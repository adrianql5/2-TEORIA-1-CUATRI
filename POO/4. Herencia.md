
# Concepto de Herencia
La herencia es uno de los conceptos fundamentales en la Programación Orientada a Objetos (POO), junto con la encapsulación y el polimorfismo. Permite que una clase nueva (llamada clase derivada o subclase) pueda adquirir las propiedades y comportamientos (atributos y métodos) de una clase existente (conocida como clase base o superclase). Esto significa que la clase derivada hereda de la clase base, y puede reutilizar o extender su funcionalidad sin tener que reescribir el código ya desarrollado.

### ¿Cómo Funciona la Herencia?
La herencia permite que una clase derivada tenga acceso a los atributos y métodos de la clase base. En términos simples:
- La clase derivada "es una" extensión de la clase base.
- Si la clase base es, por ejemplo, `Animal`, una subclase podría ser `Perro` o `Gato`, ambos "son animales" y, por lo tanto, comparten características comunes (métodos y atributos).

En POO, la relación entre una clase derivada y su clase base se describe como una relación "es-un/a". Por ejemplo:
- Si tenemos una clase `Carta` y otra clase `CartaDeMision`, podemos decir que una `CartaDeMision` "es una" `Carta`.

![[archivos/imagenes/Pasted image 20241111102820.png]]

### Ventajas de la Herencia
1. **Reutilización de código**: El código que ya está escrito, depurado y probado en una clase base puede ser reutilizado en otras clases derivadas, evitando duplicación de código.
2. **Simplificación**: Al heredar métodos y atributos de una clase base, no es necesario repetir código en todas las clases derivadas, lo que hace el código más fácil de entender y mantener.
3. **Facilidad de mantenimiento**: Cualquier cambio o mejora realizada en la clase base se refleja automáticamente en las clases derivadas.
4. **Extensibilidad**: Nuevas clases derivadas pueden crearse basadas en clases existentes, lo que facilita la expansión y evolución del programa.

### Desventajas de la Herencia
Aunque la herencia ofrece varios beneficios, también presenta algunos inconvenientes:
- **Jerarquías profundas**: Si las relaciones de herencia son muy extensas (varios niveles de jerarquía), el código se vuelve más complicado de entender. Esto dificulta saber qué métodos y atributos pertenecen a cada clase.
- **Impacto de cambios en la clase base**: Las modificaciones en la clase base afectan a todas las clases derivadas, lo que puede causar problemas si el cambio no es compatible con la implementación de las subclases.
- **Afecta la encapsulación**: Para facilitar la herencia, en algunos casos es necesario cambiar el modificador de acceso de los atributos de privado a protegido, lo cual compromete el principio de encapsulación en POO, ya que otros elementos fuera de la clase pueden tener acceso a ellos.

### Ejemplo práctico
Imaginemos un sistema de cartas donde tenemos una clase base llamada `Carta` que define atributos y métodos generales de una carta. Si queremos crear una carta específica, como `CartaDeMision`, podemos hacer que `CartaDeMision` herede de `Carta`, adquiriendo sus atributos y métodos comunes, y añadiendo cualquier comportamiento particular.

En resumen, la herencia en POO facilita la reutilización del código y la extensión de funcionalidades, pero también requiere una organización cuidadosa para evitar complicaciones innecesarias.

# Concepto de composición
La composición es uno de los pilares fundamentales de la Programación Orientada a Objetos (POO), junto con la herencia, la encapsulación y el polimorfismo. A diferencia de la herencia, que establece una relación "es-un" entre clases, la composición establece una relación "tiene-un". Es decir, una clase compuesta contiene instancias de otras clases como parte de su estructura, permitiendo así delegar responsabilidades y comportamientos específicos a estos componentes.

### ¿Qué es la Composición?
La composición es un mecanismo mediante el cual una clase (llamada clase contenedora o clase compuesta) incluye objetos de otras clases como atributos. Estos objetos son utilizados para delegar ciertas operaciones, facilitando así la construcción de funcionalidades complejas a partir de componentes más simples y reutilizables.

**Ejemplo:**
Imaginemos una clase `Automóvil` que está compuesta por objetos de las clases `Motor`, `Rueda` y `Asiento`. En este caso, `Automóvil` "tiene un" `Motor`, "tiene" varias `Rueda` y "tiene" varios `Asiento`.

```java
public class Automovil {
    private Motor motor;
    private List<Rueda> ruedas;
    private List<Asiento> asientos;

    public Automovil(Motor motor, List<Rueda> ruedas, List<Asiento> asientos) {
        this.motor = motor;
        this.ruedas = ruedas;
        this.asientos = asientos;
    }

    public void arrancar() {
        motor.encender();
    }

    // Otros métodos que delegan en los componentes
}
```

En este ejemplo, la clase `Automovil` delega la operación de encender el motor al objeto `motor` de la clase `Motor`.

### Ventajas de la Composición

1. **Distribución de Responsabilidades:**
   La composición permite que cada objeto se encargue de realizar operaciones específicas sobre sus propios atributos, promoviendo una clara separación de responsabilidades.

2. **Facilita el Mantenimiento:**
   Al distribuir las responsabilidades entre distintos objetos, es más sencillo localizar y corregir errores, así como realizar mejoras sin afectar otras partes del sistema.

3. **Mayor Flexibilidad y Extensibilidad:**
   La composición facilita la creación de nuevas funcionalidades combinando diferentes objetos, permitiendo que el sistema se expanda de manera modular.

4. **Desacoplamiento entre Clases:**
   Las clases compuestas están menos acopladas entre sí en comparación con la herencia. Un cambio en una clase componente tiene un impacto reducido en las demás clases, ya que interactúan a través de interfaces bien definidas.

### Desventajas de la Composición
1. **Mayor Complejidad de Código:**
   La composición puede resultar en una mayor cantidad de código, ya que implica la creación y gestión de múltiples objetos dentro de una clase compuesta, lo que puede aumentar la complejidad general del sistema.

2. **Tiempo de Desarrollo:**
   Implementar la composición puede requerir más tiempo de desarrollo en comparación con la herencia, ya que es necesario diseñar e implementar las clases componentes y definir claramente cómo interactuarán entre sí.

### Comparación entre Herencia y Composición

Es fundamental entender cuándo utilizar herencia y cuándo optar por la composición:

- **Herencia:** Se utiliza cuando existe una relación clara de "es-un" entre clases. Es ideal para reutilizar código y establecer una jerarquía de clases donde las subclases heredan y extienden el comportamiento de las superclases.

- **Composición:** Se emplea cuando la relación es de "tiene-un". Es preferible para crear sistemas más flexibles y modulares, donde las clases pueden combinarse de diferentes maneras sin estar fuertemente acopladas.

**Ejemplo Comparativo:**

Supongamos que estamos desarrollando un sistema para gestionar diferentes tipos de vehículos.

- **Herencia:**
  ```java
  public class Vehiculo {
      private String marca;
      private String modelo;

      public Vehiculo(String marca, String modelo) {
          this.marca = marca;
          this.modelo = modelo;
      }

      public void conducir() {
          // Lógica para conducir
      }
  }

  public class Coche extends Vehiculo {
      private int numeroDePuertas;

      public Coche(String marca, String modelo, int numeroDePuertas) {
          super(marca, modelo);
          this.numeroDePuertas = numeroDePuertas;
      }

      // Métodos específicos de Coche
  }
  ```

- **Composición:**
  ```java
  public class Motor {
      public void encender() {
          // Lógica para encender el motor
      }
  }

  public class Coche {
      private Motor motor;
      private String marca;
      private String modelo;
      private int numeroDePuertas;

      public Coche(String marca, String modelo, int numeroDePuertas, Motor motor) {
          this.marca = marca;
          this.modelo = modelo;
          this.numeroDePuertas = numeroDePuertas;
          this.motor = motor;
      }

      public void arrancar() {
          motor.encender();
      }

      // Otros métodos específicos de Coche
  }
  ```

En el ejemplo de herencia, `Coche` extiende `Vehiculo`, heredando sus atributos y métodos. En el ejemplo de composición, `Coche` contiene un objeto `Motor`, delegando la responsabilidad de encender el motor a este objeto.

### Cuándo Usar Composición

La composición es particularmente útil en los siguientes escenarios:

- **Necesidad de Reutilización de Código:** Cuando diferentes clases necesitan utilizar funcionalidades similares sin compartir una jerarquía común.
  
- **Flexibilidad en el Diseño:** Cuando se requiere que las clases puedan cambiar sus componentes en tiempo de ejecución o sean fácilmente intercambiables.
  
- **Evitar Problemas de Herencia Múltiple:** En lenguajes que no soportan herencia múltiple, la composición ofrece una alternativa para combinar funcionalidades de múltiples clases.

### Conclusión
La composición es una herramienta poderosa en la POO que permite construir sistemas modulares, flexibles y mantenibles al delegar responsabilidades a objetos componentes. Aunque puede incrementar la complejidad inicial y el tiempo de desarrollo, sus beneficios en términos de desacoplamiento y reutilización de código la hacen esencial para diseñar software robusto y escalable. Es importante equilibrar el uso de herencia y composición para aprovechar al máximo las ventajas de ambos mecanismos y evitar sus respectivas desventajas.

# Herencia vs Composición
La elección entre herencia y composición es una de las decisiones más importantes en el diseño de sistemas orientados a objetos. Aunque puede parecer que elegir entre ambas opciones es sencillo — "es-un/a" para herencia y "tiene-un/a" para composición — existen situaciones en las que esta elección no es tan clara.

### Herencia: La relación "Es-un/a"

La herencia define una relación de tipo "es-un/a" entre una clase base y una clase derivada. Esto significa que la clase derivada es una especialización de la clase base. La subclase hereda todos los atributos y métodos de la clase base y puede añadir o modificar comportamientos específicos.

- Ejemplo: Un `Perro` es un `Animal`. Si creamos un objeto de tipo `Perro`, estamos creando también un `Animal`, ya que `Perro` hereda de `Animal`.

### Composición: La relación "Tiene-un/a"

En la composición, una clase se construye incluyendo instancias de otras clases como atributos. Esto se traduce en una relación "tiene-un/a" en lugar de "es-un/a". En esta relación, la clase compuesta delega ciertas responsabilidades a los objetos que contiene.

- Ejemplo: Un `Coche` tiene un `Motor`. Un `Coche` no es un `Motor`, pero puede tener uno como parte de su estructura.

### Diferencia Conceptual: Ejemplo del Empleado y la Persona

Un caso interesante es la relación entre `Empleado` y `Persona`. 

- **Si decimos que un `Empleado` es una `Persona` (usando herencia)**, estamos estableciendo una relación fuerte de identidad entre los dos: un `Empleado` existe como una especialización de `Persona`. Sin embargo, si el `Empleado` deja de ser un `Empleado` (por ejemplo, si cambia de rol en la empresa o se retira), esto no debería significar que deja de ser una `Persona`. Este cambio en el estado de `Empleado` no afecta la identidad de `Persona`, lo que sugiere que `Empleado` no debería heredar de `Persona`.

- **Si consideramos que `Empleado` tiene una `Persona` (usando composición)**, entonces `Empleado` simplemente contiene los atributos y comportamientos de `Persona`. Esto permite que `Empleado` mantenga una relación desacoplada con `Persona`. La clase `Empleado` puede delegar todas las funcionalidades relacionadas con las personas al objeto `Persona` que contiene, sin fusionar ambas identidades. Esto refleja mejor la realidad, donde un `Empleado` es una `Persona`, pero su identidad como `Empleado` es independiente de su identidad como `Persona`.

![[archivos/imagenes/Pasted image 20241111104218.png]]
### Ventajas de Usar Composición en Casos como `Empleado` y `Persona`

1. **Separación de Identidades:** `Empleado` y `Persona` mantienen sus identidades y roles separados. Esto permite modelar con mayor precisión el mundo real, donde una persona puede tener, cambiar o dejar de tener el rol de empleado sin perder su identidad.

2. **Desacoplamiento de Clases:** Al utilizar composición, `Empleado` y `Persona` están menos acoplados. Si necesitamos cambiar detalles específicos de `Persona`, podemos hacerlo sin que esto afecte directamente a `Empleado` y viceversa.

3. **Flexibilidad:** Con composición, podemos modificar o extender las clases `Empleado` y `Persona` sin tener que preocuparse de cómo estos cambios afectarán su relación, ya que solo se comunican a través de métodos públicos.

### Desventajas de la Herencia en Casos como `Empleado` y `Persona`

1. **Acoplamiento Fuerte:** La herencia introduce un vínculo fuerte entre la clase base y la derivada, lo que hace que los cambios en `Persona` afecten a `Empleado` de manera directa, incluso si esos cambios no son relevantes para el rol de `Empleado`.

2. **Pérdida de Flexibilidad:** Si `Empleado` hereda de `Persona`, estamos limitando el diseño futuro. Si en el futuro necesitamos que `Empleado` tenga varias responsabilidades o atributos adicionales no relacionados con `Persona`, esta extensión de comportamiento podría volverse complicada de manejar con herencia.

3. **Inconsistencia de Modelado:** Si un `Empleado` hereda de `Persona`, al remover el rol de empleado (por ejemplo, al jubilarse), podríamos confundir la identidad, ya que en este caso, `Empleado` está ligado a la identidad de `Persona` y no debería estarlo en realidad.

### Conclusión: ¿Cuándo Usar Herencia vs Composición?

- **Usar Herencia** cuando la relación entre las clases es de tipo "es-un/a" y la identidad de la subclase está intrínsecamente ligada a la de la superclase. Por ejemplo, un `Ave` es un `Animal`, y su identidad como `Ave` es siempre un tipo de `Animal`.

- **Usar Composición** cuando la relación entre las clases es de tipo "tiene-un/a" o cuando las identidades están separadas. La composición es ideal cuando el rol de una clase puede variar o cambiar sin afectar la identidad de sus componentes, como en el caso de `Empleado` y `Persona`.

Optar por herencia o composición dependerá de la naturaleza de la relación entre las clases y de los requisitos de flexibilidad y desacoplamiento del sistema.

# Herencia en Java
La herencia en Java permite que una clase (la clase derivada o subclase) extienda a otra (la clase base o superclase), compartiendo sus atributos y métodos. Esto facilita la reutilización y la organización del código, aunque también implica ciertas restricciones específicas de Java.

#### Restricciones en la Herencia en Java
1. **Herencia Simple**: Java no permite la herencia múltiple (una clase solo puede heredar de una única clase base). Esto simplifica la jerarquía de clases y evita problemas como la ambigüedad de métodos y atributos.

2. **Tipos de Acceso**: Solo se heredan los atributos y métodos públicos y protegidos de la clase base, además de los que tienen acceso "paquete" dentro del mismo paquete. Los atributos privados, aunque no son directamente accesibles desde la subclase, también se heredan, y pueden ser accedidos a través de métodos públicos o protegidos en la clase base. 

3. **Encapsulación y Herencia**: La encapsulación es una prioridad en Java, de modo que los atributos deben ser privados para mantener la integridad de los datos. Aunque puede parecer que hacer los atributos públicos o protegidos facilita la herencia, esto compromete la encapsulación y aumenta la dificultad de mantenimiento del programa.

#### Preguntas Frecuentes sobre la Herencia en Java
1. **Atributos Privados y Métodos Públicos**: Si la subclase no tiene acceso directo a los atributos privados, pero sí a los métodos públicos que los utilizan, ¿cómo es posible que funcionen en la subclase?
   - **Respuesta**: La subclase hereda todos los atributos, independientemente del nivel de acceso, aunque no siempre tiene visibilidad sobre ellos. La herencia permite que los métodos públicos de la clase base funcionen en la subclase accediendo a los atributos privados que estos mismos métodos manejan.

2. **Métodos Privados y Métodos Públicos**: Si la subclase no hereda métodos privados, pero sí los métodos públicos que dependen de ellos, ¿cómo puede acceder a esos métodos privados?
   - **Respuesta**: Los métodos privados también se heredan, aunque la subclase no puede invocarlos directamente. Los métodos públicos heredados acceden a los métodos privados de la clase base, preservando la funcionalidad dentro del contexto de los métodos visibles.

![[archivos/imagenes/Pasted image 20241111104534.png]]

#### Constructores y Herencia
Los constructores tienen un comportamiento especial en Java:

1. **No se Heredan**: Los constructores son específicos de cada clase y no se heredan, ya que cada constructor está diseñado para inicializar los atributos de la clase particular en la que se encuentra.

2. **Constructor sin Argumentos**: Si la clase base tiene un constructor sin argumentos, se invoca automáticamente al instanciar la subclase. Si la subclase tiene un constructor sin argumentos, la clase base debe contar también con uno, de lo contrario, se produce un error.

3. **Constructor con Argumentos**: Si el constructor de la clase base requiere argumentos, se debe invocar explícitamente utilizando `super(…)` en el constructor de la subclase. `super` permite seleccionar el constructor adecuado en la clase base.

#### Sobreescritura de Métodos
La sobreescritura es fundamental en la herencia, ya que permite redefinir un método de la clase base en la subclase. Algunos puntos clave:

- **Requisitos de Sobreescritura**: El nombre, los parámetros y el tipo de retorno del método sobrescrito deben coincidir. El tipo de acceso en la subclase debe ser igual o más amplio que en la clase base.
- **Uso de `super`**: Para acceder a la implementación del método en la clase base desde la subclase, se utiliza `super.metodo()`. Esto es útil cuando se desea extender la funcionalidad del método heredado, reutilizando la lógica de la clase base y añadiendo funcionalidad específica en la subclase.

#### La Clase Object y Herencia en Java
Todas las clases en Java derivan implícitamente de la clase `Object`, la superclase raíz. Esto significa que heredan métodos fundamentales como:

- **toString()**: Para representar el objeto como una cadena.
- **equals() y hashCode()**: Para comparar objetos y gestionar colecciones de manera efectiva.
- **finalize()**: Invocado por el recolector de basura antes de liberar un objeto de la memoria.
- **notify() y wait()**: Métodos relacionados con el manejo de threads y la sincronización de objetos.

En resumen, Java impone una estructura clara y orientada a la seguridad en el uso de la herencia, con énfasis en mantener la encapsulación y la claridad en las relaciones de las clases.


# Clases Abstractas
Las clases abstractas son un componente esencial en la Programación Orientada a Objetos que permite estructurar el código de forma jerárquica, asegurando que ciertas clases superiores establezcan una estructura o comportamiento básico sin permitir su instanciación directa.

#### Características y Uso de las Clases Abstractas
1. **No se pueden Instanciar**: Las clases abstractas no pueden ser instanciadas directamente. Aunque pueden tener constructores, estos solo se invocan mediante `super` cuando otra clase (una subclase) hereda de la clase abstracta.
   - **Ejemplo**: Si `CartaDeEquipamiento()` es un constructor de una clase abstracta, intentar instanciarlo con `new CartaDeEquipamiento()` generará un error.

2. **Atributos y Métodos**: Las clases abstractas pueden contener atributos y métodos implementados, al igual que las clases no abstractas. Esto permite que las subclases hereden dichos métodos y atributos, fomentando la reutilización de código. Las clases abstractas suelen colocarse en niveles superiores de las jerarquías de clases, sirviendo como plantillas para clases específicas que sí se pueden instanciar.

3. **Métodos Abstractos**: Las clases abstractas pueden incluir métodos abstractos, que son métodos sin cuerpo (sin implementación), solo definidos por su nombre, tipo de retorno y parámetros.
   - **Definición de Método Abstracto**: `public abstract void nombreMetodo();`
   - **Implementación en Subclases**: Las subclases concretas que heredan de una clase abstracta deben proporcionar una implementación para todos los métodos abstractos.

4. **Invocación de Métodos Abstractos en Constructores**: Aunque un método abstracto no tiene implementación en la clase abstracta, puede ser invocado de forma indirecta desde el constructor de la clase abstracta. Esto asegura que las subclases proporcionen una implementación concreta que será llamada en el constructor.

5. **Jerarquía de Clases**: Las clases abstractas suelen estar en niveles superiores dentro de la jerarquía de clases, permitiendo la creación de subclases más especializadas. Las clases concretas o finales están en los niveles inferiores y representan implementaciones específicas que no deben ser derivadas.

#### Ventajas de las Clases Abstractas
1. **Interfaz Común**: Si una clase abstracta tiene solo métodos abstractos, asegura que todas sus subclases tengan una interfaz común, facilitando la consistencia y la comunicación entre clases en el programa.
   
2. **Reutilización de Código**: Si una clase abstracta implementa métodos que pueden ser usados sin cambios por sus subclases, esto reduce el tiempo de desarrollo y el esfuerzo, ya que el código puede ser reutilizado en múltiples subclases.

#### Clases Finales y Modificadores `final` y `static`

1. **Clases Finales**: Una clase final no permite derivaciones. Esto indica que la clase es un nodo final en la jerarquía y que su diseño no requiere ampliaciones futuras.
   
2. **Métodos Finales**: Un método final en una clase base no puede ser sobrescrito en las subclases, garantizando que su implementación permanezca inmutable.

3. **Atributos Finales**: Los atributos marcados como `final` no pueden cambiar de valor una vez que se les ha asignado uno, lo cual es útil para definir constantes.
   - **Constantes**: Generalmente, las constantes en Java se definen como `final static`, haciendo que el valor permanezca constante y accesible sin necesidad de instanciar la clase.

4. **Modificador `static`**: Al aplicar `static` en métodos o atributos, estos se almacenan en la memoria estática, permitiendo que sean accesibles sin necesidad de crear una instancia de la clase. Esto es útil para métodos utilitarios o atributos comunes a todas las instancias de la clase.

### Ejemplo de Clase Abstracta y Final en Java
```java
// Clase abstracta que define un comportamiento común para Vehículos
public abstract class Vehiculo {
    protected String marca;

    // Constructor de la clase abstracta
    public Vehiculo(String marca) {
        this.marca = marca;
    }

    // Método abstracto: cada tipo de vehículo debe definir cómo moverse
    public abstract void mover();

    // Método común implementado que se hereda en todas las subclases
    public void mostrarMarca() {
        System.out.println("Marca: " + marca);
    }
}

// Clase concreta derivada de Vehiculo
public class Coche extends Vehiculo {
    private int velocidadMaxima;

    public Coche(String marca, int velocidadMaxima) {
        super(marca);
        this.velocidadMaxima = velocidadMaxima;
    }

    @Override
    public void mover() {
        System.out.println("El coche se mueve a " + velocidadMaxima + " km/h");
    }
}

// Clase final que define un tipo específico de vehículo que no permite derivaciones
public final class Bicicleta extends Vehiculo {
    public Bicicleta(String marca) {
        super(marca);
    }

    @Override
    public void mover() {
        System.out.println("La bicicleta se mueve con pedales.");
    }
}
```

### Resumen
Las clases abstractas en Java proporcionan una estructura para la reutilización y organización del código. Aunque no pueden instanciarse, son esenciales para construir jerarquías y definir comportamientos comunes. Las clases y métodos `final` aportan estabilidad y limitan la extensión, mientras que el uso de `static` permite acceder a atributos y métodos comunes sin instancias, optimizando la memoria y el tiempo de acceso.