Escrito por **Adrián Quiroga Linares**.

# Concepto de Herencia
Permite que una clase nueva (*llamada clase derivada o subclase*) pueda **adquirir las propiedades y comportamientos** (*atributos y métodos*) de una clase existente (conocida como clase base o *superclase*). Esto significa que la clase derivada **hereda** de la clase base, y puede reutilizar o extender su funcionalidad sin tener que reescribir el código ya desarrollado.

## ¿Cómo Funciona la Herencia?
La herencia permite que una **clase derivada tenga acceso a los atributos y métodos de la superclase**. En términos simples:
- La **subclase** es una extensión de la clase base.
- Si la **superclase** es, por ejemplo, `Animal`, una subclase podría ser `Perro` o `Gato`, ambos "son animales" y, por lo tanto, comparten características comunes (métodos y atributos).

## Ventajas de la Herencia
1. **Reutilización de código**: El código que ya está escrito, depurado y probado en una clase base puede ser reutilizado en otras clases derivadas, evitando duplicación de código.
2. **Simplificación**: Al heredar métodos y atributos de una clase base, no es necesario repetir código en todas las clases derivadas, lo que hace el código más fácil de entender y mantener.
3. **Facilidad de mantenimiento**: Cualquier cambio o mejora realizada en la clase base se refleja automáticamente en las clases derivadas.
4. **Extensibilidad**: Nuevas clases derivadas pueden crearse basadas en clases existentes, lo que facilita la expansión y evolución del programa.

## Desventajas de la Herencia
Aunque la herencia ofrece varios beneficios, también presenta algunos inconvenientes:
- **Jerarquías profundas**: Si las relaciones de herencia son muy extensas (varios niveles de jerarquía), el código se vuelve más complicado de entender. Esto dificulta saber qué métodos y atributos pertenecen a cada clase.
- **Impacto de cambios en la clase base**: Las modificaciones en la clase base afectan a todas las clases derivadas, lo que puede causar problemas si el cambio no es compatible con la implementación de las subclases.
- **Afecta la encapsulación**: Para facilitar la herencia, en algunos casos es necesario cambiar el modificador de acceso de los atributos de privado a protegido, lo cual compromete el principio de encapsulación en POO, ya que otros elementos fuera de la clase pueden tener acceso a ellos.

# Concepto de composición
A diferencia de la herencia, que establece una relación "es-un" entre clases, la composición establece una relación "tiene-un". Es decir, una clase compuesta contiene instancias de otras clases como parte de su estructura, permitiendo así delegar responsabilidades y comportamientos específicos a estos componentes.
## ¿Qué es la Composición?
La composición es un mecanismo mediante el cual una clase (llamada clase contenedora o clase compuesta) incluye objetos de otras clases como atributos. Estos objetos son utilizados para delegar ciertas operaciones, facilitando así la construcción de funcionalidades complejas a partir de **componentes más simples y reutilizables.**

## Ventajas de la Composición
1. **Distribución de Responsabilidades:**
   La composición permite que cada objeto se encargue de realizar operaciones específicas sobre sus propios atributos, promoviendo una clara separación de responsabilidades.

2. **Facilita el Mantenimiento:**
   Al distribuir las responsabilidades entre distintos objetos, es más sencillo localizar y corregir errores, así como realizar mejoras sin afectar otras partes del sistema.

3. **Mayor Flexibilidad y Extensibilidad:**
   La composición facilita la creación de nuevas funcionalidades combinando diferentes objetos, permitiendo que el sistema se expanda de manera modular.

4. **Desacoplamiento entre Clases:**
   Las clases compuestas están menos acopladas entre sí en comparación con la herencia. Un cambio en una clase componente tiene un impacto reducido en las demás clases, ya que interactúan a través de interfaces bien definidas.

## Desventajas de la Composición
1. **Mayor Complejidad de Código:**
   La composición puede resultar en una mayor cantidad de código, ya que implica la creación y gestión de múltiples objetos dentro de una clase compuesta, lo que puede aumentar la complejidad general del sistema.

2. **Tiempo de Desarrollo:**
   Implementar la composición puede requerir más tiempo de desarrollo en comparación con la herencia, ya que es necesario diseñar e implementar las clases componentes y definir claramente cómo interactuarán entre sí.

## Comparación entre Herencia y Composición

Es fundamental entender cuándo utilizar herencia y cuándo optar por la composición:

- **Herencia:** Se utiliza cuando existe una relación clara de "es-un" entre clases. Es ideal para reutilizar código y establecer una jerarquía de clases donde las subclases heredan y extienden el comportamiento de las superclases.

- **Composición:** Se emplea cuando la relación es de "tiene-un". Es preferible para crear sistemas más flexibles y modulares, donde las clases pueden combinarse de diferentes maneras sin estar fuertemente acopladas.

**Ejemplo Comparativo:**
- **Herencia:**
  ```java
  public class Vehiculo {
      private String marca;
      private String modelo;

      public Vehiculo(String marca, String modelo) {
          this.marca = marca;
          this.modelo = modelo;
      }

      public void conducir() {
          // Lógica para conducir
      }
  }

  public class Coche extends Vehiculo {
      private int numeroDePuertas;

      public Coche(String marca, String modelo, int numeroDePuertas) {
          super(marca, modelo);
          this.numeroDePuertas = numeroDePuertas;
      }

      // Métodos específicos de Coche
  }
  ```

- **Composición:**
  ```java
  public class Motor {
      public void encender() {
          // Lógica para encender el motor
      }
  }

  public class Coche {
      private Motor motor;
      private String marca;
      private String modelo;
      private int numeroDePuertas;

      public Coche(String marca, String modelo, int numeroDePuertas, Motor motor) {
          this.marca = marca;
          this.modelo = modelo;
          this.numeroDePuertas = numeroDePuertas;
          this.motor = motor;
      }

      public void arrancar() {
          motor.encender();
      }

      // Otros métodos específicos de Coche
  }
  ```

![[archivos/imagenes/Pasted image 20241111104218.png]]


# Restricciones en la Herencia en Java
1. **Herencia Simple**: Java no permite la herencia múltiple (u*na clase solo puede heredar de una única superclase*). Esto simplifica la jerarquía de clases y evita problemas como la ambigüedad de métodos y atributos.

2. **Tipos de Acceso**: Solo se heredan los atributos y métodos **públicos y protegidos de la superclase**, además de los que tienen acceso "paquete" dentro del mismo paquete. Los atributos privados, aunque no son directamente accesibles desde la subclase, también se heredan, y pueden ser accedidos a través de métodos públicos o protegidos en la clase base. 

3. **Encapsulación y Herencia**: La encapsulación es una prioridad en Java, de modo que **los atributos deben ser privados** para mantener la integridad de los datos. Aunque puede parecer que hacer los atributos públicos o protegidos facilita la herencia, esto compromete la encapsulación y aumenta la dificultad de mantenimiento del programa. **SE DEBEN USAR GETTERS Y SETTERS DESDE LAS SUBCLASES.**

# Preguntas Frecuentes sobre la Herencia en Java
1. **Atributos Privados y Métodos Públicos**: Si la subclase no tiene acceso directo a los atributos privados, pero sí a los métodos públicos que los utilizan, ¿cómo es posible que funcionen en la subclase?
   - **Respuesta**: La subclase hereda todos los atributos, independientemente del nivel de acceso, aunque no siempre tiene visibilidad sobre ellos. La herencia permite que los métodos públicos de la clase base funcionen en la subclase accediendo a los atributos privados que estos mismos métodos manejan.

2. **Métodos Privados y Métodos Públicos**: Si la subclase no hereda métodos privados, pero sí los métodos públicos que dependen de ellos, ¿cómo puede acceder a esos métodos privados?
   - **Respuesta**: Los métodos privados también se heredan, aunque la subclase no puede invocarlos directamente. Los métodos públicos heredados acceden a los métodos privados de la clase base, preservando la funcionalidad dentro del contexto de los métodos visibles.

![[archivos/imagenes/Pasted image 20241111104534.png]]

# Constructores y Herencia


1. **No se Heredan**: Los constructores son específicos de cada clase y no se heredan, ya que cada constructor está diseñado para inicializar los atributos de la clase particular en la que se encuentra.

2. **Constructor sin Argumentos**: Si la superclase tiene un constructor sin argumentos, se invoca automáticamente al instanciar la subclase. Si la subclase tiene un constructor sin argumentos, la **clase base debe contar también con uno**, de lo contrario, se produce un error.

3. **Constructor con Argumentos**: Si el constructor de la clase base requiere argumentos, se debe invocar explícitamente utilizando `super(…)` en el constructor de la subclase. `super` permite seleccionar el constructor adecuado en la clase base. Solo puede acceder a los elementos de clase **inmediatamente superior**.

# Sobreescritura de Métodos
La sobreescritura es fundamental en la herencia, ya que permite redefinir un método de la clase base en la subclase. Algunos puntos clave:

- **Requisitos de Sobreescritura**: **El nombre, los parámetros y el tipo de retorno del método sobrescrito deben coincidir**. El tipo de acceso en la subclase debe ser igual o más amplio que en la clase base.
- **Uso de `super`**: Para acceder a la implementación del método en la superclase desde la subclase, se utiliza `super.metodo()`. Esto es útil cuando se desea extender la funcionalidad del método heredado, reutilizando la lógica de la clase base y añadiendo funcionalidad específica en la subclase.
- Si queremos usar el metodo de la **subclase** debemos escribir `@Override` encima del método.
### La Clase Object y Herencia en Java
Todas las clases en Java derivan implícitamente de la clase `Object`, la superclase raíz. Esto significa que heredan métodos fundamentales como:
- **toString()**: Para representar el objeto como una cadena.
- **equals() y hashCode()**: Para comparar objetos y gestionar colecciones de manera efectiva.
- **finalize()**: Invocado por el recolector de basura antes de liberar un objeto de la memoria.
- **notify() y wait()**: Métodos relacionados con el manejo de threads y la sincronización de objetos.

En resumen, Java impone una estructura clara y orientada a la seguridad en el uso de la herencia, con énfasis en mantener la encapsulación y la claridad en las relaciones de las clases.

# Clases Abstractas
Las clases abstractas son clases que **no se pueden instanciar**.

## Características y Uso de las Clases Abstractas
1. **No se pueden Instanciar**: Las clases abstractas no pueden ser instanciadas directamente. Aunque pueden tener constructores, estos solo se invocan mediante `super` cuando otra clase (una subclase) hereda de la clase abstracta.
   - **Ejemplo**: Si `CartaDeEquipamiento()` es un constructor de una clase abstracta, intentar instanciarlo con `new CartaDeEquipamiento()` generará un error.

2. **Atributos y Métodos**: Las clases abstractas pueden contener atributos y métodos implementados, al igual que las clases no abstractas. Esto permite que las subclases hereden dichos métodos y atributos, fomentando la reutilización de código. Las clases abstractas suelen colocarse en niveles superiores de las jerarquías de clases, sirviendo como plantillas para clases específicas que sí se pueden instanciar.

3. **Métodos Abstractos**: Las clases abstractas pueden incluir métodos abstractos, que son métodos sin cuerpo (sin implementación), solo definidos por su nombre, tipo de retorno y parámetros.
   - **Definición de Método Abstracto**: `public abstract void nombreMetodo();`
   - **Implementación en Subclases**: Las subclases concretas que heredan de una clase abstracta deben proporcionar una implementación para todos los métodos abstractos.

4. **Invocación de Métodos Abstractos en Constructores**: Aunque un método abstracto no tiene implementación en la clase abstracta, puede ser invocado de forma indirecta desde el constructor de la clase abstracta. Esto asegura que las subclases proporcionen una implementación concreta que será llamada en el constructor.

5. **Jerarquía de Clases**: Las clases abstractas suelen estar en niveles superiores dentro de la jerarquía de clases, permitiendo la creación de subclases más especializadas. Las clases concretas o finales están en los niveles inferiores y representan implementaciones específicas que no deben ser derivadas.

## Ventajas de las Clases Abstractas
1. **Interfaz Común**: Si una clase abstracta tiene solo métodos abstractos, asegura que todas sus subclases tengan una interfaz común, facilitando la consistencia y la comunicación entre clases en el programa.
   
2. **Reutilización de Código**: Si una clase abstracta implementa métodos que pueden ser usados sin cambios por sus subclases, esto reduce el tiempo de desarrollo y el esfuerzo, ya que el código puede ser reutilizado en múltiples subclases.

## Clases Finales y Modificadores `final` y `static`

1. **Clases Finales**: Una clase final no permite derivaciones. Esto indica que la clase es un nodo final en la jerarquía y que su diseño no requiere ampliaciones futuras.
   
2. **Métodos Finales**: Un método final en una clase base no puede ser sobrescrito en las subclases, garantizando que su implementación permanezca inmutable.

3. **Atributos Finales**: Los atributos marcados como `final` no pueden cambiar de valor una vez que se les ha asignado uno, lo cual es útil para definir constantes.
   - **Constantes**: Generalmente, las constantes en Java se definen como `final static`, haciendo que el valor permanezca constante y accesible sin necesidad de instanciar la clase.

4. **Modificador `static`**: Al aplicar `static` en métodos o atributos, estos se almacenan en la memoria estática, permitiendo que sean accesibles sin necesidad de crear una instancia de la clase. Esto es útil para métodos utilitarios o atributos comunes a todas las instancias de la clase.

### Ejemplo de Clase Abstracta y Final en Java
```java
// Clase abstracta que define un comportamiento común para Vehículos
public abstract class Vehiculo {
    protected String marca;

    // Constructor de la clase abstracta
    public Vehiculo(String marca) {
        this.marca = marca;
    }

    // Método abstracto: cada tipo de vehículo debe definir cómo moverse
    public abstract void mover();

    // Método común implementado que se hereda en todas las subclases
    public void mostrarMarca() {
        System.out.println("Marca: " + marca);
    }
}

// Clase concreta derivada de Vehiculo
public class Coche extends Vehiculo {
    private int velocidadMaxima;

    public Coche(String marca, int velocidadMaxima) {
        super(marca);
        this.velocidadMaxima = velocidadMaxima;
    }

    @Override
    public void mover() {
        System.out.println("El coche se mueve a " + velocidadMaxima + " km/h");
    }
}

// Clase final que define un tipo específico de vehículo que no permite derivaciones
public final class Bicicleta extends Vehiculo {
    public Bicicleta(String marca) {
        super(marca);
    }

    @Override
    public void mover() {
        System.out.println("La bicicleta se mueve con pedales.");
    }
}
```

### Resumen
Las clases abstractas en Java proporcionan una estructura para la reutilización y organización del código. Aunque no pueden instanciarse, son esenciales para construir jerarquías y definir comportamientos comunes. Las clases y métodos `final` aportan estabilidad y limitan la extensión, mientras que el uso de `static` permite acceder a atributos y métodos comunes sin instancias, optimizando la memoria y el tiempo de acceso.