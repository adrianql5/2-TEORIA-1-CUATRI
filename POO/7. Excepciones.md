
Escrito por **Adrián Quiroga Linares**.

### Concepto de Excepción 
La gestión de excepciones es una tarea fundamental en el desarrollo de software, ya que permite manejar adecuadamente los errores y las situaciones imprevistas que pueden surgir durante la ejecución de un programa. Tratar correctamente las excepciones mejora la usabilidad del sistema y facilita su mantenimiento, ya que organiza y separa el código según sus responsabilidades.

#### Separación Lógica de Código
Para mantener un diseño claro y modular, se deben diferenciar los siguientes tipos de código en un programa:

1. **Funcionalidad del método**: Código que implementa lo que el método debe realizar.
    
    - Ejemplo: En un método que calcula el promedio de una lista de números, la funcionalidad se concentra en sumar los valores y dividir entre el total.
2. **Interacción con usuarios u otros sistemas**: Código que se encarga de recibir datos de entrada y devolver resultados.
    
    - Ejemplo: Pedir al usuario que ingrese números por consola.
3. **Acceso y almacenamiento de datos**: Código que lee o escribe datos en un sistema de almacenamiento.
    
    - Ejemplo: Guardar los resultados del cálculo en un archivo.
4. **Gestión de errores**: Código diseñado para identificar y manejar excepciones que puedan surgir en el proceso.
    
    - Ejemplo: Detectar si la lista de números está vacía antes de intentar calcular el promedio.

#### ¿Qué es una Excepción?
Una excepción es cualquier evento inesperado que ocurre durante la ejecución de un programa y que interrumpe el flujo normal del código. Estas no solo incluyen errores tradicionales, como fallos en cálculos, sino también situaciones que requieren una respuesta especial dentro de la lógica del programa.

- **Errores**:
    
    - **Ejemplo**: Una división por cero.
        
        ```java
        int divisor = 0;
        int resultado = 10 / divisor; // Esto lanza una ArithmeticException.
        ```
        
- **Condiciones esperadas pero no ideales**:
    
    - **Ejemplo**: Introducir un comando incompleto en una interfaz.
        
        ```java
        if (comando.isEmpty()) {
            System.out.println("Comando incompleto. Por favor, intente de nuevo.");
        }
        ```
        

#### Gestión de Excepciones en Java

En Java, el manejo de excepciones sigue un enfoque que separa claramente el código relacionado con:

1. **Detección**: Identificar que algo inesperado ha ocurrido.
2. **Comunicación**: Notificar o registrar el problema para su análisis.
3. **Tratamiento**: Definir cómo el programa responde al evento.

Por ejemplo, una manera típica de manejar excepciones en Java es mediante bloques `try-catch`:

```java
public static void main(String[] args) {
    try {
        int divisor = 0;
        int resultado = 10 / divisor; // Puede lanzar una ArithmeticException.
    } catch (ArithmeticException e) {
        System.out.println("Error: División por cero no permitida.");
    }
}
```

Este enfoque asegura que el código principal se mantenga enfocado en su funcionalidad, mientras que la lógica para manejar errores se encuentra bien delimitada en bloques específicos.

### Definición de Excepciones

La correcta definición de excepciones es crucial antes de planificar su gestión en tiempo de ejecución. Implica identificar:

1. **Qué excepciones pueden ocurrir.**
2. **En qué métodos se producirán.**

#### Especificación de Excepciones como Clases

En Java, las excepciones se representan mediante clases derivadas de la clase base **`Throwable`**, que proporciona métodos útiles para manejar información sobre la excepción. Los dos métodos más comunes son:

- **`getMessage()`**: Devuelve el mensaje asociado a la excepción.
    
    ```java
    try {
        throw new Exception("Error: archivo no encontrado");
    } catch (Exception e) {
        System.out.println(e.getMessage()); // Muestra: Error: archivo no encontrado
    }
    ```
    
- **`printStackTrace()`**: Imprime la secuencia de invocaciones que llevó a la excepción.
    
    ```java
    try {
        throw new Exception("Error crítico");
    } catch (Exception e) {
        e.printStackTrace();
    }
    ```
    

#### Tipos de Excepciones en Java

1. **Chequeadas (Checked):**
    
    - **Características**:
        - Se verifican en **tiempo de compilación**.
        - Los métodos deben declarar explícitamente que pueden lanzarlas mediante `throws`.
        - Derivan de la clase **`Exception`** (excepto de sus subclases directas, como `RuntimeException`).
    - **Ejemplo**:
        
        ```java
        import java.io.*;
        
        public void leerArchivo(String nombreArchivo) throws IOException {
            FileReader archivo = new FileReader(nombreArchivo);
        }
        ```
        
        Si el archivo no existe, el compilador obliga a manejar la excepción mediante un bloque `try-catch` o propagándola con `throws`.
2. **No chequeadas (Unchecked):**
    
    - **Características**:
        
        - No se verifican en tiempo de compilación.
        - Derivan de las clases **`RuntimeException`** o **`Error`**.
        - El programador es responsable de identificarlas y tratarlas.
    - **Ejemplo**:
        
        ```java
        public void dividir(int a, int b) {
            System.out.println(a / b); // Lanza ArithmeticException si b es 0.
        }
        ```
        
    - **Ejemplo Clásico: NullPointerException**: Esta es no chequeada porque normalmente no es posible "arreglar" una referencia nula sin un cambio significativo en el código.
        

#### Crear Excepciones Propias

Definir excepciones personalizadas proporciona control adicional. Estas clases derivan de **`Exception`** e incluyen un constructor que utiliza el de la clase base:

```java
class MiExcepcion extends Exception {
    public MiExcepcion(String mensaje) {
        super(mensaje); // Llama al constructor de Exception.
    }
}
```

Uso:

```java
public void validarEdad(int edad) throws MiExcepcion {
    if (edad < 18) {
        throw new MiExcepcion("Edad menor a 18 años no permitida.");
    }
}
```

#### Declaración de Excepciones en Métodos

- Los métodos que pueden lanzar excepciones chequeadas deben incluir `throws` en su **firma**:
    
    ```java
    public void procesar() throws IOException, SQLException {
        // Puede lanzar IOException o SQLException.
    }
    ```
    
- Si las excepciones comparten una misma clase base, se puede especificar esta clase:
    
    ```java
    public void procesar() throws Exception {
        // Maneja cualquier excepción derivada de Exception.
    }
    ```
    

#### Excepciones en Constructores

Los constructores también pueden lanzar excepciones, y estas deben declararse:

```java
public MiClase(String rutaArchivo) throws FileNotFoundException {
    FileReader archivo = new FileReader(rutaArchivo); // Puede lanzar FileNotFoundException.
}
```

Este enfoque de declarar y etiquetar las excepciones ayuda a que los desarrolladores sean conscientes de los posibles problemas y diseñen estrategias para gestionarlos adecuadamente.

### Gestión de Excepciones: Lanzar (`throw`)

Cuando un método detecta una condición que impide continuar con la ejecución normal, puede **lanzar una excepción**. Este proceso tiene dos etapas principales:

1. **Detección de la excepción**: Identificar la condición que activa el lanzamiento de la excepción.
2. **Generación de la excepción**: Crear y lanzar un objeto del tipo de excepción correspondiente, transfiriendo el control al código que gestionará dicha excepción.

#### Detección de la Excepción

Dentro del método que puede lanzar una excepción, se especifican las condiciones que provocan esta acción. Por ejemplo:

- **División entre cero**:
    
    ```java
    public void dividir(int numerador, int denominador) throws ArithmeticException {
        if (denominador == 0) {
            throw new ArithmeticException("No se puede dividir por cero");
        }
        System.out.println("Resultado: " + (numerador / denominador));
    }
    ```
    
- **Errores específicos en una lógica personalizada**: Si un proyecto define códigos de error, estos se pueden manejar como excepciones específicas. Ejemplo:
    
    ```java
    public void procesarJuego(int codigoError) throws IllegalArgumentException {
        if (codigoError == 404) {
            throw new IllegalArgumentException("Código de error: 404. Elemento no encontrado.");
        }
    }
    ```
    

#### Generación y Lanzamiento de la Excepción

Al detectar la condición problemática, se crea un **objeto del tipo de excepción** correspondiente. Este objeto encapsula información útil sobre el error, como:

- Una descripción del problema.
- Datos de contexto, como valores relacionados con la excepción.

El lanzamiento de la excepción se realiza con la palabra clave **`throw`**, y el flujo de ejecución del método se interrumpe en ese punto. El programa transfiere el control al bloque de código que maneja esta excepción.

#### Ejemplo: Lanzar una Excepción

```java
public void validarEdad(int edad) throws IllegalArgumentException {
    if (edad < 18) {
        throw new IllegalArgumentException("Edad no válida: " + edad + ". Debe ser mayor o igual a 18.");
    }
    System.out.println("Edad válida: " + edad);
}
```

- La excepción incluye información contextual (`"Edad no válida: ..."`) como mensaje.
- El flujo del programa abandona inmediatamente el método y se transfiere al manejador de excepciones.

#### Información en el Contexto de la Excepción

Es habitual pasar información adicional como argumentos al constructor de la excepción para facilitar su manejo posterior:

- **Descripción textual del problema**:
    
    ```java
    throw new Exception("Archivo no encontrado");
    ```
    
- **Referencias a objetos útiles**:
    
    ```java
    public void procesarDatos(Object datos) throws IllegalArgumentException {
        if (datos == null) {
            throw new IllegalArgumentException("Datos inválidos: " + datos);
        }
    }
    ```
    

#### Flujo del Programa

Cuando se lanza una excepción:

1. Se crea el objeto de excepción.
2. Se detiene la ejecución del método en el punto del `throw`.
3. El control se transfiere al código que captura y gestiona la excepción.

#### Ejemplo Completo

```java
public void metodoA() {
    try {
        metodoB();
    } catch (ArithmeticException e) {
        System.out.println("Excepción capturada: " + e.getMessage());
    }
}

public void metodoB() throws ArithmeticException {
    int numerador = 10;
    int denominador = 0;
    if (denominador == 0) {
        throw new ArithmeticException("No se puede dividir por cero");
    }
    System.out.println("Resultado: " + (numerador / denominador));
}
```

- El método **`metodoB`** lanza una excepción al detectar un error (división por cero).
- El método **`metodoA`** captura la excepción y maneja el problema.

#### Consideraciones al Lanzar Excepciones

1. **Especificar en la firma del método**: Si un método puede lanzar una excepción chequeada, debe indicarse en la firma del método con `throws`.
2. **Solo para condiciones excepcionales**: Lanzar excepciones solo para situaciones que realmente representen un error o condición especial que requiera atención.
3. **Incluir información útil**: Añadir mensajes descriptivos o datos relevantes en el objeto de excepción para facilitar el diagnóstico.

##@# Resumen

El uso de `throw` permite a un método señalar que no puede continuar con su ejecución normal. Este mecanismo garantiza que el programa pueda manejar condiciones excepcionales de manera ordenada y con información suficiente para resolver el problema o notificarlo adecuadamente.



### 5. Gestión de Excepciones: Tratar (`catch`)

Cuando se lanza una excepción, se transfiere un objeto de tipo excepción al **bloque `catch`** asociado. Este bloque captura y gestiona la excepción utilizando la información proporcionada por el objeto de excepción, como el mensaje descriptivo o los datos adicionales.

#### Proceso de Captura de la Excepción

1. **Lanzamiento de la Excepción**: Se genera y lanza un objeto de excepción desde un bloque `try` o un método invocado dentro de este.
2. **Captura**: El flujo de ejecución entra en el bloque `catch` que coincide con el tipo de excepción lanzada.
3. **Tratamiento**: En el bloque `catch` se define el comportamiento para manejar la excepción, como:
    - Mostrar un mensaje al usuario.
    - Registrar el error en un archivo de logs.
    - Realizar acciones compensatorias, como cerrar recursos.

#### Ejemplo Básico

```java
public void dividir(int a, int b) {
    try {
        int resultado = a / b;
        System.out.println("Resultado: " + resultado);
    } catch (ArithmeticException e) {
        System.out.println("Error: " + e.getMessage());
    }
}
```

- **`try`**: Intenta ejecutar el código que podría generar una excepción.
- **`catch`**: Captura y maneja la excepción si ocurre.

#### Restricciones entre Bloques `try`–`catch`

1. **Relación Obligatoria**:
    
    - Cada bloque `catch` debe estar asociado a un único bloque `try`.
    - Un bloque `try` debe tener al menos un bloque `catch` o un bloque `finally`.
2. **Cantidad de Bloques `catch`**:
    
    - Puede haber tantos bloques `catch` como tipos de excepciones a manejar.
    - También es posible tener menos bloques `catch` si las excepciones comparten una clase base.
3. **Orden y Herencia**:
    
    - Los bloques `catch` deben ir de más específico a más general.
    - Una excepción capturada en un `catch` para una clase base no será manejada por un `catch` posterior para una subclase.
    
    ```java
    try {
        // Código que genera una excepción
    } catch (Exception e) {
        // Captura genérica
    } catch (IOException e) {
        // Este bloque nunca se ejecutará porque Exception es más general.
    }
    ```
    
4. **Multi-Catch**: Permite capturar varias excepciones en un solo bloque, simplificando el código cuando el tratamiento es idéntico:
    
    ```java
    try {
        // Código que puede generar múltiples excepciones
    } catch (IOException | ArithmeticException e) {
        System.out.println("Excepción capturada: " + e.getMessage());
    }
    ```
    

#### Bloque `finally`

El bloque **`finally`** se ejecuta siempre, independientemente de si ocurre o no una excepción. Es útil para:

- Liberar recursos.
- Cerrar conexiones.
- Realizar operaciones finales necesarias.

Ejemplo:

```java
public void procesarArchivo() {
    FileReader reader = null;
    try {
        reader = new FileReader("archivo.txt");
        // Procesar el archivo
    } catch (IOException e) {
        System.out.println("Error al procesar el archivo: " + e.getMessage());
    } finally {
        if (reader != null) {
            try {
                reader.close();
            } catch (IOException e) {
                System.out.println("Error al cerrar el archivo.");
            }
        }
    }
}
```

#### Ejemplo Completo con Múltiples `catch`

```java
public void procesar(int a, int b, String archivo) {
    try {
        int resultado = a / b; // Posible ArithmeticException
        FileReader reader = new FileReader(archivo); // Posible FileNotFoundException
    } catch (ArithmeticException e) {
        System.out.println("Error de cálculo: " + e.getMessage());
    } catch (FileNotFoundException e) {
        System.out.println("Archivo no encontrado: " + e.getMessage());
    } finally {
        System.out.println("Bloque finally ejecutado");
    }
}
```

#### Resumen del Bloque `catch`

- Permite capturar una excepción específica lanzada en el bloque `try`.
- Utiliza el objeto de excepción transferido para manejarla, proporcionando información sobre el error.
- Es clave estructurar los bloques `catch` de forma eficiente, usando la herencia y el polimorfismo para evitar redundancias.

---

### 6. Revisitando Generación de Excepciones

Un método que invoca a otro que lanza una excepción no está obligado a capturarla inmediatamente. Puede:

- Capturarla localmente usando un bloque `try–catch`.
- Delegar el tratamiento a otro método o nivel superior.

#### Encadenamiento de Excepciones

Cuando el tratamiento final de las excepciones ocurre en un método más elevado en la jerarquía de llamadas, los métodos intermedios pueden **propagar** la excepción:

```java
public void metodoA() throws Exception {
    metodoB();
}

public void metodoB() throws Exception {
    metodoC();
}

public void metodoC() throws Exception {
    throw new Exception("Error en metodoC");
}
```

- **Encadenamiento**: La excepción lanzada en `metodoC` es propagada a `metodoB` y, finalmente, a `metodoA`, donde puede ser capturada.
- **Unificación del Tratamiento**: Permite centralizar la gestión de excepciones en un único lugar, mejorando la organización y mantenimiento del código.

---

### Usos Prácticos del Encadenamiento

1. **Centralizar Logs o Notificaciones**:
    - Los métodos finales pueden registrar el error en un sistema centralizado.
2. **Evitar Sobrecarga en Métodos Intermedios**:
    - Los métodos que no están preparados para manejar excepciones específicas delegan esta responsabilidad.
3. **Unificación de Mensajes para Usuarios**:
    - El método final puede transformar excepciones técnicas en mensajes comprensibles para el usuario final.