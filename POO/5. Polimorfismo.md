# Polimorfismo en herencia
El **polimorfismo** es uno de los principios fundamentales de la Programación Orientada a Objetos (POO) y permite que un mismo objeto pueda comportarse de distintas maneras dependiendo del contexto, es decir, de la forma en que se utilice en el programa.

#### Concepto de Polimorfismo
El polimorfismo permite que:
1. Un objeto se comporte como una instancia de la clase de la cual fue instanciado usando `new`, es decir, como la clase específica a la cual pertenece.
2. Un objeto también puede comportarse como una instancia de cualquier clase de la que herede, es decir, como una instancia de alguna de las clases superiores en la jerarquía de clases.

#### Ejemplo de Polimorfismo
Por ejemplo, si tenemos una jerarquía de clases donde `Animal` es la clase base, y `Perro` y `Gato` son clases derivadas, un objeto de `Perro` puede comportarse tanto como un `Perro` o, en contextos donde sea necesario, como un `Animal`. Esto es posible porque `Perro` hereda las propiedades y métodos de `Animal`.

#### Polimorfismo y Herencia
El polimorfismo está estrechamente relacionado con la herencia y la sobrescritura de métodos. Cuando una subclase sobrescribe métodos de su clase base, estos métodos pueden comportarse de manera diferente dependiendo de la clase específica del objeto que los llama. Esta característica es fundamental para permitir que las clases derivadas proporcionen una implementación propia para métodos heredados, lo cual favorece la flexibilidad y la extensibilidad del código.

#### Polimorfismo y Clases Abstractas
A pesar de que las clases abstractas no pueden ser instanciadas directamente (es decir, no se puede utilizar `new` para crear un objeto de una clase abstracta), el polimorfismo permite que un objeto de una clase derivada se trate como una instancia de esa clase abstracta.

**¿Existe una contradicción en esto?**  
No. Aunque las clases abstractas no pueden ser instanciadas, pueden ser utilizadas para definir un tipo. Esto significa que se pueden crear referencias de una clase abstracta que apunten a objetos de sus subclases. Estas referencias permiten invocar métodos de la clase abstracta que hayan sido implementados o sobrescritos en las clases derivadas, asegurando que las subclases cumplan con ciertos comportamientos y restricciones establecidos en la clase abstracta.

#### Ejemplo de Polimorfismo con Clases Abstractas

Imaginemos la clase abstracta `Forma`, de la que derivan clases como `Circulo` y `Cuadrado`:

```java
public abstract class Forma {
    public abstract void dibujar();
}

public class Circulo extends Forma {
    @Override
    public void dibujar() {
        System.out.println("Dibujando un círculo");
    }
}

public class Cuadrado extends Forma {
    @Override
    public void dibujar() {
        System.out.println("Dibujando un cuadrado");
    }
}
```

Podemos declarar un array de `Forma` y almacenar en él objetos `Circulo` y `Cuadrado`:

```java
Forma[] formas = {new Circulo(), new Cuadrado()};

for (Forma forma : formas) {
    forma.dibujar(); // Invoca el método apropiado dependiendo del tipo real del objeto
}
```

Aquí, el polimorfismo permite que cada objeto se comporte de acuerdo con su tipo específico (`Circulo` o `Cuadrado`), aunque se le trate como una `Forma`. Este comportamiento es posible gracias a la herencia y la sobrescritura de métodos.

### Resumen
El polimorfismo en herencia permite que un mismo objeto pueda utilizarse de varias maneras, según la clase en la jerarquía a la que se haga referencia en cada contexto. Las clases abstractas, aunque no se pueden instanciar directamente, permiten definir tipos y asegurar comportamientos consistentes en las clases derivadas. De este modo, el polimorfismo y las clases abstractas facilitan la extensibilidad, la flexibilidad y la organización del código en la POO.

# Upcasting & Downcasting
En programación orientada a objetos, **upcasting** y **downcasting** son mecanismos de conversión de tipos que permiten cambiar la perspectiva desde la cual se trata un objeto dentro de una jerarquía de clases. Ambos son tipos de **casting de objetos**, que facilita la manipulación de objetos en jerarquías complejas y el uso de polimorfismo.

#### Upcasting
El **upcasting** ocurre cuando un objeto de una clase derivada (subclase) se trata como un objeto de una clase base (superclase). Esto es común en escenarios donde se desea que un objeto de una subclase se comporte con las propiedades y métodos definidos en la clase base o en las clases superiores de su jerarquía. 

Ejemplo:

```java
class Animal {
    public void hacerSonido() {
        System.out.println("El animal hace un sonido");
    }
}

class Perro extends Animal {
    @Override
    public void hacerSonido() {
        System.out.println("El perro ladra");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal miAnimal = new Perro(); // Upcasting
        miAnimal.hacerSonido(); // Imprime "El perro ladra"
    }
}
```

En este caso, el objeto `miAnimal` es un `Perro` (subclase) que se trata como `Animal` (superclase). Aquí, aunque `miAnimal` es referenciado como `Animal`, sigue siendo un `Perro`, y los métodos sobrescritos en `Perro` son invocados si existen en el objeto real.

**Ventajas de Upcasting:**
1. Facilita el polimorfismo, permitiendo que una referencia de una clase base almacene un objeto de cualquier subclase.
2. Proporciona mayor flexibilidad en la estructura del código, permitiendo manejar diferentes tipos de objetos como si fuesen de la misma clase base.

#### Downcasting
El **downcasting** es el proceso opuesto al upcasting: un objeto de una clase base se trata como un objeto de una clase derivada. Es menos común que el upcasting, ya que se realiza únicamente cuando se necesita acceder a los atributos o métodos específicos de la subclase, los cuales no están definidos en la superclase.

Ejemplo:

```java
public class Main {
    public static void main(String[] args) {
        Animal miAnimal = new Perro(); // Upcasting
        if (miAnimal instanceof Perro) {
            Perro miPerro = (Perro) miAnimal; // Downcasting
            miPerro.hacerSonido(); // Imprime "El perro ladra"
        }
    }
}
```

Aquí, `miAnimal` es tratado nuevamente como `Perro`, accediendo así a los métodos específicos de `Perro`.

**Consideraciones del Downcasting:**
1. **Riesgo de error en tiempo de ejecución**: si el objeto no es realmente de la clase a la que se realiza el cast, se lanzará una excepción `ClassCastException`.
2. **Verificación con `instanceof`**: antes de un downcasting, es recomendable verificar si el objeto realmente es una instancia de la subclase deseada para evitar errores en tiempo de ejecución.

#### Cambios en la Accesibilidad de Atributos y Métodos
El **casting de objetos** no modifica el objeto en sí, sino que cambia los métodos y atributos accesibles desde la referencia de ese objeto. Solo estarán disponibles los métodos y atributos:
1. **Definidos en la clase hacia la que se ha hecho el casting**.
2. **Heredados por esta clase** de sus clases base en la jerarquía.

Esto significa que en un upcasting, el objeto solo tendrá acceso a los métodos y atributos de la clase base, aunque siga siendo internamente un objeto de la subclase. 

### Resumen
**Upcasting** y **downcasting** son herramientas clave en la POO para trabajar con jerarquías de clases y aprovechar el polimorfismo. Con upcasting, un objeto de subclase puede ser tratado como un objeto de una clase base, facilitando la estructura polimórfica del programa. Con downcasting, un objeto de una clase base se trata como una subclase, permitiendo acceder a los métodos específicos de la subclase.


# Upcasting
**Upcasting** es una práctica común en programación orientada a objetos, utilizada para facilitar el polimorfismo. Permite que un objeto de una clase derivada se trate como un objeto de su clase base, lo que resulta natural ya que cualquier instancia de una subclase también es una instancia de su superclase.

#### Características de Upcasting
- **No necesita especificar el cast**: Al realizar upcasting, no es necesario declarar explícitamente el cambio de tipo en el código. La subclase se ajusta automáticamente a la superclase porque hereda todos sus métodos y atributos.
  
- **Pérdida de visibilidad de métodos específicos**: Los métodos y atributos exclusivos de la subclase dejan de ser accesibles desde la referencia de la superclase. Esto significa que, aunque el objeto sigue siendo de la subclase, solo puede acceder a los métodos de la clase base.

- **Uso de métodos sobrescritos**: Si un método está sobrescrito en la subclase, al realizar upcasting el objeto utiliza la implementación del método de la subclase, no la de la superclase. Esto permite que el polimorfismo funcione correctamente, ya que se utiliza la implementación específica de la clase real del objeto.

- **Diseño enfocado al polimorfismo**: Upcasting es clave en el diseño de programas orientados a objetos que requieren polimorfismo, especialmente al trabajar con clases abstractas. Permite un enfoque flexible y escalable, donde las subclases pueden tener implementaciones específicas mientras que se manejan de manera genérica desde la referencia de la superclase.

#### Ejemplo de Upcasting

```java
class Animal {
    public void hacerSonido() {
        System.out.println("El animal hace un sonido");
    }
}

class Perro extends Animal {
    @Override
    public void hacerSonido() {
        System.out.println("El perro ladra");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal miAnimal = new Perro(); // Upcasting implícito
        miAnimal.hacerSonido(); // Imprime "El perro ladra"
    }
}
```

En este ejemplo, `miAnimal` es una referencia de tipo `Animal` que apunta a un objeto `Perro`. Al llamar a `hacerSonido()`, se ejecuta la versión sobrescrita del método en `Perro`, demostrando el comportamiento polimórfico.

**Consideraciones:**
- **Acceso limitado a métodos específicos**: Una vez realizado el upcasting, no es posible acceder a métodos y atributos específicos de `Perro` sin hacer downcasting.
- **Diseño cuidadoso**: Es importante elegir correctamente los métodos para sobrescribir en las subclases y definir claramente la estructura de la jerarquía para que el polimorfismo sea eficiente y claro en su implementación.
---

# Downcasting

**Downcasting** se utiliza para tratar un objeto de una clase base como si fuera de una subclase específica. Este proceso debe hacerse explícitamente y es necesario indicar el tipo de clase derivada a la que queremos "convertir" el objeto de la superclase.

#### Características de Downcasting
- **Requiere cast explícito**: Para realizar un downcasting, es necesario forzar el cambio de tipo utilizando una notación explícita `(<NombreClaseDerivada>)`. Esto le indica al compilador que se desea tratar el objeto como un tipo específico de subclase.

- **Verificación en tiempo de ejecución**: Aunque el código compila, el casting real ocurre en tiempo de ejecución. Si el objeto no pertenece a la subclase a la que se intenta convertir, se lanza una excepción `ClassCastException`.

- **Uso del operador `instanceof`**: Para evitar errores en tiempo de ejecución, se recomienda verificar el tipo del objeto con `instanceof` antes de realizar el downcasting. Esto garantiza que el objeto sea una instancia de la subclase específica.

#### Ejemplo de Downcasting

```java
class Animal {
    public void hacerSonido() {
        System.out.println("El animal hace un sonido");
    }
}

class Perro extends Animal {
    public void ladrar() {
        System.out.println("El perro ladra");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal miAnimal = new Perro(); // Upcasting
        if (miAnimal instanceof Perro) {
            Perro miPerro = (Perro) miAnimal; // Downcasting
            miPerro.ladrar(); // Imprime "El perro ladra"
        }
    }
}
```

En este caso, `miAnimal` es tratado como un `Perro` mediante downcasting, lo que permite acceder a `ladrar()`, un método exclusivo de `Perro`.

**Consideraciones:**
- **Excepción en tiempo de ejecución**: Si el objeto no es del tipo `Perro`, el casting fallará, lanzando una excepción `ClassCastException`.
- **Uso de `instanceof`**: Verificar el tipo con `instanceof` ayuda a prevenir excepciones y asegura que el casting solo se realice si el objeto pertenece realmente a la subclase. 

### Resumen
- **Upcasting** facilita el polimorfismo, permitiendo tratar un objeto de una subclase como uno de su clase base sin necesidad de una conversión explícita.
- **Downcasting** permite acceder a métodos específicos de la subclase, aunque requiere cast explícito y verificación de tipo con `instanceof` para evitar errores.


# Beneficios del Polimorfismo

El **polimorfismo** es un concepto central en la programación orientada a objetos (POO) que permite que un mismo método funcione de manera diferente según la clase que lo implemente. Este principio aporta varias ventajas importantes en el desarrollo de software:

#### 1. Simplificación del Código
El polimorfismo permite manejar diferentes objetos como si pertenecieran a una misma clase base, lo cual simplifica el código:
- Los objetos derivados de una jerarquía se pueden tratar mediante referencias de la clase base.
- Permite invocar métodos comunes a todas las clases derivadas desde una única referencia de la clase base, reduciendo la redundancia y manteniendo el código más limpio y manejable.

#### 2. Extensibilidad del Programa
Gracias al polimorfismo, se pueden extender programas añadiendo nuevas clases a la jerarquía sin realizar grandes cambios en el código existente:
- Nuevas clases que hereden de una clase base e implementen métodos comunes pueden ser integradas sin modificar el comportamiento general del programa.
- El código que maneja la jerarquía de clases no necesita ser alterado porque las nuevas clases implementan los métodos de la clase base, respetando la estructura definida.

#### 3. Flexibilidad y Reutilización del Código
El polimorfismo fomenta la reutilización de código mediante la herencia y el uso de métodos comunes:
- Las clases base pueden definir métodos que luego serán reutilizados o sobrescritos en las clases derivadas.
- El upcasting permite aprovechar la interfaz común de la clase base para manipular objetos de cualquier subclase, garantizando que el programa sea adaptable y flexible.

#### 4. Reducción de Errores y Mantenimiento Más Sencillo
El polimorfismo facilita la actualización y el mantenimiento del programa:
- Los cambios en métodos de la clase base se reflejan automáticamente en todas las clases derivadas, lo que ayuda a mantener la coherencia y facilita las modificaciones.
- Las pruebas y el depurado de código también se simplifican, ya que el comportamiento de los métodos puede ser evaluado desde el nivel base, asegurando que todas las subclases mantengan una interfaz consistente.

#### Consideración de Downcasting
Si bien el **downcasting** también forma parte del polimorfismo, es importante considerar que este puede requerir cambios en el código cuando se introducen nuevas clases. Sin embargo:
- Estos cambios suelen ser **extensiones** de métodos ya existentes, ya que se añaden nuevas clases derivadas, ampliando las funcionalidades del programa.

En resumen, el polimorfismo es fundamental para escribir código flexible, escalable y extensible, simplificando el desarrollo y mejorando la adaptabilidad a cambios y expansiones en el software.