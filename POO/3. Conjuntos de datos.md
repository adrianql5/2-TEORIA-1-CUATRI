[[archivos/bibliografia/3. Conjuntos de datos - Arrays, colecciones, listas, conjuntos y mapas.pdf|3. Conjuntos de datos - Arrays, colecciones, listas, conjuntos y mapas]]

Escrito por **Adrián Quiroga Linares**.

# Conjuntos de datos
Una buena parte de la programación consiste en manejar conjuntos de datos sobre los que se realizan operaciones CRUD de búsqueda, inserción, modificación y borrado. Típicamente la mayoría de los lenguajes de programación soportan la representación de conjuntos de datos a través del concepto de array. 

Los arrays tienen muchas limitaciones a la hora de acceder a los datos, tanto en la lectura como en la escritura. Se han propuesto una buena cantidad de formas de representar conjunto de datos que intentan dar respuesta a esas limitaciones. Java soporta directamente varios tipos de conjuntos de datos.

| Tipo         | Descripción                               |
|--------------|-------------------------------------------|
| Arrays       | Elementos accesibles a través de un índice |
| Colección    | Grupo de objetos                          |
| Iterador     | Objeto que itera sobre una colección      |
| Lista        | Colección ordenada de objetos             |
| Conjunto     | Colección sin objetos duplicados          |
| Mapa         | Objeto que relaciona claves con valores   |

# Arrays
En Java, los **arrays** son una estructura fundamental que comparte algunas características con los arrays en otros lenguajes de programación procedimentales.

## 1. Estructura y Acceso mediante Índices
Un array es una colección de elementos del mismo tipo, que ocupan posiciones de memoria consecutivas. Esto permite acceder rápidamente a cualquier elemento utilizando su **índice**. El primer elemento está en el índice `0`, el segundo en `1`, y así sucesivamente hasta `length - 1` (donde `length` es la longitud del array).

#### Ejemplo de declaración e inicialización de un array
```java
int[] numeros = {1, 2, 3, 4, 5};  // Declaración e inicialización de un array de enteros
System.out.println(numeros[0]);   // Imprime el primer elemento: 1
System.out.println(numeros[4]);   // Imprime el último elemento: 5
```

## 2. Los Arrays en Java son Objetos
En Java, un array es en realidad un **objeto**. Esto significa que al crear un array, se debe reservar memoria explícitamente usando `new`, a menos que se inicialice directamente con valores como en el ejemplo anterior. Además, hereda métodos de la clase `Object` y tiene un atributo público `length` que almacena su longitud.

### Ejemplo de creación de un array usando `new`
```java
int[] edades = new int[5];   // Crea un array de enteros con 5 elementos, inicializados en 0
edades[0] = 10;              // Asigna valores a los elementos
edades[1] = 15;
System.out.println(edades.length);  // Imprime la longitud del array: 5
```

## 3. Acceso Seguro: `ArrayIndexOutOfBoundsException`
Si intentamos acceder a una posición fuera del rango de índices del array (menor que `0` o mayor o igual a `length`), Java generará una excepción `ArrayIndexOutOfBoundsException`. Esto protege al programa de errores comunes al trabajar con índices fuera de rango.

### Ejemplo de excepción por índice fuera de rango
```java
int[] valores = {1, 2, 3};
System.out.println(valores[3]);  // Genera ArrayIndexOutOfBoundsException, ya que el índice 3 no existe
```

## 4. Arrays de Tipos de Datos Primitivos y Objetos
Java permite almacenar **tipos de datos primitivos** (como `int`, `double`, `char`, etc.) en arrays, lo cual es una ventaja en términos de eficiencia. También se pueden almacenar objetos en arrays, lo que permite mayor flexibilidad.

### Ejemplo de arrays de tipos primitivos y de objetos
```java
// Array de tipos primitivos
char[] letras = {'A', 'B', 'C'};

// Array de objetos (en este caso, de tipo String)
String[] nombres = new String[3];
nombres[0] = "Alice";
nombres[1] = "Bob";
nombres[2] = "Charlie";
```

## 5. Limitaciones de los Arrays
Los arrays en Java tienen varias limitaciones importantes:

- **Tamaño Fijo**: Una vez que se crea un array, su tamaño no se puede cambiar. Si necesitamos una estructura de tamaño dinámico, es mejor usar otras colecciones de Java, como `ArrayList`.
- **No se pueden eliminar elementos**: No existe una operación directa para borrar un elemento del array; simplemente se puede establecer el valor en `null` (para tipos de objetos) o en el valor predeterminado (para tipos primitivos).
- **Acceso y Modificación Limitados**: A diferencia de algunas colecciones, los arrays no tienen métodos para operaciones complejas, como agregar o eliminar elementos; solo permiten acceso y modificación directa por índice.

### Ejemplo que muestra las limitaciones
```java
int[] numeros = {1, 2, 3};
// Queremos agregar un elemento, pero no podemos cambiar el tamaño del array directamente.
// Una solución es crear un nuevo array con el tamaño deseado y copiar los elementos:
int[] nuevoArray = new int[4];
System.arraycopy(numeros, 0, nuevoArray, 0, numeros.length);
nuevoArray[3] = 4;   // Ahora el nuevo array tiene el elemento adicional

System.out.println(Arrays.toString(nuevoArray));  // Imprime [1, 2, 3, 4]
```

En este ejemplo, hemos tenido que crear un nuevo array de mayor tamaño para simular la adición de un elemento, debido a la limitación de tamaño fijo de los arrays.

## Conclusión
Los arrays en Java son una estructura eficiente y útil para almacenar conjuntos de datos de tamaño fijo, especialmente cuando se trabaja con tipos primitivos. Sin embargo, debido a sus limitaciones, para situaciones donde se necesita un tamaño dinámico y operaciones más complejas, Java proporciona clases adicionales en la biblioteca de colecciones, como `ArrayList`, `LinkedList`, `HashSet`, y `HashMap`, que son más flexibles y potentes.

# Colecciones, listas, iteradores y mapas
Todos los tipos de conjuntos de datos son mapas (Map), colecciones (Collection) o iteradores (Iterator). Los otros tipos de conjuntos de datos tienen características que particularizan el tipo que hereda. Los ArrayList y los HashMap son tipos de listas y de mapas, respectivamente, que se usan con mucha frecuencia en los programas de Java.

En Java, las colecciones, listas, iteradores y mapas son estructuras fundamentales para almacenar y manipular conjuntos de datos. Aquí te explico en más detalle estos conceptos con ejemplos.

## 1. Colecciones (Collection)
Una **colección** en Java es una estructura que agrupa un conjunto de elementos (objetos) y proporciona métodos para realizar operaciones comunes como agregar, eliminar y verificar si un elemento está en la colección. La interfaz `Collection` define los métodos básicos que cualquier tipo de colección debe tener, pero al ser una interfaz, no se puede instanciar directamente. Existen varias clases que implementan esta interfaz, como `ArrayList`, `HashSet`, y `LinkedList`.

**Ejemplo de métodos de Collection**:
```java
Collection<String> nombres = new ArrayList<>();
nombres.add("Ana"); // Añadir un elemento
nombres.add("Juan");

System.out.println(nombres.contains("Ana")); // true
System.out.println(nombres.isEmpty()); // false

nombres.remove("Ana"); // Eliminar un elemento
System.out.println(nombres.contains("Ana")); // false
```

En el ejemplo:
- `add` añade un elemento a la colección.
- `contains` verifica si el elemento existe en la colección.
- `isEmpty` comprueba si la colección está vacía.
- `remove` elimina un elemento específico.

No se puede recorrer una colección **usando un índice** porque no es un grupo ordenado de elementos.
Una de las formas más comunes de recorrer una colección es usando un **bucle for-each**:
```java
for (String nombre : nombres) {
    System.out.println(nombre);
}
```

## 2. Iteradores (Iterator)
Un **iterator** o **iterador** es un objeto que permite recorrer los elementos de una **colección** de manera secuencial. La interfaz `Iterator` define tres métodos clave: `hasNext`, `next` y `remove`. 

Los iteradores son útiles cuando queremos **eliminar elementos mientras recorremos la colección**, algo que no es posible hacer con un **bucle for-each debido a que provocaría una** `ConcurrentModificationException`.

**Ejemplo de uso de Iterator**:
```java
Iterator<String> iterador = nombres.iterator();
while (iterador.hasNext()) {
    String nombre = iterador.next();
    System.out.println(nombre);
    if (nombre.equals("Juan")) {
        iterador.remove(); // Elimina el elemento actual
    }
}
```

En este caso:
- `boolean hasNext` comprueba si hay un siguiente elemento.
- `E next` devuelve el siguiente elemento y avanza el iterador.
- `remove` elimina el elemento actual, algo que no se puede hacer con un bucle for-each.

![[archivos/imagenes/Pasted image 20241214170210.png]]

- A diferencia de **for-each**, un **iterador** **permite la eliminación de los elementos mientras se recorre la colección**, eliminado tanto los elementos de la colección como del iterador.
- Un **iterador** solamente se puede usar una **única** vez para recorrer los elementos de la colección, ya que el puntero del iterador habrá llegado al **final de la colección y hasNext devolverá siempre falso**.

![[archivos/imagenes/Pasted image 20241214170557.png]]


## 3. Listas
Las **listas** en Java son colecciones ordenadas, lo que significa que mantienen el orden de inserción de los elementos. Además, permiten acceder a cada elemento usando un índice, algo que distingue a las listas de otras colecciones como los conjuntos (sets), que no mantienen un orden específico. La interfaz `List` en Java extiende `Collection` y define métodos adicionales para trabajar con listas de manera ordenada.

### Características principales de las listas:
1. **Orden de inserción**: Los elementos se almacenan en el orden en que se añaden a la lista. Esto permite que cada elemento tenga un índice asociado, lo cual facilita el acceso y manipulación de los elementos.
2. **Permiten duplicados**: Las listas permiten que un mismo elemento aparezca múltiples veces. Esto puede ser útil cuando se necesita almacenar valores repetidos en un orden específico.
3. **Acceso mediante índice**: La interfaz `List` proporciona métodos como `get`, `set`, y `remove`, que permiten trabajar con los elementos en posiciones específicas de la lista.

### Métodos adicionales en `List`:
Además de los métodos comunes de `Collection`, `List` añade métodos que están pensados para el acceso basado en índices:
- `E get(int i)`: Devuelve el elemento en la posición `i` de la lista.
- `void set(int i, E ele)`: Actualiza el elemento en la posición `i` con el valor `ele`.
- `E remove(int i)`: Elimina el elemento en la posición `i` de la lista.

**Ejemplo básico de List**:
```java
List<String> frutas = new ArrayList<>();
frutas.add("Manzana");
frutas.add("Pera");
frutas.add("Manzana"); // Las listas permiten duplicados

System.out.println(frutas.get(1)); // Pera

frutas.set(1, "Banana"); // Cambia el elemento en la posición 1
System.out.println(frutas.get(1)); // Banana

frutas.remove(0); // Elimina el primer elemento (Manzana)
System.out.println(frutas); // [Banana, Manzana]
```

### ArrayList
`ArrayList` es una implementación común de `List` que usa un array interno para almacenar los elementos. Algunas características clave de `ArrayList` son:

1. **Redimensión dinámica**: Cuando el número de elementos sobrepasa la capacidad del array interno, el tamaño del `ArrayList` se incrementa automáticamente. Inicialmente, `ArrayList` reserva espacio para 10 elementos, y cuando se necesita más capacidad, esta se incrementa por defecto en 10 unidades adicionales.

2. **Capacidad y tamaño**:
   - **Capacidad**: Es el número de elementos que el array interno puede contener sin redimensionarse.
   - **Tamaño**: Es el número actual de elementos que contiene el `ArrayList`. La capacidad puede ser mayor que el tamaño actual.

3. **Elementos nulos (`null`)**: `ArrayList` permite almacenar elementos `null`. Es importante tener en cuenta este detalle al recorrer o manipular la lista, para evitar errores al operar sobre valores nulos. **Comprobar si es null al recorrer la lista.**

4. **Penalización de rendimiento**: Cada vez que el `ArrayList` necesita crecer, copia los elementos en un nuevo array con mayor capacidad. Si esta operación se realiza con frecuencia, puede afectar el rendimiento.

5. **Alias y mutabilidad**: Dado que `ArrayList` almacena referencias a los objetos, cualquier cambio en un objeto dentro de la lista afectará a todos los lugares donde esté referenciado, sin modificar la posición en la lista.

![[archivos/imagenes/Pasted image 20241110170215.png]]

**Ejemplo de uso de ArrayList**:
```java
ArrayList<Integer> numeros = new ArrayList<>(); // Crea un ArrayList con capacidad para 10 elementos
for (int i = 1; i <= 15; i++) {
    numeros.add(i); // Al llegar a 11 elementos, el ArrayList se redimensionará automáticamente
}

System.out.println("Tamaño: " + numeros.size()); // 15
System.out.println("Elemento en la posición 10: " + numeros.get(10)); // 11

numeros.set(5, 100); // Actualiza el elemento en la posición 5
System.out.println(numeros); // Muestra todos los elementos
```

### Resumen
- Las **listas** en Java son colecciones ordenadas que permiten duplicados y se pueden recorrer por índices.
- La interfaz **`List`** incluye métodos como `get`, `set` y `remove` que permiten acceder y modificar elementos en posiciones específicas.
- **`ArrayList`** es una implementación de `List` que redimensiona su capacidad automáticamente y permite almacenar `null`.
- La **redimensión dinámica** de `ArrayList` facilita la gestión de almacenamiento, pero puede impactar el rendimiento si ocurre con mucha frecuencia.

## 4. Conjuntos
En Java, los **conjuntos** (sets) son colecciones que almacenan elementos únicos. Esto significa que no se permiten elementos  duplicados en un conjunto, de acuerdo con el criterio de igualdad definido en el método `equals`. La interfaz `Set` extiende `Collection` y, aunque define las mismas operaciones que `Collection`, tiene reglas adicionales sobre la unicidad de los elementos.

### Características principales de los conjuntos (`Set`):
1. **Elementos únicos**: Un conjunto no permite elementos duplicados. Si intentas agregar un elemento que ya existe en el conjunto (según el criterio de `equals`), el conjunto no lo añadirá.
2. **Permite un único `null`**: Aunque no todas las implementaciones de `Set` permiten elementos `null`, cuando lo permiten, solo se puede agregar un único `null`.
3. **Orden indefinido**: La mayoría de las implementaciones de `Set` no garantizan un orden específico para los elementos, a diferencia de las listas. Sin embargo, existen implementaciones como `LinkedHashSet` y `TreeSet` que mantienen un orden predecible.
4. **Recorrido con for-each o iterador**: Al igual que otras colecciones, un conjunto se puede recorrer con un bucle `for-each` o usando un iterador.

**Ejemplo básico de Set**:
```java
Set<String> nombres = new HashSet<>();
nombres.add("Ana");
nombres.add("Juan");
nombres.add("Ana"); // No se añade ya que "Ana" ya está en el conjunto

System.out.println(nombres); // Muestra: [Ana, Juan] (el orden puede variar)
System.out.println(nombres.contains("Ana")); // true
System.out.println(nombres.contains("Pedro")); // false
```

En este ejemplo:
- `add` añade un elemento al conjunto si no existe.
- `contains` comprueba si un elemento está en el conjunto.

### HashSet
**HashSet** es una implementación común de `Set` en Java. Internamente, `HashSet` usa una instancia de `HashMap` para almacenar los elementos. La estructura de `HashMap` permite que las operaciones de inserción, eliminación y verificación de elementos tengan una **complejidad constante** (O(1)), independientemente del tamaño del conjunto.

Características clave de `HashSet`:
1. **Orden no garantizado**: `HashSet` no mantiene el orden de los elementos como fueron insertados. El orden depende del valor del código hash (`hash code`) de cada elemento.
2. **Almacenamiento de `null`**: `HashSet` permite un único elemento `null`.
3. **Uso de `hashCode` y `equals`**: Para asegurar la unicidad de los elementos, `HashSet` depende de los métodos `hashCode` y `equals`. Es importante sobrescribir estos métodos en los objetos almacenados para evitar problemas de inconsistencia en la comparación de elementos.

**Ejemplo de uso de HashSet**:
```java
Set<Integer> numeros = new HashSet<>();
numeros.add(10);
numeros.add(20);
numeros.add(10); // Este 10 no se añadirá porque ya existe en el conjunto

System.out.println(numeros); // Muestra los elementos en un orden basado en su hash code

numeros.add(null); // Se permite añadir un único elemento null
System.out.println(numeros.contains(null)); // true

// Recorrido del HashSet
for (Integer numero : numeros) {
    System.out.println(numero);
}
```

En este ejemplo:
- `add` intenta añadir un elemento, pero solo se agregan elementos únicos.
- `contains` verifica si un elemento está presente en el conjunto.

### Importancia de `equals` y `hashCode` en `HashSet`
Cuando se usan objetos personalizados en un `HashSet`, es crucial que la clase de esos objetos sobrescriba `equals` y `hashCode` para que el `HashSet` pueda determinar correctamente la unicidad de los objetos. Si `equals` y `hashCode` no están implementados adecuadamente, el `HashSet` puede almacenar elementos duplicados o puede fallar al encontrar elementos.

**Ejemplo de clase con `equals` y `hashCode` sobrescritos**:
```java
class Persona {
    String nombre;
    int edad;

    public Persona(String nombre, int edad) {
        this.nombre = nombre;
        this.edad = edad;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Persona persona = (Persona) obj;
        return edad == persona.edad && nombre.equals(persona.nombre);
    }

    @Override
    public int hashCode() {
        return Objects.hash(nombre, edad);
    }
}

Set<Persona> personas = new HashSet<>();
personas.add(new Persona("Carlos", 30));
personas.add(new Persona("Carlos", 30)); // No se añadirá ya que es duplicado
System.out.println(personas.size()); // 1
```

### Resumen
- **Set** es una colección que almacena elementos únicos, y depende del criterio de `equals` para identificar duplicados.
- **HashSet** usa un `HashMap` internamente, permitiendo operaciones rápidas en tiempo constante.
- **Orden no garantizado**: Los elementos no se almacenan en el orden de inserción en `HashSet`.
- **Métodos `hashCode` y `equals`**: Es necesario sobrescribirlos cuando usamos objetos personalizados en un `HashSet` para asegurar la unicidad.

Estas características hacen que `Set` sea adecuado para colecciones donde la unicidad de los elementos es esencial.

## 5. Mapas
Un **Map** en Java es una estructura de datos que asocia **claves** con **valores**. Esta estructura permite almacenar y recuperar un valor rápidamente a través de su clave asociada, similar a un diccionario en otros lenguajes de programación. En un `Map`:
- Cada clave es única y no puede repetirse.
- Un valor puede estar asociado a varias claves, por lo que los valores sí pueden repetirse.

### Características principales de Map:
1. **Claves únicas y valores asociados**: Un `Map` almacena pares clave-valor (`key-value`), donde cada clave se asocia con un único valor. Si intentas añadir una clave que ya existe, el `Map` sobrescribirá el valor existente asociado a esa clave.
2. **Objetos como claves y valores**: Tanto las claves como los valores deben ser objetos (no tipos primitivos).
3. **Inmutabilidad de claves**: Es recomendable que las claves sean inmutables. Si las claves son mutables, se debe tener cuidado de no modificar los atributos que afectan el método `equals`, ya que esto puede causar problemas de consistencia.
4. **Métodos comunes en Map**:
   - `V get(Object key)`: Devuelve el valor asociado a una clave específica.
   - `V put(K key, V value)`: Asocia un valor a una clave dada, agregando o actualizando el par en el mapa.
   - `boolean containsValue(Object value)`: Verifica si un valor está en el mapa.
   - `boolean containsKey(Object key)`: Verifica si una clave está en el mapa.
   - `V remove(Object key)`: Elimina el par clave-valor basado en la clave.

### Ejemplo básico de Map
```java
Map<String, Integer> edades = new HashMap<>();
edades.put("Ana", 30);
edades.put("Juan", 25);
edades.put("Ana", 35); // Sobreescribe el valor de la clave "Ana" con 35

System.out.println(edades.get("Ana")); // 35
System.out.println(edades.containsKey("Pedro")); // false
System.out.println(edades.containsValue(25)); // true

edades.remove("Juan");
System.out.println(edades); // {Ana=35}
```

### Métodos de conversión a colecciones
`Map` define métodos para convertir las claves y valores en estructuras de datos que se pueden recorrer, lo cual facilita el acceso a cada componente del mapa:
- `Collection<V> values()`: Devuelve una colección con todos los valores del mapa.

- `Set<K> keySet()`: Devuelve un conjunto con todas las claves.

![[archivos/imagenes/Pasted image 20241214223828.png]]
![[archivos/imagenes/Pasted image 20241214223841.png]]

- `Set<Map.Entry<K, V>> entrySet()`: Devuelve un conjunto con todas las entradas `<clave, valor>`. **Una dupla de valores y podemos pillar cualquiera.**
![[archivos/imagenes/Pasted image 20241214224010.png]]
 También se puede usar `Iterator<Map.Entry<String,Contiente>>  entrySet()`


> [!Importante]
> **La clave de un mapa puede ser cualquier tipo de objeto**.
> Para **localizar y obtener la clave** con la que se recupera el valor se hará uso de **equals**.
> 

### HashMap
**HashMap** es una implementación común de `Map` en Java que permite un acceso eficiente a los datos usando un mecanismo basado en **hashes**. Un `HashMap` funciona internamente con una tabla hash, lo que permite que las operaciones como `put` y `get` se realicen en **tiempo constante** (O(1)), independientemente del número de elementos.

1. **Claves y hash code**: `HashMap` usa el código hash de las claves para decidir la posición en la tabla hash. Esto hace que la búsqueda sea más rápida porque no necesita revisar cada elemento, sino solo aquellos con el mismo código hash.
2. **Método `hashCode`**: Para que `HashMap` funcione correctamente, las clases de los objetos que se usen como claves deben sobrescribir el método `hashCode()`. Esto permite comparar rápidamente los objetos en función de su hash code antes de realizar una comparación más profunda con `equals`.
3. **Orden no garantizado**: `HashMap` no asegura el orden de los elementos. El orden de inserción puede variar y está determinado por la función hash de cada clave.

> [!Importante]
>- Primero se comprueba si los objetos tienen el **mismo hash code**, de modo que si no es el mismo, se considerará que los objetos son diferentes 
> 
> - Si el **hash code es igual**, se invoca al método **equals** para aplicar el criterio de igualdad y comprobar que los objetos son iguales
> 
> - Se pueden almacenar claves y valores nulos



![[archivos/imagenes/Pasted image 20241214230809.png]]

> [!OJO]
> Se asume que aunque dos objetos no sean iguales, los hash code pueden ser iguales; pero si dos objetos son diferentes, entonces los hash code deben de ser diferentes.


>


**Ejemplo de uso de HashMap**:
```java
HashMap<String, String> capitales = new HashMap<>();
capitales.put("España", "Madrid");
capitales.put("Francia", "París");
capitales.put("Italia", "Roma");

System.out.println(capitales.get("Francia")); // París
System.out.println(capitales.containsKey("Italia")); // true
System.out.println(capitales.containsValue("Madrid")); // true

// Recorrido de un HashMap
for (Map.Entry<String, String> entrada : capitales.entrySet()) {
    System.out.println("País: " + entrada.getKey() + ", Capital: " + entrada.getValue());
}
```

### Resumen
- Un **Map** asocia claves únicas con valores y permite el acceso a los valores a través de sus claves.
- **HashMap** es una implementación de `Map` que ofrece acceso rápido en tiempo constante y usa una tabla hash para almacenar los datos.
- **Métodos `equals` y `hashCode`** son fundamentales para el buen funcionamiento de un `HashMap`, ya que permiten comparar y ubicar las claves de forma eficiente. 
- `HashMap` **no mantiene el orden de los elementos**, pero ofrece métodos para recorrer todas las claves, valores o pares clave-valor del mapa.

Esta estructura es útil cuando se necesita una correspondencia rápida y directa entre claves y valores, como en tablas de búsqueda, catálogos o registros.

![[archivos/imagenes/Pasted image 20241214225539.png]]

# Comparativa
Las características de los datos que se almacenan orientan la selección del tipo de conjunto de datos que se usarán en el programa.

Las listas ocupan menos memoria que los mapas y los mapas son más rápidos que las listas.

![[archivos/imagenes/Pasted image 20241110171852.png]]

