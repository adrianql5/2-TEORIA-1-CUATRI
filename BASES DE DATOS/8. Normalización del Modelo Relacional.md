[[Archivos/bibliografia/bases_datos.pdf|bases_datos]]

# Introducción
Sí, es posible diseñar una base de datos directamente en el modelo relacional, construyendo las tablas y sus relaciones sin desarrollar previamente un modelo Entidad-Relación (ER). Esto puede ser viable en bases de datos pequeñas, donde las entidades y sus relaciones se pueden identificar y estructurar de forma intuitiva. Las relaciones entre tablas se establecen mediante claves externas que apuntan a claves primarias o candidatas, permitiendo un diseño funcional sin el modelo ER. 

Sin embargo, en bases de datos grandes o con muchos atributos, es recomendable seguir un enfoque más sistemático. El modelo ER permite organizar y visualizar las entidades y sus relaciones antes de pasar al modelo relacional, lo cual facilita el diseño en casos complejos.

La **normalización** es una técnica de diseño de bases de datos relacionales que sigue un enfoque de abajo hacia arriba y se basa en el concepto de dependencia funcional entre atributos. Las dependencias funcionales ayudan a definir la "semántica" de los datos, representando cómo unos atributos dependen de otros. En este sentido, la normalización cumple una función similar al modelo ER, al representar la lógica y relaciones subyacentes de los datos.

El proceso de normalización aplica una serie de condiciones llamadas **Formas Normales**. Alcanzar una forma normal más alta, como la Tercera Forma Normal (3NF) o la Forma Normal de Boyce-Codd (BCNF), suele producir bases de datos mejor estructuradas. Estas formas normales ayudan a eliminar redundancias y a evitar problemas de inconsistencia.

# Buenos Diseños Relacionales
Para diseñar buenas bases de datos relacionales, es crucial considerar aspectos como redundancia, consistencia y la utilidad de los esquemas que se eligen. Aquí se presentan algunas características de los buenos diseños y los problemas que pueden surgir al no aplicarlos correctamente.

###  Evitar Esquemas con Redundancia
**Ejemplo: Esquema de `profesor_dept`**

Imaginemos que queremos combinar la información de las tablas `profesor` y `departamento` en una sola tabla, llamada `profesor_dept`. Este esquema tiene las siguientes columnas:
- `ID` (identificador único del profesor)
- `nombre` (nombre del profesor)
- `sueldo` (sueldo del profesor)
- `nombre_dept` (nombre del departamento)
- `edificio` (edificio del departamento)
- `presupuesto` (presupuesto del departamento)

Aunque esto parece práctico, genera problemas:
- **Redundancia:** Para cada profesor del mismo departamento, la información del departamento (nombre, edificio, presupuesto) se repite. Por ejemplo, en el departamento de Informática, el presupuesto y el edificio se duplican para cada profesor.
- **Inconsistencia:** Si un usuario actualiza el presupuesto del departamento en una fila pero olvida hacerlo en las demás, se produce una inconsistencia en los datos. Por ejemplo, si cambia el presupuesto de Informática en una fila pero no en las demás, las filas ya no coinciden, y la información se vuelve poco confiable.

La alternativa más adecuada sería mantener las tablas `profesor` y `departamento` separadas, y establecer una clave externa en `profesor` que referencie a `departamento`. Esto evita la duplicación de información y facilita las actualizaciones.

### Problemas con los Esquemas que No Permiten Atributos Independientes
Algunos esquemas pueden impedir la representación de datos independientes. En el caso de `profesor_dept`, si se crea un nuevo departamento sin profesores asignados, no se podría registrar en la base de datos. Esto se debe a que el esquema `profesor_dept` requiere un `ID` de profesor, y no se podría introducir el departamento por sí solo.

**Solución:** Separar `profesor` y `departamento` permite almacenar departamentos sin necesidad de que tengan profesores asignados. Así se garantiza la representación de todos los datos relevantes.

### Esquemas Demasiado Divididos: Riesgo de Descomposiciones con Pérdidas

Dividir una tabla en demasiadas partes también puede traer problemas. Una descomposición excesiva puede provocar **pérdidas de información** al intentar reconstruir los datos originales.

**Ejemplo: Esquema `empleado`**

Supongamos que tenemos la tabla `empleado`:
- `ID` (identificador único)
- `nombre` (nombre del empleado)
- `calle`
- `ciudad`
- `sueldo`

Si decidimos dividir `empleado` en dos tablas:
- `empleado1` (contiene `ID` y `nombre`)
- `empleado2` (contiene `nombre`, `calle`, `ciudad`, `sueldo`)

Este diseño introduce problemas. Si dos empleados tienen el mismo nombre, como ocurre a menudo con nombres comunes, será difícil reconstruir la información exacta de cada empleado. Por ejemplo:

| ID   | nombre | calle     | ciudad   | sueldo |
|------|--------|-----------|----------|--------|
| 57766| Kim    | Main      | Perryridge | 75000 |
| 98776| Kim    | North     | Hampton   | 67000 |

Al descomponer y luego intentar recombinar estas tablas, se pueden generar combinaciones incorrectas de datos, como la siguiente:

| ID   | nombre | calle     | ciudad   | sueldo |
|------|--------|-----------|----------|--------|
| 57766| Kim    | Main      | Perryridge | 75000 |
| 98776| Kim    | North     | Hampton   | 67000 |
| 57766| Kim    | North     | Hampton   | 75000 |
| 98776| Kim    | Main      | Perryridge | 67000 |

Los últimos dos registros no existían en la tabla original y son incorrectos, ya que mezclan datos de ambos empleados con el nombre “Kim”. Este tipo de error ocurre cuando la descomposición de una tabla da lugar a una **descomposición con pérdidas**, lo cual afecta la integridad de los datos.

**Solución:** La descomposición correcta debe permitir una reconstrucción exacta de la tabla original. En este caso, mantener `empleado` como una sola tabla o elegir una descomposición diferente puede evitar estos errores.

### Importancia de la Normalización
La normalización es un proceso de diseño que ayuda a organizar los datos en una base de datos para minimizar la redundancia y evitar problemas de consistencia. Este proceso implica la aplicación de varias **Formas Normales** (1NF, 2NF, 3NF, y BCNF) que ayudan a organizar los datos de manera que cada nivel cumple requisitos específicos para asegurar la consistencia.

**Conclusión:** Un buen diseño de base de datos relacional evita la redundancia, asegura la consistencia, y facilita la representación precisa de datos independientemente.


# Primera Forma Normal
El modelo de entidad-relación (E-R) permite que los atributos de las entidades y relaciones tengan subestructuras. Esto significa que un atributo puede estar compuesto por varios subatributos o contener varios valores. Por ejemplo:

- **Atributos compuestos**: Un atributo como `dirección` puede dividirse en `calle`, `ciudad`, `estado`, y `código postal`.
- **Atributos multivalorados**: Un atributo como `número_teléfono` puede contener varios números, en lugar de un solo valor.

Cuando se transforma un diseño E-R en tablas en una base de datos relacional, se debe eliminar esta subestructura para cumplir con las normas de la **primera forma normal (1FN)**. Esto significa:

1. **Para atributos compuestos**: Se separa cada subatributo como un atributo independiente en la tabla.
2. **Para atributos multivalorados**: Se crea una nueva fila en la tabla por cada valor del conjunto multivalorado.

### Definición de dominio atómico
Un **dominio** es atómico si los elementos de ese dominio se consideran indivisibles, es decir, no pueden dividirse en subpartes. Una tabla está en la primera forma normal (1FN) si todos los atributos de la tabla tienen dominios atómicos.

**Ejemplo de dominio no atómico**: Supongamos una tabla `empleado` con un atributo `hijos`, donde cada elemento del dominio de `hijos` es un conjunto de nombres de los hijos de un empleado. Aquí, el dominio no es atómico porque se compone de varios valores (los nombres de los hijos). Para que esté en 1FN, este atributo debería transformarse de modo que cada hijo sea representado en una fila separada o como un atributo independiente.

### Ejemplo práctico: Números de identificación de empleados
En algunas organizaciones, los empleados tienen un número de identificación con un formato específico. Por ejemplo, un número de identificación puede ser `CS001`, donde:
- Las dos primeras letras indican el departamento (`CS` para Ciencias de la Computación).
- Las cuatro cifras indican un número único dentro del departamento.

Este número de identificación no es atómico porque se puede dividir en el código del departamento y un número único. En una base de datos en 1FN, el departamento y el número único deberían almacenarse en atributos separados para evitar dividir el número en partes a nivel de aplicación, lo que llevaría a problemas de consistencia.

### Beneficios de dominios atómicos y la 1FN
1. **Reducción de redundancia**: Al evitar valores compuestos o conjuntos en un mismo atributo, se reduce la duplicación de información y la posibilidad de inconsistencias.
   
2. **Facilidad de actualización**: Si se utilizan identificadores compuestos, como `CS001`, para representar el departamento y número de empleado, cada cambio en el departamento requeriría actualizar el identificador en todas las referencias a ese empleado. Esto es complicado y propenso a errores.

3. **Eficiencia en las consultas**: Las consultas son más fáciles de escribir y ejecutar cuando los datos están en una estructura atómica, sin necesidad de descomponer datos complejos o conjuntos.

### Ejemplo de diseño inconsistente

Si un profesor tiene un conjunto de secciones que enseña y cada sección tiene un conjunto de profesores asignados, pueden ocurrir inconsistencias. Si se cambia la asignación de un profesor a una sección, se deben actualizar ambos conjuntos. Si no se hace, la base de datos puede quedar en un estado inconsistente. En lugar de esto, es mejor almacenar esta información en una relación independiente, lo cual evita redundancia y mejora la integridad de los datos.

### Limitaciones de la 1FN

Exigir que todos los dominios sean atómicos puede ser una carga en ciertos casos, como en aplicaciones con estructuras de datos complejas, donde los atributos compuestos o multivalorados resultan útiles. En estas situaciones, convertir los datos a una forma completamente atómica puede requerir programación adicional y afectar el rendimiento. Por ello, algunos sistemas de bases de datos modernos permiten valores no atómicos, aunque en el contexto de la 1FN, solo se consideran dominios atómicos.

### Resumen
La primera forma normal (1FN) es una de las primeras reglas de normalización en bases de datos relacionales y se basa en el uso de dominios atómicos. Esto significa que los valores de los atributos no deben tener subpartes ni conjuntos de elementos, sino que deben ser indivisibles, lo que facilita el diseño y gestión de bases de datos al reducir redundancias y evitar inconsistencias.

# Descomposición mediante Dependencias Funcionales
Voy a explicarte paso a paso el concepto de **descomposición mediante dependencias funcionales** en bases de datos, incluyendo ejemplos para facilitar la comprensión. El objetivo principal de la descomposición es evitar problemas en el diseño de una base de datos, como la redundancia y las anomalías de actualización. Este proceso se basa en el análisis de claves y **dependencias funcionales**.

### Claves y Dependencias Funcionales
En una base de datos, una **clave** es un conjunto de atributos que identifica unívocamente una tupla (fila) en una relación (tabla). Una **dependencia funcional** es una restricción entre dos conjuntos de atributos en una relación. Formalmente, decimos que en una relación $R$, un conjunto de atributos $\alpha$ determina otro conjunto $\beta$ (escribimos $\alpha \to \beta$ si para cualquier par de tuplas (filas) en  $R$ que tengan el mismo valor en $\alpha$, también tienen el mismo valor en $\beta$.

**Ejemplo 1: Dependencia Funcional**
Supongamos que tenemos una relación llamada `profesor_dept` con los siguientes atributos:
- `ID`: Identificador único del profesor
- `nombre`: Nombre del profesor
- `sueldo`: Sueldo del profesor
- `nombre_dept`: Nombre del departamento donde trabaja el profesor
- `edificio`: Edificio donde está el departamento
- `presupuesto`: Presupuesto del departamento

Si sabemos que el `nombre_dept` determina el `presupuesto` (es decir, cada departamento tiene un único presupuesto), entonces podemos decir que:
$$
\text{nombre\_dept} \to \text{presupuesto}
$$
Esto significa que para cualquier dos tuplas con el mismo `nombre_dept`, el valor de `presupuesto` también debe ser el mismo.

**Ejemplo 2: Superclave y Dependencia Funcional**
Consideremos que `ID` es único para cada profesor. Por lo tanto, el `ID` puede identificar de forma única toda la información de un profesor:
$$
\text{ID} \to \{\text{nombre, sueldo, nombre\_dept, edificio, presupuesto}\}
$$
Este conjunto `{ID}` es una **superclave** porque puede identificar unívocamente cada tupla en la relación.

### ¿Por Qué Descomponer una Relación?
Cuando un esquema de relación (una tabla) no está bien diseñado, puede contener redundancias y generar problemas, como:
- **Anomalías de inserción**: Dificultades para agregar datos nuevos sin incluir información redundante.
- **Anomalías de eliminación**: Al eliminar una tupla, podemos perder información importante de otra tupla.
- **Anomalías de actualización**: Necesidad de actualizar múltiples tuplas para mantener la coherencia de los datos.

**Ejemplo de Anomalía**
Imaginemos que en `profesor_dept`, cada vez que queremos insertar un profesor nuevo que trabaja en el departamento de Matemáticas, tenemos que añadir el valor del presupuesto de Matemáticas, aunque ya lo hayamos introducido antes. Esto genera redundancia.

Para solucionar estos problemas, usamos las **formas normales**, que son criterios para organizar los atributos en una relación. En particular, la **Forma Normal de Boyce-Codd (FNBC)** es una forma normal avanzada que elimina ciertas redundancias.

###  Descomposición Usando Dependencias Funcionales
La descomposición consiste en dividir una relación en dos o más relaciones más pequeñas, de modo que se eliminen las redundancias y se mantenga la información original.

**Ejemplo de Descomposición**
Supongamos que en `profesor_dept` tenemos las siguientes dependencias funcionales:
1. `ID` → `{nombre, sueldo, nombre_dept, edificio, presupuesto}`
2. `nombre_dept` → `{presupuesto, edificio}`

En este caso, `nombre_dept` → `presupuesto` y `nombre_dept` → `edificio` nos indican que el presupuesto y el edificio dependen únicamente del departamento y no del profesor en sí. Podemos descomponer la relación `profesor_dept` en dos relaciones:

1. `profesor_info(ID, nombre, sueldo, nombre_dept)`
2. `departamento(nombre_dept, edificio, presupuesto)`

Ahora, en `profesor_info`, cada tupla representa la información de un profesor junto con su departamento, y en `departamento`, cada tupla representa información única de cada departamento. Esto elimina la redundancia de tener que almacenar `edificio` y `presupuesto` repetidamente en `profesor_dept`.

### Condiciones para una Buena Descomposición
La descomposición debe cumplir las siguientes condiciones para ser útil:
- **Preservación de dependencias funcionales**: Las dependencias funcionales originales deben mantenerse en las relaciones resultantes.
- **Sin pérdida de información**: Debemos poder reconstruir la relación original a partir de las relaciones descompuestas.

Siguiendo con el ejemplo anterior, la descomposición cumple estas condiciones porque:
- Podemos combinar `profesor_info` y `departamento` para obtener la relación original.
- Las dependencias funcionales importantes (`ID → {nombre, sueldo, nombre_dept}` y `nombre_dept → {edificio, presupuesto}`) se preservan.

### Dependencias Funcionales Triviales y No Triviales

Una **dependencia funcional trivial** es aquella en la que los atributos en el lado derecho ya están incluidos en el lado izquierdo. Por ejemplo, $\text{ID} \to \text{ID}$ es trivial porque $\text{ID}$ siempre determina a sí mismo.

**Ejemplo: Dependencia Trivial y No Trivial**
- Trivial: `ID, nombre → ID` (porque `ID` está en el lado izquierdo).
- No trivial: `ID → nombre` (aquí, `nombre` no está en el lado izquierdo, por lo que esta dependencia es informativa).

### Resumen
1. **Dependencias funcionales**: Expresan restricciones de cómo un conjunto de atributos determina a otro.
2. **Superclaves**: Atributos que identifican unívocamente cada tupla en una relación.
3. **Descomposición**: Divide una relación en relaciones más pequeñas para evitar redundancia y preservar la integridad de los datos.
4. **Condiciones de descomposición**: Debe preservar las dependencias funcionales y evitar la pérdida de información.

### Definiciones
Aquí tienes las definiciones importantes que ayudan a entender mejor el concepto de normalización en bases de datos y los diferentes tipos de dependencias funcionales:

- **Dependencia Funcional**: Describe la relación existente entre atributos de una relación. Si $A$ y $B$ son conjuntos de atributos de la relación $R$, $B$ será funcionalmente dependiente de $A$ (escrito como $A \rightarrow B$ si cada valor de $A$ está asociado con exactamente un valor de $B$. En otras palabras, los valores de $A$ determinan los valores de $B$.

- **Determinante**: Es el grupo de atributos en el lado izquierdo de una dependencia funcional. Por ejemplo, si tenemos una dependencia funcional $A \rightarrow B$, entonces $A$ se denomina determinante de la relación.

- **Dependencia Funcional Completa**: Ocurre cuando un conjunto de atributos $B$ depende funcionalmente de $A$ (es decir, $A \rightarrow B$, pero no de ningún subconjunto de $A$. Esto significa que todos los atributos de $A$ son necesarios para determinar $B$. Esta propiedad es clave para lograr la **segunda forma normal** en la normalización de bases de datos.

- **Dependencia Parcial**: Es una dependencia funcional en la que existe algún atributo que puede eliminarse del determinante, y la dependencia aún se verifica. Es decir, hay una relación entre un subconjunto de los atributos del determinante y el atributo dependiente. Esta dependencia parcial debe eliminarse para cumplir con la **segunda forma normal**.

- **Dependencia Transitiva**: Se produce si existen tres conjuntos de atributos $A$, $B$, y $C$ en la relación $R$, tales que $C$ depende funcionalmente de $B$ y $B$ depende funcionalmente de $A$. En este caso, $C$ depende transitivamente de $A$ a través de $B$. Para alcanzar la **tercera forma normal**, deben eliminarse estas dependencias transitivas.

![[Archivos/imagenes/Pasted image 20241106123439.png]]


# Teoría de las Dependencias Funcionales
La teoría de las dependencias funcionales es crucial para entender la normalización de bases de datos, y en particular, para determinar si un esquema cumple con la **Primera Forma Normal de Boyce-Codd (FNBC)** o la **Tercera Forma Normal (3FN)**. En este contexto, se habla de cómo razonar sobre las dependencias funcionales y cómo podemos determinar nuevas dependencias que se deriven lógicamente de un conjunto dado.

### ¿Qué es una dependencia funcional?
Una **dependencia funcional** entre dos conjuntos de atributos \( X \) y \( Y \) en una relación \( R \) se denota como:

$$
X \rightarrow Y
$$

Esto significa que si dos tuplas (filas) tienen los mismos valores para el conjunto de atributos $X$, entonces también deben tener los mismos valores para el conjunto $Y$. Es decir, el valor de $X$ determina el valor de $Y$.

## Cierre de un conjunto de dependencias funcionales
Cuando hablamos del **cierre de un conjunto de dependencias funcionales** $F$, denotado como $F^+$, nos referimos al conjunto de todas las dependencias funcionales que se pueden derivar lógicamente a partir de las dependencias en $F$. El cierre es importante porque, cuando estamos comprobando si un esquema está en una forma normal (como la FNBC o la 3FN), no basta con mirar únicamente las dependencias que se nos dan. Debemos considerar todas las dependencias funcionales que pueden deducirse de ellas.

**Ejemplo:**
Supongamos que tenemos el siguiente conjunto de dependencias funcionales para un esquema de relación $R(A, B, C, G, H, I)$:

$$
F = \{ A \rightarrow B, A \rightarrow C, CG \rightarrow H, CG \rightarrow I, B \rightarrow H \}
$$

Queremos determinar si $A \rightarrow H$ se puede deducir a partir de $F$.

1. Sabemos que $A \rightarrow B$, lo que implica que si dos tuplas tienen el mismo valor para $A$, entonces también deben tener el mismo valor para $B$.
2. También sabemos que $B \rightarrow H$, lo que implica que si dos tuplas tienen el mismo valor para $B$, entonces deben tener el mismo valor para $H$.
3. Si $t_1[A] = t_2[A]$, entonces $t_1[B] = t_2[B]$ por $A \rightarrow B$.
4. Luego, $t_1[B] = t_2[B]$ implica que $t_1[H] = t_2[H]$ por $B \rightarrow H$.

Por lo tanto, hemos demostrado que $A \rightarrow H$ se cumple, lo que significa que **$A \rightarrow H$ está implicado lógicamente por $F$**.

### Cálculo del cierre $F^+$
El **cierre** de $F$, denotado como $F^+$, es el conjunto de todas las dependencias funcionales que pueden derivarse de $F$ usando un conjunto de reglas de inferencia. Esto es útil porque, para verificar la normalización de una base de datos, necesitamos conocer todas las dependencias que se cumplen en el esquema.

### Axiomas de Armstrong
Los **axiomas de Armstrong** son un conjunto de reglas de inferencia que nos permiten derivar nuevas dependencias funcionales de manera sistemática y lógica. Estas reglas son las siguientes:

1. **Reflexividad**: Si $\alpha \subseteq \beta$, entonces $\beta \rightarrow \alpha$.
   
   Esto significa que si un conjunto de atributos $\beta$ es un subconjunto de otro conjunto $\alpha$, entonces $\alpha \rightarrow \beta$ es una dependencia funcional válida. Ejemplo: Si $A$ es subconjunto de $AB$, entonces $AB \rightarrow A$.
   
2. **Aumentatividad**: Si $\alpha \rightarrow \beta$ y $\gamma$ es un conjunto de atributos, entonces $\gamma \alpha \rightarrow \gamma \beta$.

   Esto nos dice que si $\alpha$ determina $\beta$, entonces cualquier conjunto de atributos $\gamma$ que se añada a ambos lados de la dependencia también será válido. Ejemplo: Si $A \rightarrow B$, entonces $AC \rightarrow BC$ es válido.

3. **Transitividad**: Si $\alpha \rightarrow \beta$ y $\beta \rightarrow \gamma$, entonces $\alpha \rightarrow \gamma$.

   Esto implica que si un conjunto $\alpha$ determina $\beta$, y $\beta$ determina $\gamma$, entonces $\alpha$ también determina $\gamma$. Ejemplo: Si $A \rightarrow B$ y $B \rightarrow C$, entonces $A \rightarrow C$.

### Otras reglas útiles
Además de los axiomas de Armstrong, existen reglas adicionales que se usan para derivar dependencias funcionales más fácilmente:

- **Unión**: Si $\alpha \rightarrow \beta$ y $\alpha \rightarrow \gamma$, entonces $\alpha \rightarrow \beta \gamma$.
- **Descomposición**: Si $\alpha \rightarrow \beta \gamma$, entonces $\alpha \rightarrow \beta$ y $\alpha \rightarrow \gamma$.
- **Pseudotransitividad**: Si $\alpha \rightarrow \beta$ y $\gamma \beta \rightarrow \delta$, entonces $\alpha \gamma \rightarrow \delta$.

### Ejemplo con el conjunto $F$
Tomemos el conjunto $F = \{ A \rightarrow B, A \rightarrow C, CG \rightarrow H, CG \rightarrow I, B \rightarrow H \}$ y calculemos $F^+$:

1. **A → H**: Sabemos que $A \rightarrow B$ y $B \rightarrow H$, por lo que, aplicando la transitividad, obtenemos $A \rightarrow H$.
   
2. **CG → HI**: Sabemos que $CG \rightarrow H$ y $CG \rightarrow I$, por lo que, aplicando la unión, obtenemos $CG \rightarrow HI$.

3. **AG → I**: Sabemos que $A \rightarrow C$ y $CG \rightarrow I$, por lo que, aplicando la pseudotransitividad, obtenemos $AG \rightarrow I$.

### Procedimiento para calcular $F^+$
El procedimiento para calcular $F^+$ implica aplicar repetidamente las reglas de Armstrong y las reglas adicionales hasta que no se puedan derivar más dependencias. Dado que un conjunto de atributos tiene $2^n$ subconjuntos, el número total de dependencias funcionales posibles es $2^{2n}$, donde $n$ es el número de atributos en el esquema.

### Conclusión
El concepto de dependencias funcionales y su cierre es fundamental para la normalización de bases de datos. Usando las reglas de inferencia, como los axiomas de Armstrong, podemos derivar todas las dependencias funcionales que se cumplen en un esquema y asegurar que este cumpla con las formas normales requeridas.

## Cierre del conjunto de atributos
Es una herramienta clave para razonar sobre las dependencias funcionales y la identificación de superclaves. Vamos a desglosar cada parte de esta teoría de manera detallada con ejemplos para facilitar la comprensión.

### Definición de Cierre de un Conjunto de Atributos

Cuando decimos que un **atributo B está determinado funcionalmente por un conjunto de atributos α**, estamos afirmando que, dado que se cumple la dependencia funcional α → B, el valor de B se puede deducir a partir de los atributos en α. En otras palabras, si conocemos los valores de los atributos en α, podemos predecir con certeza el valor de B.

El **cierre de un conjunto de atributos α** bajo un conjunto de dependencias funcionales F, denotado como **α+**, es el conjunto de todos los atributos que pueden ser determinados funcionalmente a partir de α usando las dependencias de F. Es decir, si calculamos α+, obtendremos todos los atributos que se pueden derivar de α a través de las dependencias funcionales presentes en F.

### Algoritmo para Calcular el Cierre de Atributos

El algoritmo para calcular el cierre de un conjunto de atributos α bajo F (es decir, α+) es bastante directo, y está basado en las dependencias funcionales disponibles. El procedimiento sigue los siguientes pasos:

1. **Inicialización**: Comienza con el conjunto de atributos α, ya que estos son los atributos que estamos considerando. Es decir, empezamos con el cierre de α como α mismo: `resultado = α`.

2. **Aplicación de las dependencias funcionales**: Iteramos sobre las dependencias funcionales en F, y por cada dependencia de la forma **β → γ**, si β está contenido en el conjunto `resultado` (es decir, los atributos de β ya están en el conjunto de atributos que hemos determinado), agregamos todos los atributos de γ al conjunto `resultado`.

3. **Repetir hasta que no cambie el conjunto**: El proceso continúa hasta que en una iteración no se agreguen más atributos al conjunto `resultado`. Es decir, cuando ya no se pueden deducir nuevos atributos a partir de las dependencias funcionales.

### Ejemplo

Supongamos que tenemos el conjunto de dependencias funcionales F:

- A → B
- A → C
- CG → H
- CG → I
- B → H

Y queremos calcular el cierre de **AG** (es decir, (AG)+), con el conjunto de atributos **α = AG**. Vamos a aplicar el algoritmo paso a paso:

#### Paso 1: Inicialización

Comenzamos con `resultado = AG` (es decir, {A, G}).

#### Paso 2: Aplicación de las dependencias funcionales

1. **A → B**: Como A está en `resultado` (AG), podemos añadir B. Ahora, `resultado = {A, G, B}`.
2. **A → C**: Como A está en `resultado`, podemos añadir C. Ahora, `resultado = {A, G, B, C}`.
3. **CG → H**: Como C y G están en `resultado`, podemos añadir H. Ahora, `resultado = {A, G, B, C, H}`.
4. **CG → I**: Como C y G están en `resultado`, podemos añadir I. Ahora, `resultado = {A, G, B, C, H, I}`.
5. **B → H**: Ya tenemos H en `resultado`, por lo que no hay cambios.

#### Paso 3: Repetir hasta que no cambie más

En la siguiente iteración, no se agregan más atributos a `resultado`, por lo que el algoritmo termina. El cierre de **AG** bajo **F** es **{A, G, B, C, H, I}**, es decir, **(AG)+ = {A, G, B, C, H, I}**.

### Correctitud del Algoritmo

Este algoritmo es correcto porque, en cada iteración, asegura que los atributos determinados funcionalmente por α se añaden a `resultado`. Gracias a las reglas de transitividad y reflexividad, si podemos determinar que **α → β** y luego **β → γ**, podemos concluir que **α → γ**. Además, si **β → γ** y **β ⊆ resultado**, entonces α → γ por transitividad.

De esta manera, garantizamos que cuando el algoritmo termina, **resultado** contiene todos los atributos de α+, es decir, el cierre de α bajo F.

### Aplicaciones del Cierre de Atributos

El cálculo del cierre de atributos tiene varias aplicaciones importantes:

1. **Comprobar si un conjunto de atributos es una superclave**: Un conjunto α es una **superclave** si su cierre **α+** contiene todos los atributos de la relación R. Por ejemplo, si tenemos una relación R = {A, B, C, D}, y queremos comprobar si **AG** es una superclave, calculamos **(AG)+** y verificamos si contiene todos los atributos de R. Si es así, **AG** es una superclave.

2. **Comprobar si una dependencia funcional es válida**: Para verificar si una dependencia funcional **α → β** pertenece al conjunto **F+**, podemos calcular **α+** y verificar si contiene todos los atributos de β. Si β está contenido en **α+**, entonces la dependencia **α → β** se cumple.

3. **Calcular todas las dependencias funcionales implicadas**: Para calcular todo el conjunto de dependencias funcionales **F+**, podemos calcular el cierre de cada conjunto de atributos γ ⊆ R, y para cada subconjunto S de γ+, generar la dependencia funcional **γ → S**.

![[Archivos/imagenes/Pasted image 20241106162630.png]]
### Conclusión
El **cierre de atributos** es una herramienta fundamental en el análisis de bases de datos relacionales. Nos permite razonar sobre las dependencias funcionales y determinar cosas como superclaves y la validez de dependencias funcionales. El algoritmo mostrado proporciona un método eficiente y formal para calcular el cierre de un conjunto de atributos bajo un conjunto dado de dependencias funcionales, y es un paso clave en la normalización de bases de datos.

## Recubrimiento Canónico
El recubrimiento canónico de un conjunto de dependencias funcionales es una versión simplificada de ese conjunto, que tiene las mismas implicaciones lógicas pero es más eficiente para comprobar si una base de datos cumple con todas las dependencias. El objetivo es reducir el número de dependencias y atributos a verificar, asegurando que las comprobaciones sean más rápidas.

### Conceptos Clave
1. **Atributos raros**: Un atributo en una dependencia funcional es raro si se puede eliminar sin cambiar el cierre del conjunto de dependencias. Esto implica que su presencia no afecta a las implicaciones lógicas de la dependencia.
   
2. **Recubrimiento Canónico (Fc)**: Un conjunto de dependencias que tiene las siguientes propiedades:
   - No contiene dependencias con atributos raros.
   - El lado izquierdo de cada dependencia es único, es decir, no hay dependencias con el mismo conjunto de atributos en el lado izquierdo.

### Procedimiento para Encontrar el Recubrimiento Canónico
1. **Unión de dependencias**: Si existen dependencias con el mismo conjunto de atributos en el lado izquierdo, se combinan en una sola dependencia. Por ejemplo, si tienes `A → BC` y `A → B`, se combinan en `A → BC`.
   
2. **Eliminar atributos raros**: Si algún atributo en una dependencia es raro, se elimina de la dependencia. Para comprobar si un atributo es raro, se deben calcular los cierres de los atributos involucrados usando las dependencias actuales.

3. **Repetir hasta que no haya cambios**: El proceso de unión y eliminación de atributos raros se repite hasta que no haya más dependencias que puedan ser combinadas o simplificadas.

### Ejemplo Práctico
Dado el conjunto de dependencias funcionales:
```
A → BC
B → C
A → B
AB → C
```

1. **Unión de dependencias**: Se combinan `A → BC` y `A → B` en `A → BC`.
   
   Entonces, el conjunto de dependencias es:

   ```
   A → BC
   B → C
   AB → C
   ```

2. **Eliminar atributos raros**:
   - En `AB → C`, `B` es raro en el lado izquierdo, porque se puede inferir `A → C` de las dependencias restantes.
   - En `A → BC`, `C` es raro en el lado derecho porque `A → B` y `B → C` implican `A → C`.

   El conjunto de dependencias después de eliminar los atributos raros es:

   ```
   A → B
   B → C
   ```

   Este es el recubrimiento canónico de las dependencias originales.

### Recubrimiento Canónico no Único

Es importante notar que el recubrimiento canónico puede no ser único. El algoritmo para hallar el recubrimiento canónico selecciona una de las dependencias para eliminar atributos raros, lo que puede dar lugar a diferentes soluciones válidas.

Por ejemplo, dado el conjunto:

```
A → BC
B → AC
C → AB
```

El recubrimiento canónico podría ser:

```
A → B, B → C, C → A
```

O también podría ser:

```
A → C, B → A, C → B
```

Ambos conjuntos tienen el mismo cierre y son válidos, pero tienen diferentes formas.

### Resumen

El recubrimiento canónico es una versión simplificada de un conjunto de dependencias funcionales, que reduce el esfuerzo para comprobar si se cumplen las dependencias en un sistema de bases de datos. Para calcularlo, se utilizan reglas como la unión de dependencias y la eliminación de atributos raros, repitiendo el proceso hasta que no se pueda hacer más simplificación.

## Descomposición sin pérdidas
La descomposición sin pérdidas es un concepto fundamental en el diseño de bases de datos. Se refiere a la propiedad de una descomposición de una relación en varias subrelaciones, donde al realizar una operación de unión natural sobre las subrelaciones, se puede recuperar la relación original sin pérdida de información. Esto es clave para asegurar que las descomposiciones no fragmenten la base de datos de manera que se pierdan datos importantes.

### Definición Formal
Supongamos que tenemos una relación $R$ con el esquema $R = (A_1, A_2, \dots, A_n)$ y un conjunto de dependencias funcionales $F$. Si descomponemos $R$ en dos subesquemas $R_1$ y $R_2$, entonces la descomposición es sin pérdidas si, para cualquier conjunto de tuplas que satisfagan las dependencias funcionales, la siguiente consulta SQL:

```sql
SELECT * FROM (SELECT R1 FROM r) NATURAL JOIN (SELECT R2 FROM r)
```

devuelve el conjunto de tuplas original de $r$. Esto se puede expresar más concisamente en álgebra relacional como:

$$
\pi_{R_1}(r) \bowtie \pi_{R_2}(r) = r
$$

Donde $\pi_{R_1}(r)$ y $\pi_{R_2}(r)$ son las proyecciones de la relación $r$ sobre los esquemas $R_1$ y $R_2$, respectivamente, y $\bowtie$ es la operación de unión natural.

### Descomposición sin Pérdidas y Dependencias Funcionales
Para que una descomposición sea sin pérdidas, se debe cumplir al menos una de las siguientes condiciones de dependencias funcionales en el conjunto $F^+$ (cierre de $F$):

- $R_1 \cap R_2 \to R_1$
- $R_1 \cap R_2 \to R_2$

En otras palabras, la intersección de los atributos de $R_1$ y $R_2$ debe formar una superclave de al menos uno de los subesquemas $R_1$ o $R_2$.

### Ejemplo
Consideremos el esquema de relación `profesor_dept`:

$$
profesor\_dept(ID, nombre, sueldo, nombre\_dept, edificio, presupuesto)
$$

Y su descomposición en los esquemas `profesor` y `departamento`:

$$
profesor(ID, nombre, nombre\_dept, sueldo)
$$
$$
departamento(nombre\_dept, edificio, presupuesto)
$$

La intersección de estos dos subesquemas es el atributo `nombre_dept`. Si $nombre\_dept \to nombre\_dept, edificio, presupuesto$, se puede concluir que esta descomposición es sin pérdidas, ya que la intersección de los subesquemas forma una superclave de $departamento$.

### Descomposición Simultánea
En el caso de la descomposición simultánea de un esquema en varios subesquemas, la comprobación de descomposición sin pérdidas se complica. Sin embargo, para una descomposición binaria (dos subesquemas), la condición que mencionamos anteriormente es suficiente para asegurar la descomposición sin pérdidas. Si se tienen más de dos subesquemas, las condiciones necesarias para asegurar que la descomposición sea sin pérdidas requieren un análisis más profundo, tomando en cuenta otras restricciones más complejas como las dependencias multivaloradas.
![[Archivos/imagenes/Pasted image 20241106163625.png]]
### Conclusión
La descomposición sin pérdidas es crucial para mantener la integridad de los datos al dividir una relación en varias partes. Las dependencias funcionales juegan un papel fundamental en la comprobación de esta propiedad, garantizando que al reconstruir la relación original a partir de las subrelaciones, no se pierda información clave.

## Conservacion de las dependencias
La conservación de las dependencias funcionales en una descomposición de relaciones es un concepto importante para asegurar que las dependencias funcionales originales se mantengan después de realizar la descomposición. Para analizar la conservación de las dependencias, se emplea la teoría de las dependencias funcionales y no el enfoque ad hoc de la Sección 8.3.3.

#### Definición de conservación de dependencias
Sea $F$ un conjunto de dependencias funcionales de un esquema $R$ y $R_1, R_2, ..., R_n$ una descomposición de $R$. La **restricción de $F$ a $R_i$** es el conjunto $F_i$ de todas las dependencias funcionales de $F^+$ (el cierre de $F$) que solo incluyen atributos de $R_i$.

El conjunto de restricciones $F_1, F_2, ..., F_n$ puede comprobarse de manera eficiente ya que cada restricción involucra solo atributos de un único esquema de relación. Importante: **la restricción de $F$ a $R_i$** se construye utilizando **$F^+$** y no solo $F$. 

Por ejemplo, si $F = \{ A \rightarrow B, B \rightarrow C \}$ y la descomposición es en  $AC$ y $AB$, la restricción de $F$ a $AC$ sería $A \rightarrow C$, aunque $A \rightarrow C$ no esté en $F$, pero sí en $F^+$.

#### Propiedad de conservación
Para comprobar si una descomposición conserva las dependencias, se verifica si la **unión** de las restricciones $F_1 \cup F_2 \cup ... \cup F_n$ tiene el mismo cierre $(F')^+ = F^+$. Si esto se cumple, entonces todas las dependencias funcionales de $F$ se conservan en la descomposición, ya que se verifica que todas las dependencias de $F$ están implicadas lógicamente por $F'$.

#### Algoritmo para comprobar la conservación de dependencias
El algoritmo para comprobar la conservación de dependencias es el siguiente:
1. **Entrada**: conjunto de esquemas $D = \{ R_1, R_2, ..., R_n \}$ y conjunto de dependencias $F$.
2. **Cálculo de $F^+$** (el cierre de $F$).
3. Para cada esquema $R_i$ de la descomposición, calcular su **restricción** de $F^+$ sobre $R_i$, es decir, $F_i$.
4. Crear un conjunto vacío $F'$ y añadir todas las restricciones $F_i$ al conjunto  $F'$).
5. Calcular $(F')^+$.
6. Si $(F')^+ = F^+$, entonces la descomposición conserva las dependencias. Si no, no las conserva.

#### Comprobación alternativa de conservación
Una forma alternativa y más eficiente de comprobar la conservación de dependencias es evitar el cálculo de $F^+$. El algoritmo modificado sigue estos pasos para cada dependencia $\alpha \rightarrow \beta$ en $F$:

1. **Inicialización**: Comienza con $\text{resultado} = \alpha$.
2. Para cada $R_i$ de la descomposición, calcular el **cierre** de $(\text{resultado} \cap R_i)$ bajo  $F$ y actualizar $\text{resultado}$ con la unión de los cierres obtenidos.
3. El proceso continúa hasta que no haya cambios en $\text{resultado}$.
4. Si $\text{resultado}$ contiene todos los atributos de $\beta$, la dependencia $\alpha \rightarrow \beta$ se conserva.

La descomposición conserva las dependencias si y solo si este procedimiento se aplica a todas las dependencias de $F$.

#### Razón detrás de la comprobación
Este enfoque es equivalente al cálculo del cierre bajo $F'$ sin necesidad de calcular $F'$ explícitamente. La razón por la que funciona correctamente se debe a que las dependencias funcionales de $F'$ pueden ser generadas por las dependencias de $F$ y sus restricciones $F_i$.

#### Eficiencia
Este enfoque de comprobación es **polinómico**, lo cual es mucho más eficiente que el cálculo exponencial necesario para calcular $F^+$. Esto permite realizar comprobaciones rápidas y efectivas para verificar la conservación de las dependencias sin necesidad de calcular el cierre completo de $F^+$.

---

En resumen, la conservación de las dependencias es esencial en la descomposición de relaciones, y mediante el uso de restricciones $F_i$ y algoritmos optimizados de cálculo de cierres, se puede verificar de manera eficiente que una descomposición conserve todas las dependencias funcionales originales.

# Algortimo de Berstein
El **algoritmo de Bernstein** es una serie de pasos para normalizar bases de datos, asegurando que una relación cumple condiciones de integridad y evita redundancias. Veamos cada paso con explicaciones y ejemplos.

### Paso 1: Análisis Semántico y Obtención de la Relación Universal
El primer paso es identificar la relación universal $U$, que contiene todos los atributos de interés, y el conjunto $F$ de dependencias funcionales. Este paso define la estructura inicial de la relación a partir de los datos y requisitos del problema.

**Ejemplo**: Supongamos que estamos modelando una base de datos para una empresa con los atributos:
- **EmpleadoID**
- **DepartamentoID**
- **ProyectoID**
- **Salario**

Dependencias funcionales identificadas:
1. $\text{EmpleadoID} \to \text{DepartamentoID, Salario}$
2. $\text{DepartamentoID, ProyectoID} \to \text{Salario}$

La relación universal $U$ sería $\text{EmpleadoID, DepartamentoID, ProyectoID, Salario}$ con el conjunto $F$ de dependencias funcionales.

### Paso 2: Primera Forma Normal (1FN)
Para que una relación esté en 1FN, debe eliminar atributos compuestos o multivalorados. Esto significa que cada celda de la tabla debe contener solo un valor atómico.

**Ejemplo**: Si tenemos una lista de proyectos asignados a un empleado como `ProyectoID = {P1, P2}`, necesitamos descomponerla para que cada fila tenga solo un `ProyectoID`.

Transformación:

| EmpleadoID | DepartamentoID | ProyectoID | Salario |
|------------|----------------|------------|---------|
| E1         | D1             | P1         | 5000    |
| E1         | D1             | P2         | 5000    |

### Paso 3: Recubrimiento Canónico de $F$
Este paso simplifica el conjunto de dependencias funcionales a su forma esencial, conocida como **recubrimiento canónico**.

#### Paso 3.1: Descomposición de Armstrong
Usamos esta regla para dividir las dependencias funcionales en dependencias con un solo atributo en el lado derecho.

**Ejemplo**: Si tenemos la dependencia $text{EmpleadoID} \to \text{DepartamentoID, Salario}$, la descomponemos en:
- $\text{EmpleadoID} \to \text{DepartamentoID}$
- $\text{EmpleadoID} \to \text{Salario}$

#### Paso 3.2: Eliminar Dependencias Implicadas Lógicamente
Se eliminan las dependencias funcionales que son consecuencia de otras dependencias en el conjunto.

**Ejemplo**: Si ya tenemos:
- $\text{EmpleadoID} \to \text{DepartamentoID}$
- $\text{DepartamentoID, ProyectoID} \to \text{Salario}$

Podemos eliminar cualquier dependencia redundante, manteniendo solo aquellas necesarias.

#### Paso 3.3: Unión de Armstrong
Se aplican las reglas de unión para combinar dependencias cuando es posible.

**Ejemplo**: Si tenemos:
- $\text{EmpleadoID} \to \text{DepartamentoID}$
- $\text{EmpleadoID} \to \text{Salario}$

Podemos unirlas en $\text{EmpleadoID} \to \text{DepartamentoID, Salario}$.

### Paso 4: Descomposición por Atributos Equivalentes
Si la relación no cumple con la FNBC, se procede a descomponerla buscando grupos de atributos equivalentes.

**Ejemplo**: Consideremos:
- $\text{EmpleadoID} \to \text{DepartamentoID}$
- $\text{DepartamentoID} \to \text{Salario}$

Dividimos la relación en dos tablas:
1. Una relación con $\text{EmpleadoID}$ y $\text{DepartamentoID}$.
2. Otra con $\text{DepartamentoID}$ y $\text{Salario}$.

Esto asegura que cada tabla cumple las dependencias funcionales sin redundancia.

### Paso 5: Descomposición para FNBC
Por último, se elimina cualquier dependencia funcional que no cumpla la FNBC.

**Ejemplo**: Si tenemos una relación con:
- $\text{EmpleadoID} \to \text{ProyectoID}$
- $\text{ProyectoID} \to \text{Salario}$

Para cumplir FNBC, descomponemos en:
1. Una relación entre $\text{EmpleadoID}$ y $\text{ProyectoID}$.
2. Otra entre $\text{ProyectoID}$ y $\text{Salario}$.

Al seguir estos pasos, garantizamos una base de datos bien estructurada en forma normal hasta FNBC, evitando redundancias y problemas de actualización.

# Otras Formas Normales
- **Dependencia Multivaluada**: Es una dependencia entre conjuntos de atributos \( A \), \( B \) y \( C \) donde los valores de \( B \) y \( C \) son independientes entre sí para cada valor de \( A \). Esto significa que, para un valor de \( A \), existe un conjunto de valores para \( B \) y otro conjunto para \( C \), sin que los valores de \( B \) dependan de los de \( C \), y viceversa.

- **Relación en Cuarta Forma Normal (4FN)**: Una relación que está en la Forma Normal de Boyce-Codd (FNBC) y que no contiene dependencias multivaluadas. Esto elimina redundancias que pueden no capturarse solo con dependencias funcionales.

- **Relación en Quinta Forma Normal (5FN)**: Una relación que no presenta **dependencias de combinación**, es decir, propiedades de descomposición que aseguran que, al recombinar mediante una **reunión natural** las relaciones descompuestas, no se generan tuplas incorrectas.
## Descomposición Mediante Dependencias Multivaloradas
La descomposición mediante **dependencias multivaloradas** se usa cuando un esquema cumple con la Forma Normal de Boyce-Codd (FNBC) pero sigue teniendo redundancias. Esto sucede porque la FNBC solo considera **dependencias funcionales**, que no siempre son suficientes para eliminar toda la repetición de información. Para entender este concepto, veamos un ejemplo paso a paso.

### Ejemplo: Profesor con Múltiples Departamentos y Direcciones

Supongamos que tenemos el siguiente esquema de relación en una universidad:

```
prof (ID, nombre_dept, nombre, calle, ciudad)
```

Donde:
- **ID**: Identificador único del profesor.
- **nombre_dept**: Nombre del departamento en el que trabaja el profesor.
- **nombre**: Nombre del profesor.
- **calle** y **ciudad**: Dirección de residencia del profesor.

Este esquema tiene la dependencia funcional:
- **ID → nombre, calle, ciudad**: El **ID** determina el **nombre**, **calle** y **ciudad** del profesor.

### Problema de Redundancia en FNBC

Este esquema parece normalizado en FNBC, pero si un profesor puede estar en varios departamentos o tener varias direcciones (por ejemplo, una residencia de invierno y otra de verano), aún sufrimos problemas de redundancia:

1. **Redundancia en dirección**: La dirección de cada residencia se repite en cada fila que asocia al profesor con un departamento.
   
Para solucionar esto, descomponemos el esquema en dos nuevas relaciones:
```
r1 (ID, nombre)
r2 (ID, nombre_dept, calle, ciudad)
```

Ahora, **r2** tiene redundancia porque cada dirección del profesor se repite por cada departamento con el que esté asociado.

### Dependencias Multivaloradas

Para eliminar esta redundancia, necesitamos un nuevo tipo de dependencia: la **dependencia multivalorada**. Una dependencia multivalorada se representa como:

- **ID →→ calle, ciudad**: Esto significa que la relación entre **ID** y **calle, ciudad** es independiente de la relación entre **ID** y **nombre_dept**. El hecho de que un profesor tenga varias direcciones no debería depender de los departamentos a los que pertenece.

La dependencia multivalorada **ID →→ calle, ciudad** indica que:
1. Si un profesor con **ID = 22222** está asociado al departamento de Física, **todas** sus direcciones deben estar asociadas a Física.
2. Similarmente, si tiene otra dirección y está asociado a Matemáticas, esa dirección también debe asociarse.

### Descomposición en la Cuarta Forma Normal (4FN)

Para resolver la redundancia que no elimina FNBC, usamos la **Cuarta Forma Normal (4FN)**, que incluye las dependencias multivaloradas.

Al aplicar la 4FN, descomponemos **r2** en:
```
r21 (ID, nombre_dept)
r22 (ID, calle, ciudad)
```

Ahora:
- En **r21**, cada profesor puede estar en varios departamentos sin que se repita la dirección.
- En **r22**, cada profesor puede tener múltiples direcciones sin que estas dependan de los departamentos.

### Resumen Visual

| ID   | nombre_dept | calle  | ciudad      |
|------|-------------|--------|-------------|
| 22222| Física      | Main   | Manchester  |
| 22222| Matemáticas | North  | Rye         |

Para satisfacer **ID →→ calle, ciudad**, añadimos las combinaciones necesarias:
- (Física, 22222, Main, Manchester)
- (Matemáticas, 22222, North, Rye)

### Conclusión

La 4FN asegura que los datos estén completamente libres de redundancias relacionadas con dependencias multivaloradas, algo que FNBC no puede garantizar cuando existen múltiples valores independientes para un mismo atributo.

## Mas Formas Normales
La cuarta forma normal (4FN) no es la forma normal "definitiva". Como se ha visto, las dependencias multivaluadas permiten entender y abordar ciertos tipos de redundancia en la información que las dependencias funcionales no explican. Existen también restricciones llamadas **dependencias de reunión**, que generalizan las dependencias multivaluadas y dan lugar a otra forma normal, la **forma normal de reunión por proyección (FNRP)**, también conocida en algunos textos como **quinta forma normal**.

#### Algoritmo de descomposición en 4FN
El siguiente es un algoritmo para descomponer en 4FN:
1. Inicializar:
   - `resultado = {R}`
   - `hecho = falso`
   - Calcular `D+`
   
   Para cada esquema \( R_i \) en `resultado`, \( D_i \) denota la restricción de \( D+ \) en \( R_i \).
   
2. Mientras `hecho` sea falso:
   - Si existe un esquema \( R_i \) en `resultado` que no está en 4FN con respecto a \( D_i \):
     - Sea \( \alpha →→ \beta \) una dependencia multivaluada no trivial en \( R_i \) tal que \( \alpha → R_i \notin D_i \) y \( \alpha \cap \beta = \emptyset \).
     - Actualizar `resultado` como \( (resultado - R_i) \cup (R_i - \beta) \cup (\alpha, \beta) \).
   - De lo contrario, establecer `hecho = verdadero`.

#### Otras formas normales

Además de 4FN y FNRP, existe una **forma normal de dominios y claves (FNDC)**, la cual se deriva de una clase de restricciones aún más general. Sin embargo, el uso de estas restricciones generalizadas presenta desafíos prácticos, ya que no solo son difíciles de razonar, sino que también carecen de un conjunto de reglas de inferencia completas y seguras para su análisis. Por este motivo, FNRP y FNDC son formas normales poco comunes.
