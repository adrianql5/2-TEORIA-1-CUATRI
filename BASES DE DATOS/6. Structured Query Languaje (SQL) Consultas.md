[[Archivos/bibliografia/bases_datos.pdf|bases_datos]]

Escrito por **Adrián Quiroga Linares**.

# Introducción
La parte más importante de un lenguaje de Bases de Datos es la encargada de realizar consultas. La obtención de información que relaciona datos almacenados en diferentes tablas desarrolla todo el potencial de una Base da Datos.

# Estructura Básica de una Consulta en SQL
Las consultas SQL tienen una estructura básica que consiste en tres cláusulas principales:

1. **`SELECT`**: Especifica qué columnas o expresiones deseas que se muestren en el resultado.
2. **`FROM`**: Indica de qué tablas o relaciones provienen los datos.
3. **`WHERE`**: Define condiciones o filtros que las filas deben cumplir para ser incluidas en el resultado.

### Ejemplos detallados

#### Consultas simples sobre una tabla
Si queremos encontrar los nombres de todos los profesores de una universidad, la consulta sería:

```sql
SELECT nombre 
FROM profesor;
```

- **`SELECT nombre`** indica que solo deseamos ver el atributo `nombre`.
- **`FROM profesor`** señala que estamos obteniendo los datos de la tabla `profesor`.

El resultado será una relación con una columna que contiene los nombres de todos los profesores. 

#### Eliminación de duplicados
Por defecto, SQL permite que se repitan valores en los resultados. Si varios profesores pertenecen al mismo departamento, podríamos obtener el nombre del departamento repetido. Si deseamos evitar estos duplicados, utilizamos la palabra clave `DISTINCT`:

```sql
SELECT DISTINCT nombre_dept 
FROM profesor;
```

Esto garantiza que cada nombre de departamento aparezca solo una vez.

#### Usar expresiones aritméticas
SQL permite incluir operaciones matemáticas en las consultas. Por ejemplo, si queremos aumentar un 10% el sueldo de todos los profesores:

```sql
SELECT ID, nombre, nombre_dept, sueldo * 1.1 
FROM profesor;
```

Aquí, la expresión `sueldo * 1.1` calcula el nuevo sueldo. El resultado de esta consulta incluye todas las columnas especificadas, pero el sueldo reflejará el aumento del 10%.

#### Filtrar resultados con `WHERE`
Podemos usar la cláusula `WHERE` para aplicar condiciones. Por ejemplo, si queremos encontrar solo a los profesores del departamento de Informática cuyo sueldo sea mayor a 70,000 €:

```sql
SELECT nombre 
FROM profesor 
WHERE nombre_dept = 'Informática' AND sueldo > 70000;
```

- **`WHERE nombre_dept = 'Informática'`** asegura que solo seleccionemos los profesores del departamento de Informática.
- **`AND sueldo > 70000`** filtra los que ganan más de 70,000 €.

#### Operadores lógicos en `WHERE`
SQL permite usar operadores como `AND`, `OR`, y `NOT` para combinar múltiples condiciones. Por ejemplo, si buscamos profesores cuyo departamento sea Informática o Matemáticas y su sueldo sea mayor a 70,000 €:

```sql
SELECT nombre 
FROM profesor 
WHERE (nombre_dept = 'Informática' OR nombre_dept = 'Matemáticas') 
AND sueldo > 70000;
```

Esta consulta selecciona profesores que cumplan cualquiera de las dos condiciones de departamento y cuyo sueldo supere los 70,000 €.

Estas consultas forman la base para trabajar con SQL, y más adelante se pueden ampliar con otras características como la agrupación de resultados y la unión entre múltiples tablas.

# Operaciones Básicas Adicionales en SQL

Aquí tienes una explicación detallada sobre las operaciones básicas adicionales en SQL, centrándonos en el renombrado y otras operaciones que has mencionado.

## La Operación de Renombramiento

El renombrado de atributos y relaciones en SQL es fundamental para manejar nombres de columnas y tablas de forma efectiva y legible. Utilizamos la cláusula `AS` para renombrar columnas y tablas en las consultas SQL.

### Renombrado de Atributos

Cuando ejecutamos una consulta SQL, los resultados incluyen columnas cuyos nombres provienen de las tablas de la cláusula `FROM`. Sin embargo, si hay columnas con el mismo nombre en diferentes tablas, el resultado tendrá nombres duplicados. Además, cuando se utilizan expresiones en la cláusula `SELECT`, estas no tendrán un nombre explícito. 

**Ejemplo Original:**

```sql
SELECT nombre, asignatura_id 
FROM profesor, enseña 
WHERE profesor.ID = enseña.ID;
```

En este caso, los resultados mostrarán las columnas `nombre` y `asignatura_id`. Si ambas tablas tienen un atributo llamado `nombre`, esto generará un conflicto.

**Uso de `AS` para Renombrar:**

Si queremos que el atributo `nombre` aparezca como `nombre_profesor`, podemos modificar la consulta:

```sql
SELECT nombre AS nombre_profesor, asignatura_id 
FROM profesor, enseña 
WHERE profesor.ID = enseña.ID;
```

Esto es útil para clarificar los resultados y evitar confusiones.

### Renombrado de Relaciones

También podemos renombrar tablas utilizando la cláusula `AS`. Esto es especialmente útil cuando queremos hacer referencias a la misma tabla varias veces. Por ejemplo, si queremos comparar los sueldos de los profesores en un departamento específico:

```sql
SELECT DISTINCT T.nombre 
FROM profesor AS T, profesor AS S 
WHERE T.sueldo > S.sueldo AND S.nombre_dept = 'Biología';
```

Aquí, `T` y `S` son alias para la misma tabla `profesor`, permitiendo que la consulta sea más legible y que podamos diferenciar entre las dos instancias de la misma tabla.

## Operaciones con Cadenas de Caracteres

Las cadenas de caracteres en SQL se definen usando comillas simples. Es importante tener en cuenta que la comparación de cadenas es sensible a las mayúsculas en la mayoría de los sistemas de bases de datos, excepto en algunos como MySQL.

**Funciones Comunes con Cadenas:**

- **Concatenación:** Usando `||` para unir cadenas.
- **Longitud:** `LENGTH(cadena)` para obtener el número de caracteres.
- **Subcadenas:** `SUBSTRING(cadena, inicio, longitud)` para extraer partes de una cadena.
- **Cambio de Mayúsculas:** `UPPER(cadena)` y `LOWER(cadena)` para transformar a mayúsculas o minúsculas.

**Ejemplo de Concatenación:**

```sql
SELECT nombre || ' ' || apellido AS nombre_completo 
FROM profesor;
```

**Uso de `LIKE` para Comparaciones:**

El operador `LIKE` se utiliza para buscar patrones en cadenas. Los caracteres especiales son `%` (cualquier subcadena) y `_` (cualquier carácter).

**Ejemplo de Búsqueda de Patrones:**

```sql
SELECT nombre_dept 
FROM departamento 
WHERE edificio LIKE '%Watson%';
```

Esto busca todos los departamentos cuyo nombre de edificio contenga "Watson".

## Especificación de Atributos en la Cláusula `SELECT`

Podemos utilizar el asterisco `*` en la cláusula `SELECT` para seleccionar todos los atributos de una tabla. Por ejemplo:

```sql
SELECT profesor.* 
FROM profesor, enseña 
WHERE profesor.ID = enseña.ID;
```

Esto selecciona todos los atributos de la tabla `profesor`.

## Orden en la Presentación de las Tuplas

SQL permite controlar el orden de las filas devueltas con la cláusula `ORDER BY`. Por defecto, el orden es ascendente.

**Ejemplo de Ordenación Ascendente:**

```sql
SELECT nombre 
FROM profesor 
WHERE nombre_dept = 'Física' 
ORDER BY nombre;
```

**Orden Descendente y Múltiples Atributos:**

```sql
SELECT * 
FROM profesor 
ORDER BY sueldo DESC, nombre ASC;
```

Esto ordena los resultados por `sueldo` de manera descendente y, en caso de empate, por `nombre` de manera ascendente.

## Predicados de la Cláusula `WHERE`

SQL proporciona el operador `BETWEEN` para simplificar las condiciones en la cláusula `WHERE`. Este operador se usa para especificar un rango de valores.

**Ejemplo de Uso de `BETWEEN`:**

```sql
SELECT nombre 
FROM profesor 
WHERE sueldo BETWEEN 90000 AND 100000;
```

Esto busca los nombres de los profesores cuyo sueldo está entre 90,000 y 100,000.

**Uso de `NOT BETWEEN`:**

También se puede usar para excluir rangos:

```sql
SELECT nombre 
FROM profesor 
WHERE sueldo NOT BETWEEN 90000 AND 100000;
```

#### Resumen

SQL ofrece una variedad de operaciones adicionales que permiten manipular y presentar datos de manera efectiva. El renombrado de atributos y relaciones mejora la legibilidad de las consultas, mientras que las operaciones con cadenas, el orden de las tuplas y los predicados en `WHERE` permiten una mayor flexibilidad al trabajar con datos. Estos conceptos son esenciales para realizar consultas complejas y obtener la información deseada de una base de datos de manera eficiente.

# Operaciones sobre conjuntos
Vamos a desglosar cada una de las operaciones de conjunto en SQL: **unión**, **intersección** y **excepto**, con ejemplos detallados para cada caso.

### 1. Unión (`UNION`)

La operación **unión** combina los resultados de dos consultas, eliminando los duplicados. 

#### Ejemplo:
Supongamos que tenemos dos conjuntos de secciones de asignaturas:

- **c1**: Secciones del semestre de otoño de 2009.
    - CS-101
    - CS-315
    - CS-319
    - CS-347
    - CS-101  (duplicado)

- **c2**: Secciones del semestre de primavera de 2010.
    - CS-101
    - CS-319
    - MU-199

La consulta sería:

```sql
SELECT asignatura_id FROM sección WHERE semestre = 'Otoño' AND año = 2009
UNION
SELECT asignatura_id FROM sección WHERE semestre = 'Primavera' AND año = 2010;
```

#### Resultado:
- **Unión de c1 y c2**:
    - CS-101
    - CS-315
    - CS-319
    - CS-347
    - MU-199

Si en `c1` hubiera dos secciones de **CS-101**, entonces el resultado tendría una sola tupla de **CS-101**. Pero si, por ejemplo, hubiera **cuatro secciones de ECE-101** en otoño de 2009 y **dos secciones de ECE-101** en primavera de 2010, en el resultado habría **seis tuplas de ECE-101**.

### 2. Intersección (`INTERSECT`)

La operación **intersección** devuelve solo las tuplas que están presentes en ambas consultas. 

#### Ejemplo:
Siguiendo con las mismas secciones:

- **c1**: Secciones del semestre de otoño de 2009.
    - CS-101
    - CS-315
    - CS-319

- **c2**: Secciones del semestre de primavera de 2010.
    - CS-101
    - CS-319

La consulta sería:

```sql
SELECT asignatura_id FROM sección WHERE semestre = 'Otoño' AND año = 2009
INTERSECT
SELECT asignatura_id FROM sección WHERE semestre = 'Primavera' AND año = 2010;
```

#### Resultado:
- **Intersección de c1 y c2**:
    - CS-101
    - CS-319

Si en el caso de **ECE-101** hubiera cuatro secciones en otoño de 2009 y dos en primavera de 2010, en el resultado solo habría **una tupla de ECE-101**.

Si quieres mantener los duplicados, puedes usar `INTERSECT ALL`:

```sql
SELECT asignatura_id FROM sección WHERE semestre = 'Otoño' AND año = 2009
INTERSECT ALL
SELECT asignatura_id FROM sección WHERE semestre = 'Primavera' AND año = 2010;
```

En este caso, si **ECE-101** tiene **4 en otoño y 2 en primavera**, el resultado tendría **2 tuplas de ECE-101**, que es el número mínimo de duplicados.

### 3. Excepto (`EXCEPT`)

La operación **excepto** devuelve las tuplas que están en la primera consulta pero no en la segunda. 

#### Ejemplo:
Usando los mismos conjuntos:

- **c1**: Secciones del semestre de otoño de 2009.
    - CS-101
    - CS-315
    - CS-319

- **c2**: Secciones del semestre de primavera de 2010.
    - CS-101
    - CS-319

La consulta sería:

```sql
SELECT asignatura_id FROM sección WHERE semestre = 'Otoño' AND año = 2009
EXCEPT
SELECT asignatura_id FROM sección WHERE semestre = 'Primavera' AND año = 2010;
```

#### Resultado:
- **Excepto de c1 y c2**:
    - CS-315

Si, por ejemplo, hay **cuatro secciones de ECE-101** en otoño de 2009 y **dos secciones de ECE-101** en primavera de 2010, el resultado no tendría ninguna tupla de **ECE-101**.

Si deseas mantener los duplicados, puedes usar `EXCEPT ALL`:

```sql
SELECT asignatura_id FROM sección WHERE semestre = 'Otoño' AND año = 2009
EXCEPT ALL
SELECT asignatura_id FROM sección WHERE semestre = 'Primavera' AND año = 2010;
```

Aquí, si hay **cuatro secciones de ECE-101** en otoño y **dos secciones** en primavera, el resultado tendría **dos tuplas de ECE-101**.

### Resumen

- **UNION**: Combina resultados, eliminando duplicados. Si hay duplicados en ambas consultas, se cuenta una sola vez en el resultado.
- **INTERSECT**: Devuelve solo los elementos comunes entre ambas consultas. Elimina duplicados automáticamente.
- **EXCEPT**: Devuelve elementos de la primera consulta que no están en la segunda. Elimina duplicados automáticamente, pero puede mantenerlos usando `EXCEPT ALL`. 

Estos conceptos son fundamentales en SQL y se utilizan ampliamente en la manipulación de datos y la obtención de información relevante a partir de múltiples conjuntos de datos.

# Valor NULL
Los valores nulos en SQL son un concepto importante que implica ciertas peculiaridades en las operaciones aritméticas, de comparación y de conjunto. Aquí te explico en detalle cómo funcionan y cómo afectan las consultas:

### 1. Operaciones Aritméticas con Nulos

Cuando realizas operaciones aritméticas, cualquier expresión que involucre un valor nulo resultará en nulo. Por ejemplo, si tienes la siguiente expresión:

```sql
SELECT r.A + 5 FROM tabla r;
```

Si `r.A` es nulo para alguna de las tuplas, el resultado de `r.A + 5` también será nulo para esa tupla. Esto se debe a que no se puede determinar un resultado numérico válido si uno de los operandos es nulo.

### 2. Comparaciones con Nulos

Las comparaciones que involucran valores nulos son problemáticas. Por ejemplo, consideremos la comparación:

```sql
1 < NULL
```

No se puede afirmar que esta comparación sea verdadera o falsa porque no se conoce el valor que representa `NULL`. Por lo tanto, SQL considera el resultado de cualquier comparación que involucre un valor nulo como `unknown` (desconocido). Esto crea un tercer estado lógico además de `true` (verdadero) y `false` (falso).

#### Ejemplo de Comparaciones

- Si `A` es nulo, tanto la expresión `1 < A` como `NOT (1 < A)` se evaluarán como `unknown`.
- En SQL, se utiliza `IS NULL` y `IS NOT NULL` para verificar si un valor es nulo. Por ejemplo:

```sql
SELECT nombre FROM profesor WHERE sueldo IS NULL;
```

Este comando devuelve los nombres de los profesores cuyo sueldo es nulo.

### 3. Tratamiento de Valores Lógicos

Debido a la introducción de `unknown`, las operaciones booleanas deben extenderse para incluir este estado adicional. Aquí están las reglas:

- **AND**
  - `true AND unknown` → `unknown`
  - `false AND unknown` → `false`
  - `unknown AND unknown` → `unknown`

- **OR**
  - `true OR unknown` → `true`
  - `false OR unknown` → `unknown`
  - `unknown OR unknown` → `unknown`

- **NOT**
  - `NOT unknown` → `unknown`

### 4. Comparaciones en `WHERE`

Si una tupla evalúa el predicado de la cláusula `WHERE` como `false` o `unknown`, no se incluirá en el resultado. Por lo tanto, es crucial manejar los valores nulos correctamente para asegurar que las tuplas deseadas sean devueltas.

### 5. Eliminación de Duplicados con `DISTINCT`

Cuando usas la cláusula `DISTINCT`, SQL elimina las tuplas duplicadas. Dos tuplas se consideran idénticas si ambas son nulas o tienen el mismo valor en todos los atributos. Por ejemplo, las tuplas:

```sql
('A', NULL)
('A', NULL)
```

se tratarían como idénticas, y solo se mantendría una de ellas en el resultado.

### 6. Ejemplo de Uso de `DISTINCT`

Si ejecutas la siguiente consulta:

```sql
SELECT DISTINCT columna1, columna2 FROM tabla;
```

Si tienes tuplas como:

```sql
('A', NULL)
('A', NULL)
('B', 5)
```

El resultado sería:

```sql
('A', NULL)
('B', 5)
```

### 7. Operaciones de Conjunto con Nulos

El tratamiento de valores nulos también se aplica en las operaciones de conjunto, como unión, intersección y diferencia (`EXCEPT`). En estas operaciones, dos tuplas se consideran iguales si todos sus atributos tienen valores iguales, incluso si alguno es nulo. Por ejemplo, en la unión de dos conjuntos que incluyen tuplas con valores nulos, se mantendrán como idénticas.

### Conclusión

El manejo de valores nulos en SQL es fundamental para garantizar que las consultas devuelvan resultados precisos y esperados. Comprender cómo se comportan los nulos en operaciones aritméticas, comparaciones y conjuntos ayuda a evitar errores y confusiones en el análisis de datos.

# Funciones de agregación
Las funciones de agregación en SQL son herramientas fundamentales que permiten realizar cálculos sobre conjuntos de datos y devolver un único resultado. A continuación, se presenta una explicación detallada de las funciones de agregación, su uso, y ejemplos para ilustrar su aplicación.

## Funciones de Agregación

Las funciones de agregación toman un conjunto de valores y devuelven un único valor. SQL incluye las siguientes funciones de agregación incorporadas:

1. **Media (`avg`)**: Calcula la media aritmética de un conjunto de valores.
2. **Mínimo (`min`)**: Devuelve el valor mínimo de un conjunto.
3. **Máximo (`max`)**: Devuelve el valor máximo de un conjunto.
4. **Total (`sum`)**: Calcula la suma total de un conjunto de valores.
5. **Recuento (`count`)**: Devuelve el número de elementos en un conjunto.

## Agregación Básica

#### Ejemplo de Media

Considera una consulta para encontrar el sueldo medio de los profesores del departamento de Informática:

```sql
SELECT AVG(sueldo) FROM profesor WHERE nombre_dept = 'Informática';
```

Esta consulta devuelve una relación con un único atributo que contiene un único valor numérico, que es la media del sueldo de todos los profesores en el departamento especificado.

Para asignar un nombre al resultado, se puede utilizar la cláusula `AS`:

```sql
SELECT AVG(sueldo) AS med_sueldo FROM profesor WHERE nombre_dept = 'Informática';
```

Si los sueldos en el departamento de Informática son 75,000 €, 65,000 € y 92,000 €, el cálculo sería:

$$
\text{Media} = \frac{75,000 + 65,000 + 92,000}{3} = 77,333.33
$$

#### Manejo de Duplicados

La función `AVG` considera todos los valores, incluidos los duplicados. Si se añade un cuarto profesor con un sueldo de 75,000 €, y se eliminan los duplicados, la media incorrecta sería:

$$
\frac{232,000}{4} = 58,000
$$

Para evitar esto, se debe calcular considerando todos los valores. Si se desea eliminar duplicados, se puede usar `DISTINCT`:

#### Ejemplo de Recuento

Supongamos que queremos contar el número total de profesores que enseñaron en un semestre específico:

```sql
SELECT COUNT(DISTINCT ID) FROM enseña WHERE semestre = 'Primavera' AND año = 2010;
```

Aquí, cada profesor se cuenta solo una vez, independientemente de cuántas asignaturas enseñó.

Para contar todas las tuplas en una relación, se usa:

```sql
SELECT COUNT(*) FROM asignatura;
```

## Agregación con Agrupamiento

La cláusula `GROUP BY` permite aplicar funciones de agregación a grupos de tuplas. Por ejemplo, para encontrar el sueldo medio de cada departamento:

```sql
SELECT nombre_dept, AVG(sueldo) AS med_sueldo FROM profesor GROUP BY nombre_dept;
```

Esto agrupa las tuplas por `nombre_dept` y calcula la media para cada grupo. 

#### Ejemplo de Consulta Sin Agrupamiento

Si se quisiera obtener el sueldo medio de todos los profesores sin agrupar, la consulta sería:

```sql
SELECT AVG(sueldo) FROM profesor;
```

## La Cláusula `HAVING`

La cláusula `HAVING` se utiliza para filtrar grupos después de aplicar funciones de agregación. Por ejemplo, para encontrar departamentos donde el sueldo medio de los profesores es superior a 42,000 €:

```sql
SELECT nombre_dept, AVG(sueldo) AS med_sueldo 
FROM profesor 
GROUP BY nombre_dept 
HAVING AVG(sueldo) > 42000;
```

En este caso, `HAVING` aplica el filtro después de calcular la media para cada grupo.

## Agregación con Valores Nulos y Booleanos

Cuando se trata de valores nulos, las funciones de agregación se comportan de la siguiente manera:

- **`SUM`** e **`AVG`** ignoran los valores nulos. Por ejemplo:

```sql
SELECT SUM(sueldo) FROM profesor;
```

Si algunas tuplas tienen `NULL` en `sueldo`, estas se ignoran en el cálculo.

- **`COUNT(*)`** cuenta todas las tuplas, incluso si contienen valores nulos. Sin embargo, **`COUNT(columna)`** ignora los nulos en esa columna.

Por ejemplo:

```sql
SELECT COUNT(sueldo) FROM profesor;  -- Ignora nulos en sueldo
SELECT COUNT(*) FROM profesor;        -- Cuenta todas las tuplas
```

### Resumen

Las funciones de agregación son herramientas poderosas para resumir y analizar datos en SQL. Permiten realizar cálculos sobre conjuntos de datos, manejar duplicados y filtrar resultados de manera efectiva. Es importante comprender cómo y cuándo utilizar `WHERE`, `GROUP BY`, y `HAVING` para obtener los resultados deseados en las consultas SQL.


# Subconsultas anidadas
Las subconsultas anidadas son una técnica poderosa en SQL que permite ejecutar consultas dentro de otras. Estas subconsultas se utilizan para operaciones complejas que involucran comprobaciones de pertenencia, comparaciones entre conjuntos y cardinalidades. Las subconsultas suelen aparecer en la cláusula `WHERE`, pero también pueden aparecer en otras partes de la consulta, como en la cláusula `FROM` o incluso en expresiones.

### Pertenencia a conjuntos

La conectiva `IN` permite comprobar si un valor pertenece a un conjunto devuelto por una subconsulta. Esto es útil para consultas en las que queremos verificar si una tupla cumple ciertas condiciones basadas en otro conjunto de resultados.

#### Ejemplo 1: Uso de `IN`
Queremos encontrar todas las asignaturas que se enseñaron tanto en el semestre de otoño de 2009 como en primavera de 2010. En lugar de usar una intersección de conjuntos, podemos formular la consulta usando una subconsulta con `IN`:

```sql
SELECT DISTINCT asignatura_id
FROM sección
WHERE semestre = 'Otoño' AND año = 2009
  AND asignatura_id IN (
    SELECT asignatura_id
    FROM sección
    WHERE semestre = 'Primavera' AND año = 2010
);
```

En este caso, la subconsulta interna genera un conjunto de asignaturas enseñadas en primavera de 2010, y la consulta externa selecciona las asignaturas de otoño de 2009 que están en ese conjunto.

#### Ejemplo 2: Uso de `NOT IN`
Para encontrar todas las asignaturas que se enseñaron en otoño de 2009, pero no en primavera de 2010, podemos usar `NOT IN`:

```sql
SELECT DISTINCT asignatura_id
FROM sección
WHERE semestre = 'Otoño' AND año = 2009
  AND asignatura_id NOT IN (
    SELECT asignatura_id
    FROM sección
    WHERE semestre = 'Primavera' AND año = 2010
);
```

#### Ejemplo 3: Uso de `IN` con conjuntos enumerados
Podemos usar `IN` con valores específicos, por ejemplo, para encontrar a los profesores que no son ni "Mozart" ni "Einstein":

```sql
SELECT DISTINCT nombre
FROM profesor
WHERE nombre NOT IN ('Mozart', 'Einstein');
```

### Comparación de conjuntos

SQL permite comparar un valor con los elementos de un conjunto devuelto por una subconsulta. Para esto se usan operadores como `> SOME` y `> ALL`.

#### Ejemplo 1: Comparación con `SOME`
Queremos encontrar los nombres de los profesores cuyo sueldo es mayor que al menos uno de los profesores del departamento de Biología:

```sql
SELECT nombre
FROM profesor
WHERE sueldo > SOME (
  SELECT sueldo
  FROM profesor
  WHERE nombre_dept = 'Biología'
);
```

Aquí, la subconsulta devuelve los sueldos de los profesores del departamento de Biología. La condición `> SOME` se cumple si el sueldo del profesor es mayor que al menos uno de esos sueldos.

#### Ejemplo 2: Comparación con `ALL`
Si quisiéramos encontrar los profesores cuyo sueldo es mayor que el de **todos** los profesores de Biología, usaríamos `> ALL`:

```sql
SELECT nombre
FROM profesor
WHERE sueldo > ALL (
  SELECT sueldo
  FROM profesor
  WHERE nombre_dept = 'Biología'
);
```

En este caso, la consulta devuelve los profesores cuyo sueldo es mayor que el sueldo más alto de cualquier profesor de Biología.

### Comprobación de relaciones vacías

El operador `EXISTS` permite comprobar si una subconsulta devuelve alguna tupla. Esto es útil para verificar si un conjunto no está vacío.

#### Ejemplo: Uso de `EXISTS`
Queremos encontrar todas las asignaturas que se enseñaron tanto en el semestre de otoño de 2009 como en el de primavera de 2010:

```sql
SELECT asignatura_id
FROM sección AS S
WHERE semestre = 'Otoño' AND año = 2009
  AND EXISTS (
    SELECT *
    FROM sección AS T
    WHERE semestre = 'Primavera' AND año = 2010
      AND S.asignatura_id = T.asignatura_id
);
```

En este caso, `EXISTS` devuelve `TRUE` si la subconsulta encuentra alguna asignatura en primavera de 2010 que coincida con las de otoño de 2009.

### Comprobación de la ausencia de tuplas duplicadas

El constructor `UNIQUE` permite verificar que una subconsulta no contenga tuplas duplicadas.

#### Ejemplo: Uso de `UNIQUE`
Queremos encontrar todas las asignaturas que se ofrecieron al menos una vez en 2009:

```sql
SELECT T.asignatura_id
FROM asignatura AS T
WHERE UNIQUE (
  SELECT R.asignatura_id
  FROM sección AS R
  WHERE T.asignatura_id = R.asignatura_id
    AND R.año = 2009
);
```

Aquí, `UNIQUE` garantiza que no haya duplicados en las asignaturas ofrecidas en 2009.

### Subconsultas en la cláusula `FROM`

SQL permite incluir subconsultas en la cláusula `FROM`, tratándolas como tablas temporales. Esto es útil para realizar consultas más complejas o cuando se necesita trabajar con resultados intermedios.

#### Ejemplo: Subconsulta en `FROM`
Supongamos que queremos encontrar el sueldo promedio de cada departamento y luego seleccionar aquellos departamentos donde el promedio es mayor que 50000:

```sql
SELECT dept.nombre_dept, dept.promedio_sueldo
FROM (
  SELECT nombre_dept, AVG(sueldo) AS promedio_sueldo
  FROM profesor
  GROUP BY nombre_dept
) AS dept
WHERE dept.promedio_sueldo > 50000;
```

En este ejemplo, la subconsulta en `FROM` calcula los sueldos promedio por departamento y luego la consulta externa selecciona los departamentos con un promedio superior a 50000.

### Subconsultas escalares

Las subconsultas escalares devuelven un único valor y pueden aparecer en cualquier lugar de una consulta donde se espere un valor único.

#### Ejemplo: Subconsulta escalar en `SELECT`
Queremos obtener el nombre de cada profesor y el número total de profesores en el departamento de Biología:

```sql
SELECT nombre, (
  SELECT COUNT(*)
  FROM profesor
  WHERE nombre_dept = 'Biología'
) AS total_profesores_biologia
FROM profesor;
```

La subconsulta escalar devuelve el número total de profesores de Biología para cada fila del resultado de la consulta principal.

---

# Expresiones de reunión en SQL
En este capítulo se estudian temas más avanzados de SQL, como consultas más complejas, definición de vistas, transacciones, restricciones de integridad, más detalles sobre la definición de datos y la autorización. Un enfoque importante es el uso de diferentes tipos de *joins* o reuniones, que permiten combinar datos de múltiples tablas de maneras más flexibles.

### Condiciones de reunión

La **reunión natural** (*natural join*) se presentó previamente y es una forma de combinar dos tablas en las que se unen las filas que tienen el mismo valor en todas las columnas con el mismo nombre. Sin embargo, SQL proporciona otras formas más personalizables de realizar reuniones, permitiendo especificar predicados arbitrarios para determinar cómo se deben unir las filas de diferentes tablas.

Un ejemplo básico de **reunión con una condición específica** es el uso de la cláusula `on`. Esta cláusula funciona de forma similar a `where`, pero se utiliza específicamente para indicar cómo deben coincidir las filas de las tablas que se están uniendo. A continuación, se muestra un ejemplo de reunión usando `on`:

```sql
select * 
from estudiante 
join matricula 
on estudiante.ID = matricula.ID;
```

En este caso, la condición `on` asegura que las filas de las tablas `estudiante` y `matricula` se unan cuando sus valores en la columna `ID` coincidan. La principal diferencia con la reunión natural es que, con `on`, se pueden especificar las condiciones de unión de forma explícita y flexible, lo que permite tener más control sobre cómo se combinan los datos.

Este ejemplo es casi equivalente a:

```sql
select * 
from estudiante, matricula 
where estudiante.ID = matricula.ID;
```

Sin embargo, la cláusula `on` resulta más clara cuando se trata de especificar las condiciones de reunión, separando estas condiciones del resto de los filtros de la consulta, que se colocarían en la cláusula `where`.

### Reunión externa

Una limitación de la **reunión interna** (*inner join*) es que omite las filas de una tabla que no tienen coincidencias en la otra. Por ejemplo, si se quiere listar todos los estudiantes, aunque no estén matriculados en ninguna asignatura, la reunión interna fallaría, ya que los estudiantes sin coincidencias en la tabla `matricula` serían excluidos.

La **reunión externa** (*outer join*) resuelve este problema al incluir también las filas que no tienen coincidencias. Existen tres tipos de reuniones externas:

1. **Reunión externa izquierda (left outer join)**: Conserva todas las filas de la tabla a la izquierda de la operación, incluso si no tienen coincidencias en la tabla de la derecha. Los valores de las columnas de la tabla de la derecha se rellenan con `null` en estas filas.

   Ejemplo:

   ```sql
   select * 
   from estudiante 
   left outer join matricula 
   on estudiante.ID = matricula.ID;
   ```

   En este caso, se mostrarán todos los estudiantes, incluso aquellos que no tienen ninguna matrícula, como en el caso del estudiante `Snow` que no aparece en la tabla `matricula`.

2. **Reunión externa derecha (right outer join)**: Es similar a la reunión externa izquierda, pero conserva todas las filas de la tabla a la derecha de la operación.

   Ejemplo:

   ```sql
   select * 
   from matricula 
   right outer join estudiante 
   on estudiante.ID = matricula.ID;
   ```

   Esta consulta es equivalente a la anterior, pero cambia el orden de las tablas.

3. **Reunión externa completa (full outer join)**: Combina los resultados de la reunión externa izquierda y derecha, conservando todas las filas de ambas tablas. Las filas que no tienen coincidencias en la otra tabla tendrán valores `null` en las columnas correspondientes.

   Ejemplo:

   ```sql
   select * 
   from estudiante 
   full outer join matricula 
   on estudiante.ID = matricula.ID;
   ```

#### Ejemplo práctico de reunión externa

Supongamos que queremos encontrar todos los estudiantes que no están matriculados en ninguna asignatura. Podemos usar una reunión externa izquierda y filtrar los resultados donde el `asignatura_id` sea `null`, ya que estos estudiantes no tendrán coincidencias en la tabla `matricula`:

```sql
select ID 
from estudiante 
left outer join matricula 
on estudiante.ID = matricula.ID 
where asignatura_id is null;
```

Este tipo de consultas es útil cuando necesitamos trabajar con datos incompletos o queremos asegurarnos de incluir todas las filas, incluso si no tienen coincidencias en una relación específica.

En resumen, las reuniones externas proporcionan una forma más flexible de combinar tablas, permitiendo gestionar de manera adecuada los datos faltantes y asegurando que se incluyan todas las filas, incluso aquellas que no tienen coincidencias en la otra tabla.