[[Archivos/bibliografia/bases_datos.pdf|bases_datos]]
# Transacciones
**Definiciones importantes:**

**Transacción:** Acción o serie de acciones, llevadas a cabo por un usuario o por una aplicación, que leen y/o actualizan el contenido de la Base de Datos.

**Atomicidad:** Propiedad de una Transacción que garantiza su indivisibilidad (o bien se realizan todas las acciones en su totalidad o bien la Base de Datos vuelve a su estado inicial como si no se realizara nada).


En bases de datos, una **transacción** es una secuencia de operaciones SQL que se ejecutan como una unidad de trabajo. Las transacciones garantizan que las operaciones sean **atómicas** (o se completan todas, o ninguna) y preservan la **consistencia** de la base de datos.

1. **Inicio de la Transacción**: 
   En SQL, una transacción se inicia automáticamente al ejecutar una sentencia SQL. No es necesario un comando específico para iniciar una transacción; cualquier consulta de actualización (como `UPDATE`, `INSERT`, o `DELETE`) marca implícitamente el comienzo.

2. **Finalización de la Transacción**: 
   Para finalizar una transacción, SQL ofrece dos comandos principales:
   - `COMMIT`: Guarda todos los cambios realizados durante la transacción y los hace permanentes en la base de datos. Se garantiza que todos los cambios sean visibles para otros usuarios.
   - `ROLLBACK`: Revierte todos los cambios de la transacción, dejando la base de datos en el estado en el que se encontraba antes de iniciar la transacción. Esto es útil para deshacer operaciones en caso de errores.

   Por ejemplo, si realizas varias operaciones en una aplicación bancaria para transferir fondos entre dos cuentas:

   ```sql
   BEGIN; -- (Iniciado implícitamente al realizar la primera operación)
   UPDATE cuentas SET saldo = saldo - 100 WHERE cuenta_id = 1; -- Restar dinero
   UPDATE cuentas SET saldo = saldo + 100 WHERE cuenta_id = 2; -- Sumar dinero
   COMMIT; -- Guardar los cambios
   ```

   Si hay algún error entre las actualizaciones (por ejemplo, si se retira dinero pero falla al sumarlo), el `ROLLBACK` garantiza que la base de datos regrese al estado inicial, evitando inconsistencias.

3. **Fallos y Recuperación Automática**:
   Si ocurre un fallo (por ejemplo, una caída de sistema) antes de ejecutar `COMMIT`, SQL garantiza que los efectos de la transacción incompleta se reviertan automáticamente. Al reiniciar, el sistema restaura la base de datos al estado anterior de la transacción fallida.

### Ejemplo de Uso de Transacciones en Casos Prácticos

#### a) Transferencia Bancaria
   En una transferencia bancaria, necesitas restar fondos de una cuenta y sumarlos en otra. Si el sistema falla después de restar el dinero pero antes de añadirlo, habrá un desequilibrio. Por lo tanto, estas operaciones deben ejecutarse como una transacción única:

   ```sql
   UPDATE cuentas SET saldo = saldo - 500 WHERE cuenta_id = 'A';
   UPDATE cuentas SET saldo = saldo + 500 WHERE cuenta_id = 'B';
   COMMIT;
   ```

   Si alguna de las operaciones falla, `ROLLBACK` revierte los cambios, manteniendo la consistencia de los saldos de ambas cuentas.

#### b) Sistema Universitario
   Imagina que al actualizar la información de un estudiante, necesitas ajustar tanto los créditos en la tabla de asignaturas como en la tabla de estudiantes. Si una actualización se realiza y la otra falla, los datos quedarían en un estado inconsistente.

   ```sql
   UPDATE asignatura SET estado = 'completa' WHERE estudiante_id = 1234;
   UPDATE estudiante SET tot_creditos = tot_creditos + 6 WHERE estudiante_id = 1234;
   COMMIT;
   ```

   Si una de las actualizaciones falla, un `ROLLBACK` permite restaurar el estado original y evita inconsistencias en el total de créditos del estudiante.

---

## Violación de Restricciones de Integridad

En algunas transacciones complejas, es posible que temporalmente se violen restricciones de integridad durante una operación intermedia, pero que una operación posterior restaure la integridad. SQL permite gestionar esto con restricciones **diferibles**, es decir, que pueden aplazarse hasta el final de la transacción para su comprobación.

#### Ejemplo de Restricciones Diferibles

Supón que tienes una tabla `persona` con los atributos `nombre` y `conyuge`, donde `conyuge` es una clave externa que debe existir en la misma tabla `persona`. Si queremos registrar a dos personas casadas (Juan y María), cualquier inserción inicial violará la restricción, pues `conyuge` aún no existe en la tabla. La solución es diferir la restricción de clave externa hasta el final de la transacción:

```sql
-- Configurar restricciones diferibles
SET CONSTRAINTS foreign_key_de_conyuge DEFERRED;

-- Insertar a Juan y María en una única transacción
INSERT INTO persona (nombre, conyuge) VALUES ('Juan', 'Maria');
INSERT INTO persona (nombre, conyuge) VALUES ('Maria', 'Juan');
COMMIT;
```

Aquí, SQL diferirá la verificación hasta que se haya insertado la segunda tupla, permitiendo que ambos registros se realicen correctamente antes de aplicar la restricción de integridad.

### En Resumen:
Las transacciones aseguran operaciones atómicas y consistentes, y `COMMIT` y `ROLLBACK` permiten controlar si las operaciones se consolidan o revierten. Además, el SQL estándar ofrece la posibilidad de diferir restricciones de integridad para mantener la consistencia en operaciones complejas, garantizando así que las bases de datos se mantengan correctas y coherentes tras cada transacción.


# Tipos de Datos y Esquemas de SQL

En SQL, los tipos de datos y esquemas permiten definir cómo se almacena y maneja la información en una base de datos. Vamos a explorar los principales tipos de datos, sus usos y funcionalidades, así como la creación de esquemas para organizar la estructura de datos.

### Tipos Fecha y Hora en SQL

Además de los tipos básicos (enteros, reales, cadenas de caracteres), SQL también incluye tipos específicos para manejar fechas y horas. Estos tipos son esenciales para el manejo de datos temporales en bases de datos.

1. **`DATE`**: Representa una fecha en el formato `YYYY-MM-DD` (año, mes, día).
   - Ejemplo: `DATE '2001-04-25'` representa el 25 de abril de 2001.

2. **`TIME`**: Representa una hora en el formato `HH:MM:SS` (horas, minutos, segundos).
   - Se puede especificar precisión decimal en los segundos: `TIME(3)` para milisegundos.
   - Puede incluir zona horaria con `TIME WITH TIMEZONE`.
   - Ejemplo: `TIME '09:30:00'` representa las 9:30 AM.

3. **`TIMESTAMP`**: Combina fecha y hora en un solo valor (`YYYY-MM-DD HH:MM:SS`).
   - Soporta precisión decimal en los segundos (`TIMESTAMP(p)`).
   - Puede incluir información de zona horaria con `TIMESTAMP WITH TIMEZONE`.
   - Ejemplo: `TIMESTAMP '2001-04-25 10:29:01.45'` representa el 25 de abril de 2001 a las 10:29:01.450 AM.

Estos valores pueden extraerse o manipularse en SQL mediante funciones como:
- **`EXTRACT`**: Extrae un componente (por ejemplo, `YEAR`, `MONTH`, `DAY`, `HOUR`, etc.) de un valor de fecha o tiempo.
  - Ejemplo: `EXTRACT(YEAR FROM DATE '2001-04-25')` devolvería `2001`.

- **Funciones de fecha y hora actuales**: Proporcionan la fecha y hora actuales del sistema:
  - `CURRENT_DATE` devuelve la fecha actual.
  - `CURRENT_TIME` devuelve la hora actual con zona horaria.
  - `CURRENT_TIMESTAMP` devuelve fecha y hora actuales con zona horaria.

Además, **se pueden realizar cálculos de intervalos**. Por ejemplo, restar dos valores `DATE` devuelve el intervalo entre ellos en días, y sumar un intervalo a una fecha devuelve una nueva fecha.

### Valores Predeterminados

SQL permite definir valores predeterminados para atributos cuando no se proporciona un valor específico al insertar datos.

```sql
CREATE TABLE estudiante (
    ID VARCHAR(5),
    nombre VARCHAR(20) NOT NULL,
    nombre_dept VARCHAR(20),
    tot_creditos NUMERIC(3,0) DEFAULT 0,
    PRIMARY KEY (ID)
);
```

En este ejemplo, el atributo `tot_creditos` tiene un valor predeterminado de `0`. Si se inserta una nueva fila sin especificar `tot_creditos`, automáticamente se asigna `0`.

```sql
INSERT INTO estudiante(ID, nombre, nombre_dept) 
VALUES ('12789', 'Newman', 'Informática');
```

En esta inserción, `tot_creditos` se establecerá en `0` automáticamente.

### Creación de Índices

Los índices en SQL optimizan el acceso a los datos. Un índice es una estructura que permite encontrar registros rápidamente sin tener que recorrer toda la tabla.

```sql
CREATE INDEX estudianteID_indice ON estudiante(ID);
```

En este ejemplo, se crea un índice en el atributo `ID` de la tabla `estudiante`. Esto acelera las consultas que buscan valores específicos en `ID`. Por ejemplo, una consulta que busca un estudiante por `ID` (`SELECT * FROM estudiante WHERE ID = '22201'`) usará el índice para localizar rápidamente el registro, en lugar de revisar toda la tabla.

### Tipos de Datos para Objetos Grandes

SQL maneja grandes volúmenes de datos mediante los tipos `CLOB` (Character Large Object) para texto y `BLOB` (Binary Large Object) para datos binarios, como imágenes o videos.

```sql
CREATE TABLE multimedia (
    revista CLOB(10 KB),
    imagen BLOB(10 MB),
    pelicula BLOB(2 GB)
);
```

Estos tipos permiten almacenar datos de gran tamaño. Cuando se trabajan con estos datos, generalmente se obtienen "localizadores" que permiten cargar el objeto en fragmentos, lo cual es más eficiente que cargarlo entero en memoria.

### Tipos Definidos por los Usuarios

SQL permite crear tipos personalizados para asegurar la integridad de los datos. Por ejemplo, podemos definir tipos para representar diferentes monedas:

```sql
CREATE TYPE Euros AS NUMERIC(12,2) FINAL;
CREATE TYPE Libras AS NUMERIC(12,2) FINAL;
```

Estos tipos ayudan a prevenir errores. Si tenemos una columna `presupuesto` de tipo `Euros`, no será posible asignarle un valor de tipo `Libras` sin realizar una conversión explícita, lo que reduce la posibilidad de errores.

```sql
CREATE TABLE departamento (
    nombre_dept VARCHAR(20),
    edificio VARCHAR(15),
    presupuesto Euros
);
```

Si se necesita realizar una operación con estos tipos, podemos convertir explícitamente el tipo de datos usando `CAST`:

```sql
CAST(departamento.presupuesto AS NUMERIC(12,2))
```

Esto permite realizar operaciones aritméticas al convertir a un tipo común, y luego volver a convertir al tipo específico si es necesario.

### Extensiones a la creación de tablas

**1. Crear una tabla a partir de otra existente**

La sentencia `CREATE TABLE ... LIKE` se utiliza para crear una nueva tabla que tiene el mismo esquema (estructura de columnas y tipos de datos) que una tabla existente. Por ejemplo:

```sql
CREATE TABLE temp_profesor LIKE profesor;
```

En este caso, `temp_profesor` se crea con la misma estructura que la tabla `profesor`, pero sin ningún dato.

**2. Crear una tabla a partir de una consulta**

La sentencia `CREATE TABLE ... AS` permite crear una nueva tabla y llenarla con los resultados de una consulta. Por ejemplo:

```sql
CREATE TABLE t1 AS
SELECT * FROM profesor WHERE nombre_dept = 'Música' WITH DATA;
```

En este caso, `t1` se crea y se llena con todas las filas de la tabla `profesor` donde la columna `nombre_dept` tiene el valor 'Música'. La cláusula `WITH DATA` indica que la tabla se rellena con los resultados de la consulta. Si omites `WITH DATA`, según la norma SQL:2003, la tabla se crea vacía:

```sql
CREATE TABLE t2 AS
SELECT * FROM profesor WHERE nombre_dept = 'Música';
```

### Diferencias entre tablas y vistas

La creación de tablas usando `CREATE TABLE ... AS` es similar a la creación de vistas (`CREATE VIEW`). La diferencia principal es que los datos en una tabla son copiados en el momento de la creación, mientras que una vista siempre refleja los resultados actualizados de la consulta que la define. Por ejemplo:

```sql
CREATE VIEW vista_profesores AS
SELECT * FROM profesor WHERE nombre_dept = 'Música';
```

Aquí, `vista_profesores` siempre mostrará los datos actuales de la tabla `profesor` donde `nombre_dept` es 'Música', pero no almacena esos datos de forma física como lo hace `t1`.

### Esquemas, catálogos y entornos

**1. Jerarquía en la base de datos**

Los sistemas de bases de datos modernos utilizan una jerarquía de nombres para organizar las relaciones. Esta jerarquía incluye catálogos y esquemas. Piensa en los catálogos como carpetas que pueden contener varios esquemas (subcarpetas), y cada esquema puede contener tablas y vistas.

- **Catálogo**: Un conjunto de esquemas.
- **Esquema**: Un conjunto de objetos de base de datos (tablas, vistas, etc.).

Por ejemplo, el nombre completo de una tabla podría ser:

```
catalogo5.univ_esquema.asignatura
```

En este caso:
- `catalogo5` es el catálogo.
- `univ_esquema` es el esquema.
- `asignatura` es la tabla.

**2. Conexiones y esquemas predeterminados**

Cuando un usuario se conecta a una base de datos, se establece un catálogo y un esquema predeterminados para esa sesión. Esto es similar a establecer un directorio de inicio en un sistema operativo. El usuario puede referirse a las tablas simplemente por su nombre si están en su esquema predeterminado:

```sql
SELECT * FROM asignatura;
```

Si `asignatura` se encuentra en un esquema diferente, deberás especificar el esquema:

```sql
SELECT * FROM otro_esquema.asignatura;
```

**3. Creación y eliminación de esquemas**

Los esquemas pueden ser creados y eliminados utilizando las sentencias `CREATE SCHEMA` y `DROP SCHEMA`. Por ejemplo:

```sql
CREATE SCHEMA nuevo_esquema;
DROP SCHEMA viejo_esquema;
```

En la mayoría de los sistemas de bases de datos, un esquema se crea automáticamente cuando se crea un nuevo usuario, y su nombre es igual al del usuario.

### Resumen

La creación de tablas en SQL se puede realizar de manera efectiva utilizando `CREATE TABLE ... LIKE` y `CREATE TABLE ... AS`. La jerarquía de catálogos y esquemas permite una mejor organización y gestión de los objetos dentro de la base de datos, evitando conflictos de nombres y facilitando el manejo de los datos.

Si necesitas más detalles o ejemplos específicos, no dudes en preguntar.

# Autorización
La sección sobre **Autorización** en bases de datos aborda cómo se gestionan los privilegios de acceso de los usuarios a los datos y esquemas dentro de una base de datos. A continuación, se explica cada punto, con ejemplos para una mejor comprensión.


La autorización en bases de datos implica asignar diferentes tipos de permisos a los usuarios sobre las partes de la base de datos. Estos permisos se conocen como **privilegios** y se clasifican principalmente en cuatro tipos:

1. **Autorización de lectura de datos** (SELECT)
2. **Autorización de inserción de nuevos datos** (INSERT)
3. **Autorización de actualización de datos** (UPDATE)
4. **Autorización de borrado de datos** (DELETE)

#### Ejemplo de Privilegios

Supongamos que tenemos una base de datos de una universidad con una tabla llamada `estudiantes`. Los privilegios pueden ser asignados de la siguiente manera:

- **Lectura**: Un usuario llamado `profesor1` puede consultar datos de la tabla `estudiantes`:
    ```sql
    GRANT SELECT ON estudiantes TO profesor1;
    ```

- **Inserción**: Un usuario llamado `secretaria` puede agregar nuevos registros a la tabla:
    ```sql
    GRANT INSERT ON estudiantes TO secretaria;
    ```

- **Actualización**: Un usuario llamado `profesor2` puede actualizar el correo electrónico de los estudiantes:
    ```sql
    GRANT UPDATE (email) ON estudiantes TO profesor2;
    ```

- **Borrado**: Un usuario llamado `admin` puede eliminar registros de la tabla:
    ```sql
    GRANT DELETE ON estudiantes TO admin;
    ```

### Concesión y Revocación de Privilegios

Los privilegios se conceden utilizando la sentencia `GRANT` y se revocan utilizando la sentencia `REVOKE`. Por ejemplo:

- Para conceder múltiples privilegios a un usuario:
    ```sql
    GRANT SELECT, INSERT, UPDATE ON estudiantes TO profesor1;
    ```

- Para revocar un privilegio:
    ```sql
    REVOKE UPDATE ON estudiantes FROM profesor2;
    ```

### Roles

Los **roles** son grupos de privilegios que se pueden asignar a usuarios. Esto es útil cuando varios usuarios requieren los mismos permisos. Por ejemplo, en una universidad, podríamos tener roles como `profesor`, `estudiante`, o `administrador`.

- **Creación de un rol**:
    ```sql
    CREATE ROLE profesor;
    ```

- **Concesión de privilegios al rol**:
    ```sql
    GRANT SELECT ON estudiantes TO profesor;
    ```

- **Asignación de roles a usuarios**:
    ```sql
    GRANT profesor TO profesor1;
    ```

Cuando un usuario se conecta a la base de datos, tiene todos los privilegios que se le han concedido directamente, así como los que hereda de cualquier rol que se le haya asignado.

### Autorización sobre Vistas

Las **vistas** son tablas virtuales que representan resultados de consultas. Permiten a los usuarios acceder a un subconjunto de datos sin otorgar acceso directo a la tabla original.

- **Creación de una vista**:
    ```sql
    CREATE VIEW estudiantes_geologia AS
    SELECT * FROM estudiantes WHERE departamento = 'Geología';
    ```

- Un usuario puede consultar la vista sin tener acceso a la tabla original:
    ```sql
    SELECT * FROM estudiantes_geologia;
    ```

### Autorizaciones sobre Esquemas

Los esquemas son contenedores que agrupan objetos de base de datos, como tablas y vistas. Solo el propietario del esquema puede modificarlo. Sin embargo, ciertos privilegios pueden ser concedidos para permitir que otros usuarios realicen tareas específicas, como declarar claves externas.

- **Concesión de privilegios de referencia**:
    ```sql
    GRANT REFERENCES (nombre_dept) ON departamento TO mariano;
    ```

### Resumen

El sistema de autorización en bases de datos es fundamental para garantizar la seguridad y el control de acceso. Permite a los administradores asignar permisos específicos a usuarios y roles, lo que ayuda a gestionar quién puede ver, modificar o eliminar datos. La implementación de roles simplifica la administración de permisos, y el uso de vistas proporciona una forma segura de exponer datos sin comprometer la integridad de la base de datos.
