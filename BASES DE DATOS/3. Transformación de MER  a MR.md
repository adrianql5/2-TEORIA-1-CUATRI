[[../Archivos/bibliografia/bases_datos.pdf|bases_datos.pdf#page=147]]

[[3.1 Casos Transformación MER a MR]]

Escrito por **Adrián Quiroga Linares**.

# 3.1 Introducción
Por una parte, tenemos el Modelo Entidad-Relación que, como hemos visto, resulta muy útil para expresar los conceptos del mundo real que queremos incorporar en la Base de Datos sin necesidad de tener que pensar en qué Gestor de Bases de Datos vamos a utilizar en el desarrollo del proyecto. Por otra parte, **los Gestores de Bases de Datos más habituales implementan el Modelo Relacional**.

Aunque se pueden desarrollar Bases de Datos en cualquiera de los dos modelos, conforme el tamaño del modelo va creciendo las ventajas de usar **Modelo Entidad-Relación** se vuelven más evidentes: El modelo es más **entendible visualmente** y, además, resulta sencillo aplicar estrategias del tipo **“divide y vencerás”** para resolver partes del modelo y unirlas en una etapa final de integración.

En este tema vamos a ver cómo obtener un Modelo Relacional válido a partir de un Modelo Entidad-Relación correcto. Si el Modelo Entidad-Relación es correcto, la aplicación estricta de las normas que estudiaremos en este tema generaran un Modelo Relacional correcto. Siempre. Correcto, **pero no necesariamente óptimo**.


# 3.2 Transformación a Modelo Relacional del Modelo Entidad Relación Básico
La transformación del modelo Entidad-Relación (ER) al modelo relacional se realiza para poder implementar el diseño conceptual de una base de datos en un sistema de gestión de bases de datos (DBMS) relacional. Esto implica convertir las entidades, relaciones y atributos de un diagrama ER en esquemas de relaciones o tablas, que representan las estructuras de almacenamiento de datos en el DBMS.

### 3.2.1 Representación de los Conjuntos de Entidades Fuertes con Atributos Simples
Las **entidades fuertes** son aquellas que tienen una clave primaria propia, y sus atributos **simples** no pueden descomponerse en atributos más pequeños.

#### Proceso:
1. **Entidad fuerte con atributos simples**: Se crea un esquema de relación con el mismo nombre que la entidad.
2. **Atributos**: Cada atributo simple de la entidad se convierte en una columna del esquema de relación.
3. **Clave primaria**: La clave primaria de la entidad se convierte en la clave primaria de la tabla.

**Ejemplo**:
- Supongamos una entidad `Estudiante` con los atributos `ID`, `Nombre` y `Tot_cred`.
- Esquema relacional resultante: `Estudiante(ID, Nombre, Tot_cred)`.
  - Aquí, `ID` es la clave primaria de la tabla `Estudiante`.

### 3.2.2 Representación de los Conjuntos de Entidades Fuertes con Atributos Complejos
En este caso, tenemos atributos **compuestos** o **multivalorados**.

- **Atributos compuestos**: Estos atributos pueden descomponerse en varios atributos simples. En el esquema relacional, cada componente del atributo compuesto se representa como una columna independiente.
- **Atributos multivalorados**: Un atributo que puede tener múltiples valores para una entidad dada genera un nuevo esquema de relación que almacena estos valores en filas separadas.

**Ejemplo de atributo compuesto**:
- Entidad `Profesor` con atributos `ID`, `Nombre` (compuesto por `Nombre` y `Apellido`), y `Dirección` (compuesto por `Calle`, `Ciudad`, `Código_Postal`).
- Esquema relacional: `Profesor(ID, Nombre, Apellido, Calle, Ciudad, Código_Postal)`.

**Ejemplo de atributo multivalorado**:
- Supongamos que `Profesor` tiene un atributo `Teléfono` que es multivalorado.
- Esquema relacional resultante para `Teléfono`: `Profesor_Teléfono(ID, Teléfono)`, donde `ID` es clave externa que referencia al `ID` en la tabla `Profesor`.

Cada número de teléfono se guarda en una fila distinta:
```
Profesor_Teléfono
-----------------
ID   | Teléfono
-----------------
2222 | 555-1234
2222 | 555-4321
```

### 3.2.3 Representación de los Conjuntos de Entidades Débiles
Las **entidades débiles** no pueden existir sin depender de una **entidad fuerte**. Estas entidades no tienen una clave primaria propia, sino que dependen de la clave primaria de la entidad fuerte y un **discriminador**.

#### Proceso:
1. **Combinar clave primaria de la entidad fuerte y discriminador**: La clave primaria de la entidad débil es la combinación de la clave de la entidad fuerte y el discriminador.
2. **Clave externa**: Se establece una clave externa que garantiza la relación entre la entidad débil y la fuerte.

**Ejemplo**:
- Supongamos que tenemos `Asignatura` como entidad fuerte (con clave `Asignatura_ID`) y `Sección` como entidad débil que depende de `Asignatura` y tiene atributos `Secc_ID`, `Semestre`, y `Año`.
- Esquema relacional resultante: `Seccion(Asignatura_ID, Secc_ID, Semestre, Año)`.
  - Clave primaria: `Asignatura_ID, Secc_ID`.
  - `Asignatura_ID` también actúa como clave externa, que referencia la tabla `Asignatura`.

### 3.2.4 Representación de Conjuntos de Relaciones
Al transformar un conjunto de relaciones del modelo ER, se crea un esquema de relación que contiene las claves primarias de las entidades que participan en la relación.

#### Esquemas de Relaciones Binarias
1. **Relaciones muchos a muchos**: Se crea una tabla con las claves primarias de ambas entidades, y la combinación de ambas claves actúa como clave primaria.

   **Ejemplo**: Una relación `Tutor` entre `Profesor` y `Estudiante` donde un profesor puede tutorizar varios estudiantes y un estudiante puede tener varios tutores.
   - Esquema resultante: `Tutor(Profesor_ID, Estudiante_ID)`.

2. **Relaciones uno a uno**: Se puede almacenar en cualquiera de las dos tablas involucradas, ya que solo una tupla en una tabla se asocia con una tupla en la otra.

3. **Relaciones uno a varios**: La clave primaria del lado "muchos" se convierte en clave primaria en el esquema de la relación.

#### Esquemas de Relaciones N-arias
Para relaciones que involucran más de dos entidades, se toma la unión de las claves primarias de todas las entidades participantes para formar la clave primaria de la tabla.

**Ejemplo**: Una relación `Tutor_Asignatura` entre `Profesor`, `Estudiante`, y `Asignatura`.
- Esquema resultante: `Tutor_Asignatura(Profesor_ID, Estudiante_ID, Asignatura_ID)`.

#### Claves Externas
Para cada entidad que participa en la relación, se debe incluir una clave externa en el esquema que referencia su clave primaria. Esto asegura la integridad referencial entre las entidades involucradas.

**Ejemplo** de una relación `Tutor`:
```sql
CREATE TABLE Tutor (
    Profesor_ID INT,
    Estudiante_ID INT,
    FOREIGN KEY (Profesor_ID) REFERENCES Profesor(ID),
    FOREIGN KEY (Estudiante_ID) REFERENCES Estudiante(ID),
    PRIMARY KEY (Profesor_ID, Estudiante_ID)
);
```

### Redundancia de Esquemas y Combinación de Esquemas
Cuando una entidad débil depende de una entidad fuerte, no siempre es necesario crear un esquema de relación adicional, ya que la dependencia entre ambas entidades está implícita. 

1. **Relaciones varios a uno**: Pueden combinarse en el esquema de la entidad que se relaciona con "varios".
   
   **Ejemplo**: En la relación `Profesor_Dept` donde cada profesor pertenece a un solo departamento:
   ```sql
   Profesor(ID, Nombre, Dept_ID, Sueldo)
   ```
   
2. **Relaciones uno a uno**: El esquema de la relación puede combinarse con cualquiera de las dos entidades.

Usando estas técnicas, se obtiene una estructura de base de datos relacional bien definida, con tablas que preservan la información y relaciones del modelo ER inicial, asegurando integridad y consistencia en los datos.


---

![[Archivos/imagenes/Pasted image 20241003132123.png]]



# 3.3 Transformación a Modelo Relacional del Modelo Entidad-Relación Avanzado
Para explicar mejor la **transformación del Modelo Entidad-Relación Avanzado al Modelo Relacional**, vamos a detallar cada caso de jerarquía: **total y solapada**, **parcial y solapada**, **total y disjunta**, y **parcial y disjunta**. También corregiré cualquier error conceptual y organizaré la explicación de forma clara y secuencial, con ejemplos detallados.

---

## 3.3 Transformación a Modelo Relacional del Modelo Entidad-Relación Avanzado

### 3.3.1 Jerarquía Total y Solapada
En una **jerarquía total y solapada**, todos los elementos de la jerarquía deben pertenecer al menos a una subclase, y cada elemento puede pertenecer a más de una subclase.

**Método**:
1. Se crea **una sola tabla** que incluye todos los atributos de la superclase y subclases.
2. Se añaden **discriminantes binarios** (uno por cada subclase) para indicar a qué subclases pertenece cada elemento.
3. La **clave primaria (PK)** de esta tabla es la clave de la superclase.

**Ventaja**:
- Simplifica la estructura al mantener todos los elementos en una única tabla.

**Desventaja**:
- Puede provocar **redundancia** si existen muchos atributos específicos en las subclases, ya que estos se agregarán a todas las filas.

**Ejemplo**:

Supongamos una jerarquía `Vehículo` (superclase) con subclases `Coche`, `Barco` y `Avión`. Un vehículo puede ser tanto un coche como un barco, o tener más de una categoría al mismo tiempo.

- **Atributos de la superclase** `Vehículo`: `ID`, `marca`, `modelo`.
- **Atributos específicos** de las subclases:
  - `Coche`: `número_puertas`
  - `Barco`: `capacidad_toneladas`
  - `Avión`: `alcance_km`

**Tabla `Vehículo`**:

| ID  | marca | modelo | número_puertas | capacidad_toneladas | alcance_km | es_coche | es_barco | es_avion |
| --- | ----- | ------ | -------------- | ------------------- | ---------- | -------- | -------- | -------- |
| 001 | Tesla | X      | 4              | NULL               | NULL       | 1        | 0        | 0        |
| 002 | BMW   | Nautic | NULL           | 20                 | 1000       | 0        | 1        | 1        |

- Cada fila contiene atributos de la superclase y de las subclases, y los **discriminantes** (`es_coche`, `es_barco`, `es_avion`) indican a qué subclases pertenece cada vehículo.

---

### 3.3.2 Jerarquía Parcial y Solapada
En una **jerarquía parcial y solapada**, algunos elementos pueden no pertenecer a ninguna subclase, pero los que sí pertenecen pueden estar en más de una subclase.

**Método**:
1. Se crea una **tabla para la superclase** con sus atributos generales.
2. Se crea una **tabla separada para cada subclase**, que contiene la clave de la superclase y los atributos específicos de la subclase.
3. Se añaden **discriminantes binarios** en cada tabla de subclase para indicar a qué subclases pertenece cada elemento.

**Clave primaria**:
- La **clave primaria (PK)** de la tabla de la superclase es única, y se utiliza como clave foránea (FK) en las tablas de subclase.

**Ventaja**:
- Mantiene la jerarquía clara y permite flexibilidad para los elementos que no pertenecen a ninguna subclase.

**Desventaja**:
- Aumenta el número de **uniones (joins)** necesarias en consultas que combinan atributos de varias tablas.

**Ejemplo**:

Utilizando la jerarquía `Vehículo` con las subclases `Coche`, `Barco` y `Avión`, algunos vehículos pueden no estar en ninguna subclase, mientras que otros pueden estar en más de una.

**Tabla `Vehículo` (superclase):**

| ID  | marca  | modelo |
| --- | ------ | ------ |
| 001 | Tesla  | X      |
| 002 | BMW    | Nautic |
| 003 | Toyota | EcoCar |

**Tabla `Coche` (subclase):**

| ID  | número_puertas | es_coche |
| --- | -------------- | -------- |
| 001 | 4              | 1        |
| 003 | 2              | 1        |

**Tabla `Barco` (subclase):**

| ID  | capacidad_toneladas | es_barco |
| --- | ------------------- | -------- |
| 002 | 20                  | 1        |

Aquí, la clave primaria `ID` de la tabla `Vehículo` es una clave foránea en las tablas `Coche` y `Barco`. Los discriminantes (`es_coche`, `es_barco`) indican si el vehículo pertenece a la subclase.

---

### 3.3.3 Jerarquía Total y Disjunta
En una **jerarquía total y disjunta**, cada elemento debe estar en una subclase, y cada elemento solo puede pertenecer a una subclase.

**Método**:
1. Se crea una **tabla por cada subclase**, que incluye todos los atributos de la superclase y los específicos de la subclase.

**Clave primaria**:
- La **clave primaria (PK)** es la clave de la superclase en cada tabla de subclase.

**Ventaja**:
- No necesita uniones para consultas, ya que cada elemento está en una única tabla.

**Desventaja**:
- Genera **redundancia** al duplicar los atributos de la superclase en todas las tablas de subclase.

**Ejemplo**:

Consideremos `Empleado` como superclase, y `Gerente` e `Ingeniero` como subclases. Cada empleado debe pertenecer a una de estas subclases, pero no a ambas.

**Tabla `Gerente`:**

| ID  | nombre | sueldo | departamento |
| --- | ------ | ------ | ------------ |
| 001 | Alice  | 9000   | Ventas       |

**Tabla `Ingeniero`:**

| ID  | nombre | sueldo | especialidad |
| --- | ------ | ------ | ------------ |
| 002 | Bob    | 8000   | Software     |

Cada tabla incluye los atributos generales de `Empleado` y los específicos de la subclase.

---

### 3.3.4 Jerarquía Parcial y Disjunta
En una **jerarquía parcial y disjunta**, algunos elementos pueden no estar en ninguna subclase, y cada elemento solo puede pertenecer a una subclase.

**Método**:
1. Se crea una **tabla para la superclase** con sus atributos generales.
2. Se crea una **tabla para cada subclase** con sus atributos específicos y la clave primaria de la superclase como clave foránea (FK).

**Clave primaria**:
- La **clave primaria (PK)** es la clave de la superclase en la tabla principal y una clave foránea en las tablas de subclase.

**Ventaja**:
- Permite flexibilidad al representar elementos que no pertenecen a ninguna subclase.

**Desventaja**:
- Requiere **uniones (joins)** para obtener todos los atributos de un elemento si pertenece a una subclase.

**Ejemplo**:

De nuevo, usaremos `Empleado` como superclase y `Gerente` e `Ingeniero` como subclases. No todos los empleados tienen que ser gerentes o ingenieros.

**Tabla `Empleado` (superclase):**

| ID  | nombre  | sueldo |
| --- | ------- | ------ |
| 001 | Alice   | 9000   |
| 002 | Bob     | 8000   |
| 003 | Charlie | 7000   |

**Tabla `Gerente` (subclase):**

| ID  | departamento |
| --- | ------------ |
| 001 | Ventas       |

**Tabla `Ingeniero` (subclase):**

| ID  | especialidad |
| --- | ------------ |
| 002 | Software     |

En este caso, `Charlie` (ID 003) no pertenece a ninguna subclase, pero sigue existiendo en la tabla de `Empleado`.

---
---

>[!TIP]
>Solapada -> incluir discriminadores binarios
>Parcial-> incluir una tabla para la superclase
>Total-> no hay tabla para la superclase
>Disjunta->no hay discriminadores binarios




![[Archivos/imagenes/Pasted image 20241003140849.png]]

# Ejemplo
![[Archivos/imagenes/Pasted image 20241010125608.png]]
![[Archivos/imagenes/Pasted image 20241010125636.png]]


---











