[[Archivos/bibliografia/bases_datos.pdf|bases_datos]]

SQL (Structured Query Language) es el lenguaje de consulta de bases de datos más ampliamente utilizado en los gestores de bases de datos, tanto de software libre como comerciales. Aunque se le suele llamar lenguaje de consulta, también tiene instrucciones para:

- **Crear, modificar y eliminar tablas.**
- **Insertar, modificar y eliminar tuplas de las tablas.**
- **Definir restricciones de integridad de entidad y de integridad referencial.**

# Introducción al lenguaje de consultas SQL
Tiene varios componentes:
- **Lenguaje de definición de datos (LDD).** El LDD de SQL proporciona comandos para la definición de esquemas de relación, borrado de relaciones y modificación de los esquemas de relación
- **Lenguaje interactivo de manipulación de datos (LMD).** El LMD de SQL incluye un lenguaje de consultas como comandos para insertar, borrar y modificar tuplas en la base de datos
- **Integridad.** El LDD de SQL incluye comandos para especificar las restricciones de integridad que deben cumplir los datos almacenados en la base de datos. Las acutalizaciones que violan las restricciones de integridad se borran.
- **Definicion de vistas**. El LDD de SQL incluye comandos para la definición de vistas.
- **Control de transacciones**. SQL incluye comandos para especificar el comienzo y el final de las transacciones.
- **SQL incorporado y SQL dinámico**. SQL incorporado y SQL dinámico definen cómo se pueden incorporar instrucciones de SQL en lenguajes de programación de propósito general como `C`,`C++`y `Java`.
- **Autortización**. EL LDD de SQL incluye comandos pra especificar los derechos de acceso a las relaciones y a las vistas.


# Definición de datos de SQL
El conjunto de relaciones de una base de datos se especifica en el sistema mediante un lenguaje de definición de datos (LDD). El LDD de SQL permite no solo definir las relaciones, sino también la información asociada a ellas, que incluye:

- El esquema de cada relación.
- El dominio de valores para cada atributo.
- Las restricciones de integridad.
- Los índices a mantener para cada relación.
- La información de seguridad y autorización.
- La estructura de almacenamiento físico en disco de cada relación.

## Tipos Básicos
La norma SQL soporta una variedad de tipos de dominio predefinidos, incluyendo:

- **char(n)**: Cadena de caracteres de longitud fija, donde \( n \) es especificado por el usuario. También se puede utilizar **character**.
  
- **varchar(n)**: Cadena de caracteres de longitud variable, con una longitud máxima de \( n \) especificada por el usuario. La forma completa **character varying** es equivalente.

- **int**: Número entero, un subconjunto finito de los enteros dependiente de la máquina. **integer** es equivalente.

- **smallint**: Entero pequeño, un subconjunto dependiente de la máquina del tipo de dominio entero.

- **numeric(p, d)**: Número de coma fija con precisión especificada por el usuario. Se compone de \( p \) dígitos (más el signo), de los cuales \( d \) pertenecen a la parte decimal. Por ejemplo, **numeric(3,1)** puede almacenar 44.5, pero no 444.5 ni 0.32.

- **real, double precision**: Números de coma flotante, con precisión dependiente de la máquina.

- **float(n)**: Número de coma flotante cuya precisión es, al menos, de \( n \) dígitos.

Todos los tipos incluyen un valor especial llamado **valor null** (nulo), que indica la ausencia de un valor.

#### Comparaciones entre `char` y `varchar`

- **char**: Almacena una cadena de longitud fija. Si se guarda "Avi" en un atributo **char(10)**, se añaden 7 espacios para alcanzar los 10 caracteres.

- **varchar**: Almacena una cadena de longitud variable. Si se guarda "Avi" en un atributo **varchar(10)**, no se añaden espacios extra.

Al comparar valores de tipo **char**, si tienen distinto tamaño, se añaden espacios al más pequeño antes de la comparación. Comparar **char** con **varchar** puede resultar en inconsistencias, por lo que se recomienda usar **varchar** para evitar estos problemas.

Además, SQL proporciona el tipo **nvarchar** para almacenar datos en varios idiomas utilizando la representación Unicode. Muchas bases de datos también permiten almacenar Unicode en tipos **varchar** (en representación UTF-8).


## Definición de tablas en SQL

#### Ejemplo de creación de la tabla `departamento`

```sql
CREATE TABLE departamento (
    nombre_dept VARCHAR(20),
    edificio VARCHAR(15),
    presupuesto NUMERIC(12,2),
    PRIMARY KEY (nombre_dept)
);
```

- **Atributos**:
  - `nombre_dept`: cadena de caracteres de un tamaño máximo de 20.
  - `edificio`: cadena de caracteres de un tamaño máximo de 15.
  - `presupuesto`: número con un total de 12 dígitos, de los cuales 2 están tras el punto decimal.
  
- **Clave primaria**: `nombre_dept` es la clave primaria de la relación `departamento`.

#### Forma general del comando `CREATE TABLE`

```sql
CREATE TABLE r (
    A1 D1,
    A2 D2,
    …,
    An Dn,
    <restricción-integridad 1>,
    …,
    <restricción-integridad k>
);
```

- **Descripción**:
  - `r`: nombre de la relación.
  - `A_i`: nombre de los atributos del esquema.
  - `D_i`: dominio del atributo \(A_i\) (tipo y restricciones de integridad).

- **Punto y coma**: Opcional en la mayoría de las implementaciones de SQL.

#### Restricciones de integridad

1. **PRIMARY KEY $(A_j1, A_j2, …, A_jm)$**:
   - Los atributos forman la clave primaria de la relación.
   - Los atributos deben ser no nulos y únicos.

2. **FOREIGN KEY $(A_k1, A_k2, …, A_kn)$ REFERENCES s**:
   - Indica que los valores de los atributos deben corresponder con los de la clave primaria de otra relación.
   - Ejemplo: En la tabla `asignatura`, `foreign key (nombre_dept) references departamento`.

3. **NOT NULL**:
   - Indica que no se permite el valor nulo para ese atributo.
   - Ejemplo: En `profesor`, `nombre` tiene la restricción `not null`.

#### Ejemplos de creación de tablas

```sql
CREATE TABLE asignatura (
    asignatura_id VARCHAR(7),
    nombre VARCHAR(50),
    nombre_dept VARCHAR(20),
    créditos NUMERIC(2,0),
    PRIMARY KEY (asignatura_id),
    FOREIGN KEY (nombre_dept) REFERENCES departamento
);

CREATE TABLE profesor (
    ID VARCHAR(5),
    nombre VARCHAR(20) NOT NULL,
    nombre_dept VARCHAR(20),
    sueldo NUMERIC(8,2),
    PRIMARY KEY (ID),
    FOREIGN KEY (nombre_dept) REFERENCES departamento
);

CREATE TABLE sección (
    asignatura_id VARCHAR(8),
    secc_id VARCHAR(8),
    semestre VARCHAR(6),
    año NUMERIC(4,0),
    edificio VARCHAR(15),
    número_aula VARCHAR(7),
    franja_horaria_id VARCHAR(4),
    PRIMARY KEY (asignatura_id, secc_id, semestre, año),
    FOREIGN KEY (asignatura_id) REFERENCES asignatura
);

CREATE TABLE enseña (
    ID VARCHAR(5),
    asignatura_id VARCHAR(8),
    secc_id VARCHAR(8),
    semestre VARCHAR(6),
    año NUMERIC(4,0),
    PRIMARY KEY (ID, asignatura_id, secc_id, semestre, año),
    FOREIGN KEY (asignatura_id, secc_id, semestre, año) REFERENCES sección,
    FOREIGN KEY (ID) REFERENCES profesor
);
```

### Restricciones de integridad en actualizaciones e inserciones

1. **Actualizaciones**:
   - SQL evita que cualquier actualización viole las restricciones de integridad de las claves primarias.
   - Si se intenta actualizar una tupla de manera que los valores en la clave primaria sean los mismos que otra tupla existente, SQL arrojará un error y evitará la actualización.

2. **Inserciones**:
   - Si se intenta insertar una tupla en una relación que contenga un valor de clave externa que no corresponda a una tupla existente en la relación referenciada, SQL también generará un error.
   - Ejemplo de inserción en la tabla `profesor`:

   ```sql
   INSERT INTO profesor VALUES (10211, 'Smith', 'Biología', 66000);
   ```

### Comandos importantes en SQL

1. **Insertar datos**: Se utiliza el comando `INSERT` para añadir tuplas a una relación.
   - Los valores deben proporcionarse en el mismo orden que los atributos en el esquema de la relación.

   Ejemplo:
   
   ```sql
   INSERT INTO profesor VALUES (10211, 'Smith', 'Biología', 66000);
   ```

2. **Eliminar tuplas**: El comando `DELETE` elimina tuplas de una relación.
   - Elimina todas las tuplas:
   
   ```sql
   DELETE FROM estudiante;
   ```

   - También es posible eliminar tuplas específicas (esto se detalla más adelante).

3. **Eliminar relaciones**:
   - `DROP TABLE` elimina tanto las tuplas como el esquema de la relación. 
   - Ejemplo:

   ```sql
   DROP TABLE r;
   ```

   - En cambio, el comando `DELETE FROM r` solo elimina las tuplas, pero no la estructura de la tabla.

4. **Modificar la estructura de tablas**:
   - **Añadir atributos**: Se utiliza el comando `ALTER TABLE` para añadir atributos a una relación existente.
   
     Ejemplo:
     ```sql
     ALTER TABLE r ADD A D;
     ```

     Esto añadirá el atributo `A` del tipo `D` a la relación `r`. Todas las tuplas existentes tendrán el valor `NULL` en el nuevo atributo.

   - **Eliminar atributos**:
     - El comando para eliminar atributos es:

     ```sql
     ALTER TABLE r DROP A;
     ```

     Sin embargo, no todos los sistemas de bases de datos permiten eliminar atributos.


# Modificación de la base de datos.

## Borrado

El comando `DELETE` se utiliza para eliminar tuplas completas de una relación en una base de datos. No es posible eliminar valores de atributos específicos sin eliminar toda la tupla.

#### Sintaxis básica:

```sql
DELETE FROM r WHERE P;
```

- `r` es el nombre de la relación (tabla).
- `P` es un predicado que define las condiciones bajo las cuales se eliminarán las tuplas.
- Si se omite la cláusula `WHERE`, se eliminan todas las tuplas de la relación.

#### Ejemplos de borrado:

1. **Eliminar todas las tuplas de una relación:**

   ```sql
   DELETE FROM profesor;
   ```

   Este comando eliminará todas las tuplas de la tabla `profesor`, pero la estructura de la tabla seguirá existiendo.

2. **Eliminar tuplas con una condición específica:**

   - Borrar todos los profesores que pertenecen al departamento de Finanzas:

     ```sql
     DELETE FROM profesor WHERE nombre_dept = 'Finanzas';
     ```

   - Borrar todos los profesores con un sueldo entre 13.000 € y 15.000 €:

     ```sql
     DELETE FROM profesor WHERE sueldo BETWEEN 13000 AND 15000;
     ```

   - Borrar todos los profesores asociados con un departamento ubicado en el edificio Watson:

     ```sql
     DELETE FROM profesor WHERE nombre_dept IN (
         SELECT nombre_dept FROM departamento WHERE edificio = 'Watson'
     );
     ```

     Este comando primero selecciona todos los departamentos que están en el edificio `Watson`, y luego elimina a los profesores asociados con esos departamentos.

#### Anidación de `SELECT` en `DELETE`

Se pueden utilizar consultas anidadas en la cláusula `WHERE` de un comando `DELETE`. Esto permite eliminar tuplas basadas en los resultados de una subconsulta.

Por ejemplo:

- Borrar todos los profesores cuyo sueldo sea inferior a la media:

  ```sql
  DELETE FROM profesor WHERE sueldo < (
      SELECT AVG(sueldo) FROM profesor
  );
  ```

  Este comando calcula el sueldo medio de los profesores y luego elimina a aquellos cuyo sueldo esté por debajo de esa media.

#### Consideraciones importantes:

- **Orden de eliminación**: Si se están eliminando tuplas basadas en un cálculo, es importante que todas las comprobaciones se realicen antes de que empiecen los borrados. De lo contrario, los resultados pueden cambiar dependiendo del orden en el que se procesen las tuplas, afectando a consultas como la de calcular el sueldo medio.

## Inserción
### Comando `INSERT` en SQL

El comando `INSERT` permite insertar tuplas en una tabla, ya sea especificando los valores directamente o utilizando una consulta para seleccionar el conjunto de tuplas que se insertarán.

#### Sintaxis básica:

1. **Insertar una tupla con valores en el orden de los atributos:**

   ```sql
   INSERT INTO asignatura VALUES ('CS-437', 'Bases de datos', 'Informática', 4);
   ```

2. **Insertar una tupla especificando los atributos:**

   ```sql
   INSERT INTO asignatura (asignatura_id, nombre, nombre_dept, créditos) 
   VALUES ('CS-437', 'Bases de datos', 'Informática', 4);
   ```

   Este formato es útil cuando el usuario no recuerda el orden de los atributos o si se desea omitir ciertos atributos, ya que se pueden listar solo los necesarios.

3. **Insertar una tupla en un orden diferente al de los atributos en la tabla:**

   ```sql
   INSERT INTO asignatura (nombre, asignatura_id, créditos, nombre_dept) 
   VALUES ('Bases de datos', 'CS-437', 4, 'Informática');
   ```

#### Insertar con una consulta `SELECT`

Se pueden insertar tuplas que son resultado de una consulta. Por ejemplo, si se desea convertir a estudiantes en profesores del departamento de Música, con un sueldo de 18.000 €, y que tengan más de 144 créditos:

```sql
INSERT INTO profesor
SELECT ID, nombre, nombre_dept, 18000
FROM estudiante
WHERE nombre_dept = 'Música' AND tot_cred > 144;
```

Este comando evalúa primero la consulta `SELECT`, que devuelve las tuplas que cumplen con los criterios, y luego inserta esas tuplas en la tabla `profesor`.

#### Ejemplo de inserción incompleta

Es posible insertar valores en solo algunos atributos y dejar los demás como `NULL`. Por ejemplo:

```sql
INSERT INTO estudiante (ID, nombre, nombre_dept, tot_créditos) 
VALUES ('3003', 'Green', 'Finanzas', NULL);
```

Esta instrucción crea una tupla en la tabla `estudiante` donde el valor de `tot_créditos` es desconocido (`NULL`).

#### Evitar inserciones infinitas

Si se intenta ejecutar una consulta que se inserta a sí misma sin control, puede ocurrir un ciclo infinito. Por ejemplo:

```sql
INSERT INTO estudiante SELECT * FROM estudiante;
```

Si la tabla `estudiante` no tiene restricciones de clave primaria, este comando podría crear infinitas copias de las tuplas, ya que cada nueva tupla insertada es también seleccionada. Por esta razón, SQL evalúa completamente las consultas antes de realizar las inserciones.

#### Carga masiva de datos

Para grandes cantidades de datos, las bases de datos suelen tener utilidades de "carga masiva" que permiten insertar tuplas desde archivos de texto formateados. Estas herramientas son más rápidas que ejecutar múltiples comandos `INSERT`.

### Resumen:

- El comando `INSERT` se usa para agregar tuplas a una tabla.
- Se pueden especificar todos los valores de los atributos o solo algunos, dejando los no especificados como `NULL`.
- Es posible usar consultas `SELECT` para insertar múltiples tuplas a la vez.
- Es fundamental que la evaluación de la consulta `SELECT` termine antes de que ocurra cualquier inserción, para evitar problemas como inserciones infinitas.

## Actualizaciones

La instrucción `UPDATE` en SQL se utiliza para modificar valores específicos dentro de las tuplas de una relación sin necesidad de reemplazar todos los valores de la tupla. Este comando permite actualizar uno o más atributos seleccionando las tuplas a modificar mediante una cláusula `WHERE`, de forma similar a las consultas `SELECT` y las eliminaciones con `DELETE`.

#### Ejemplo básico de `UPDATE`:

Si se quiere incrementar el sueldo de todos los profesores en un 5%, se usaría la siguiente instrucción:

```sql
UPDATE profesor SET sueldo = sueldo * 1.05;
```

#### Actualización con una condición `WHERE`:

Para aplicar el incremento solo a los profesores con sueldos menores de 70.000 €, se añadiría una cláusula `WHERE`:

```sql
UPDATE profesor SET sueldo = sueldo * 1.05 WHERE sueldo < 70000;
```

La cláusula `WHERE` puede ser tan compleja como cualquier otra en SQL, incluyendo subconsultas.

#### Subconsultas en `UPDATE`:

Por ejemplo, si se desea incrementar el sueldo solo a los profesores cuyo sueldo sea inferior a la media de los profesores:

```sql
UPDATE profesor 
SET sueldo = sueldo * 1.05 
WHERE sueldo < (SELECT avg(sueldo) FROM profesor);
```

Esta instrucción evalúa primero la subconsulta, que calcula el sueldo promedio de los profesores, y luego aplica la actualización solo a aquellos que tienen un sueldo por debajo de la media.

#### Usar `CASE` en una instrucción `UPDATE`:

Cuando se necesita aplicar diferentes actualizaciones dependiendo de ciertas condiciones, se puede utilizar el constructor `CASE`. Por ejemplo, si los profesores con sueldos superiores a 100.000 € deben recibir un aumento del 3%, mientras que los que ganan menos de 100.000 € reciben un aumento del 5%, se puede escribir:

```sql
UPDATE profesor
SET sueldo = CASE 
    WHEN sueldo <= 100000 THEN sueldo * 1.05
    ELSE sueldo * 1.03
END;
```

El uso de `CASE` permite combinar múltiples actualizaciones en una sola instrucción, evitando posibles errores de orden en las actualizaciones.

#### Ejemplo avanzado con subconsultas:

Se pueden utilizar subconsultas en la cláusula `SET` para actualizar atributos en función de los resultados de otras relaciones. Por ejemplo, si se desea actualizar el atributo `tot_créditos` de los estudiantes con la suma de los créditos de las asignaturas que hayan aprobado:

```sql
UPDATE estudiante S
SET tot_créditos = (
    SELECT SUM(créditos)
    FROM matricula NATURAL JOIN asignatura
    WHERE S.ID = matricula.ID AND matricula.nota <> 'F' AND matricula.nota IS NOT NULL
);
```

#### Manejo de valores `NULL` con `CASE`:

Para evitar que el valor `tot_créditos` quede en `NULL` si un estudiante no ha aprobado ninguna asignatura, se puede usar un `CASE` en la subconsulta para asignar un valor de 0 en lugar de `NULL`:

```sql
UPDATE estudiante S
SET tot_créditos = (
    SELECT CASE 
        WHEN SUM(créditos) IS NOT NULL THEN SUM(créditos)
        ELSE 0
    END
    FROM matricula NATURAL JOIN asignatura
    WHERE S.ID = matricula.ID AND matricula.nota <> 'F' AND matricula.nota IS NOT NULL
);
```

### Resumen:

- El comando `UPDATE` modifica valores de atributos específicos en las tuplas seleccionadas.
- La cláusula `WHERE` selecciona las tuplas a modificar y puede incluir subconsultas complejas.
- El constructor `CASE` permite aplicar actualizaciones condicionales en una única instrucción.
- Se pueden usar subconsultas en la cláusula `SET` para actualizar valores en función de otras relaciones.
- `CASE` también es útil para manejar valores `NULL` al realizar actualizaciones.

# Vistas

**Definiciones importantes:**

**Relación Base:** Una tabla con nombre correspondiente a una relación del esquema de la Base de Datos dónde las tuplas están almacenadas físicamente en el Gestor de Bases de Datos.

**Vista:** El resultado dinámico de una o más operaciones relacionales sobre las relaciones base (y, opcionalmente, vistas previas) para producir otra relación. Una vista, como relación virtual, no tiene por qué existir físicamente en el Gestor de la Base de Datos, sino que puede producirse cuando se solicite por parte del usuario.

En el contexto de bases de datos, se ha discutido hasta ahora el modelo lógico, que refleja las relaciones reales almacenadas. Sin embargo, no es conveniente que todos los usuarios tengan acceso completo a este modelo por razones de seguridad y usabilidad.

**Razones para usar vistas:**

1. **Seguridad:** Algunos datos deben permanecer ocultos para ciertos usuarios. Por ejemplo, un empleado puede necesitar ver el ID, nombre y departamento de un profesor, pero no su sueldo. Esto se logra mediante una consulta SQL que solo devuelve la información permitida.

2. **Personalización:** A veces, es útil crear relaciones que sean más intuitivas para los usuarios. Por ejemplo, se podría querer listar todas las secciones de asignaturas de un departamento específico en un semestre determinado. Para ello, se utiliza una consulta SQL que filtra la información necesaria.

**Vistas como soluciones:**

En lugar de almacenar el resultado de una consulta (lo cual podría causar desactualizaciones si cambian los datos subyacentes), SQL permite crear "vistas". Una vista es una relación virtual que no se calcula y almacena de forma permanente, sino que se genera al ejecutar la consulta cada vez que se accede a ella. Esto garantiza que la información esté siempre actualizada.

Las vistas son herramientas efectivas para gestionar la seguridad y la presentación de datos en bases de datos, permitiendo que los usuarios accedan solo a la información necesaria de manera intuitiva y segura, sin comprometer la integridad de los datos subyacentes.

## Definición de Vistas en SQL

Una **vista** en SQL es una relación virtual que permite a los usuarios acceder a datos de una manera específica, sin exponer toda la información de las tablas subyacentes. Se define utilizando el comando `CREATE VIEW`, que asigna un nombre a la vista y especifica la consulta que la genera.

#### Sintaxis del Comando

El formato básico para crear una vista es:

```sql
CREATE VIEW v AS <expresión de consulta>;
```

Donde:
- `v` es el nombre de la vista.
- `<expresión de consulta>` es cualquier consulta SQL válida que devuelve un conjunto de datos.

#### Ejemplo de Creación de Vistas

1. **Vista para Empleados:**
   Si un empleado necesita acceder a datos de la relación `profesor` (como ID, nombre y departamento) pero no al sueldo, se puede crear la vista de la siguiente manera:

   ```sql
   CREATE VIEW facultad AS 
   SELECT ID, nombre, nombre_dept FROM profesor;
   ```

   Esta vista permite al empleado acceder solo a la información permitida, manteniendo el sueldo oculto.

2. **Vista de Secciones de Asignaturas:**
   Para listar todas las secciones de asignaturas del departamento de Física en el semestre de otoño de 2009, se puede crear la vista:

   ```sql
   CREATE VIEW física_otoño_2009 AS 
   SELECT asignatura.asignatura_id, secc_id, edificio, número_aula 
   FROM asignatura, sección 
   WHERE asignatura.asignatura_id = sección.asignatura_id 
     AND asignatura.nombre_dept = 'Física' 
     AND sección.semestre = 'Otoño' 
     AND sección.año = '2009';
   ```

#### Funcionamiento de las Vistas

- Las vistas no almacenan datos de forma permanente. En su lugar, el sistema de bases de datos guarda la consulta que define la vista.
- Cada vez que se accede a la vista, el sistema ejecuta la consulta para obtener los datos en tiempo real, garantizando que la información esté siempre actualizada y refleje los cambios en las tablas subyacentes.

## Uso de Vistas en Consultas SQL

Una vez que se ha definido una vista en SQL, se puede utilizar su nombre como si fuera una tabla en consultas posteriores. Esto permite simplificar las consultas y mejorar la legibilidad.

#### Ejemplo de Consulta Usando una Vista

Supongamos que se ha definido la vista `física_otoño_2009`, que contiene información sobre las asignaturas de Física ofertadas en otoño de 2009. Para encontrar todas las asignaturas que se dictaron en el edificio Watson, se puede realizar la siguiente consulta:

```sql
SELECT asignatura_id 
FROM física_otoño_2009 
WHERE edificio = 'Watson';
```

Esto demuestra cómo las vistas pueden ser referenciadas en consultas de la misma manera que las tablas reales.

#### Nombres de Atributos en Vistas

Al definir una vista, también se pueden especificar explícitamente los nombres de los atributos. Por ejemplo, para crear una vista que muestra la suma total de sueldos por departamento, se puede hacer así:

```sql
CREATE VIEW departamentos_total_sueldos(nombre_dept, total_sueldo) AS 
SELECT nombre_dept, SUM(sueldo) 
FROM profesor 
GROUP BY nombre_dept;
```

Aquí, `total_sueldo` es el nombre asignado a la suma de los sueldos, facilitando su uso posterior.

#### Funcionamiento Interno de las Vistas

Es importante entender que, al crear una vista, el sistema de bases de datos guarda la definición de la consulta, no el resultado. Esto significa que:

- Cada vez que se accede a una vista en una consulta, se evalúa la consulta que la define, garantizando que los datos estén siempre actualizados.
- Si se modifican las tablas subyacentes, el resultado de la vista reflejará esos cambios sin necesidad de recalcular y almacenar nuevos resultados.

#### Vistas Anidadas

Además, se puede crear una vista que utiliza otra vista como base. Por ejemplo, si se quiere crear una vista que liste los ID de asignaturas y los números de aula de todas las asignaturas de Física ofertadas en el edificio Watson, se puede definir así:

```sql
CREATE VIEW física_otoño_2009_watson AS 
SELECT asignatura_id, número_aula 
FROM física_otoño_2009 
WHERE edificio = 'Watson';
```

Esta vista es equivalente a definirla mediante una subconsulta, lo que demuestra la flexibilidad de las vistas en SQL:

```sql
CREATE VIEW física_otoño_2009_watson AS 
(SELECT asignatura_id, número_aula 
 FROM (SELECT asignatura.asignatura_id, edificio, número_aula 
       FROM asignatura, sección 
       WHERE asignatura.asignatura_id = sección.asignatura_id 
         AND asignatura.nombre_dept = 'Física' 
         AND sección.semestre = 'Otoño' 
         AND sección.año = '2009') 
 WHERE edificio = 'Watson');
```

## Vistas Materializadas

Las **vistas materializadas** son una extensión de las vistas tradicionales en SQL que permiten almacenar los resultados de una consulta en la base de datos. Esto significa que, a diferencia de las vistas normales, que se recalculan cada vez que se accede a ellas, las vistas materializadas guardan un conjunto de datos que se puede consultar directamente. 

#### Mantenimiento de Vistas Materializadas

El mantenimiento de las vistas materializadas es crucial para asegurar que los datos que contienen estén actualizados. Cuando se realizan cambios en las tablas subyacentes, como agregar, eliminar o modificar registros, el contenido de la vista materializada también debe actualizarse. Esto se puede hacer de varias maneras:

1. **Mantenimiento Inmediato:** La vista se actualiza automáticamente cada vez que se modifica una de las tablas que la definen.
2. **Mantenimiento Perezoso:** La vista se actualiza solo cuando se accede a ella, lo que puede resultar en datos desactualizados hasta que se consulte.
3. **Actualización Periódica:** Algunas bases de datos permiten que la vista se actualice en intervalos programados, lo que puede llevar a que los datos estén desfasados.

#### Ventajas de las Vistas Materializadas

- **Rendimiento Mejorado:** Almacenar resultados de consultas complejas o agregaciones puede acelerar significativamente el tiempo de respuesta, especialmente en aplicaciones que requieren respuestas rápidas.
- **Reducción de Carga:** Las vistas materializadas permiten evitar la lectura de grandes conjuntos de datos subyacentes, al trabajar con un conjunto de datos más pequeño.

#### Consideraciones

Si bien las vistas materializadas ofrecen ventajas en términos de rendimiento, también conllevan costos adicionales, como:

- **Almacenamiento:** Necesitan espacio adicional en disco para almacenar los resultados.
- **Sobrecarga de Actualización:** El mantenimiento de la vista puede requerir recursos y tiempo, especialmente si se actualiza con frecuencia.

#### Implementación en SQL

No existe un estándar SQL para definir vistas materializadas; en su lugar, diferentes sistemas de bases de datos proporcionan sus propias extensiones para implementarlas. Algunas bases de datos mantienen automáticamente las vistas materializadas actualizadas, mientras que otras permiten a los administradores definir cómo y cuándo se deben actualizar.


Las vistas materializadas son herramientas poderosas para optimizar consultas en bases de datos, especialmente en escenarios donde se requieren respuestas rápidas a consultas complejas. Sin embargo, es fundamental sopesar sus beneficios frente a los costos asociados con su almacenamiento y mantenimiento.

## Actualización de Vistas en SQL

Las vistas son herramientas útiles para simplificar consultas, pero permiten realizar operaciones de actualización, inserción o eliminación de manera complicada. Esto se debe a que cualquier modificación a través de una vista debe reflejarse en las tablas reales subyacentes. A continuación, se detallan algunos de los problemas y consideraciones que surgen al actualizar vistas.

#### Problemas en la Actualización de Vistas

1. **Inconsistencias en la Inserción:**
   - Supongamos que existe una vista llamada `facultad`, que permite a un empleado insertar registros. Si intenta insertar una nueva fila (por ejemplo, `('30765', 'Green', 'Música')`), esta operación tendría que traducirse a una inserción en la tabla `profesor`. Sin embargo, esto requiere un valor para el sueldo, que puede no estar disponible. Se presentan dos opciones:
     - Rechazar la inserción y devolver un mensaje de error.
     - Insertar la tupla con un valor nulo para el sueldo.

2. **Dependencias entre Tablas:**
   - Para vistas que combinan varias tablas, como `profesor_info`, que muestra el ID, el nombre y el edificio de los profesores, la inserción de nuevos registros se vuelve problemática. Por ejemplo, si intentamos insertar `('69987', 'White', 'Taylor')`, y no existe un registro correspondiente en `profesor` o `departamento`, no se puede realizar la inserción adecuadamente.

#### Condiciones para Actualizar Vistas

Para que una vista sea considerada actualizable, debe cumplir con varias condiciones:

1. **Una sola tabla en la cláusula `FROM`:** La vista debe estar basada en una única relación.
2. **Atributos en la cláusula `SELECT`:** Solo se deben incluir nombres de atributos, sin expresiones, valores agregados o especificaciones `DISTINCT`.
3. **Atributos no seleccionados:** Cualquier atributo que no aparezca en la cláusula `SELECT` debe permitir valores nulos y no ser parte de una clave primaria.
4. **Sin cláusulas `GROUP BY` o `HAVING`:** La consulta no debe agrupar datos.

Si estas condiciones se cumplen, se pueden permitir operaciones de `INSERT`, `UPDATE` y `DELETE` en la vista.

#### Uso de la Cláusula `WITH CHECK OPTION`

Para evitar inserciones que no cumplan con los criterios de la vista, se puede usar la cláusula `WITH CHECK OPTION` al definirla. Esto significa que si un usuario intenta insertar una tupla que no cumple con la condición de la cláusula `WHERE` de la vista, la inserción será rechazada. Por ejemplo:

```sql
CREATE VIEW historia_profesores AS 
SELECT * FROM profesor WHERE nombre_dept = 'Historia' WITH CHECK OPTION;
```

Con esta cláusula, si alguien intenta insertar un registro que no se incluiría en la vista, la base de datos no permitirá la operación.

#### Conclusiones

Las actualizaciones a través de vistas pueden ser complicadas debido a la necesidad de que los cambios se reflejen en las tablas subyacentes. Aunque es posible permitir actualizaciones bajo ciertas condiciones, estas operaciones deben manejarse con cuidado para evitar inconsistencias. Utilizar cláusulas como `WITH CHECK OPTION` puede ayudar a mantener la integridad de los datos. Cada sistema de gestión de bases de datos puede tener sus propias reglas y capacidades, por lo que es fundamental consultar la documentación específica para obtener detalles sobre cómo manejar actualizaciones en vistas.


# Restricciones de Integridad

Las **restricciones de integridad** son reglas que aseguran la consistencia y validez de los datos en una base de datos. Protegen contra modificaciones que podrían causar incoherencias, garantizando que solo se realicen cambios que no comprometan la integridad de la información.

#### Ejemplos de Restricciones de Integridad

1. **No Nulos:** Un atributo, como el nombre de un profesor, no puede ser nulo.
2. **Unicidad:** No puede haber duplicados en un identificador único, como el ID de un profesor.
3. **Referencial:** Todos los nombres de departamento en una tabla (por ejemplo, `asignatura`) deben corresponder a un departamento existente en la tabla `departamento`.
4. **Condiciones Numéricas:** El presupuesto de un departamento debe ser mayor que 0.00 €.

#### Implementación de Restricciones de Integridad

Las restricciones de integridad se definen principalmente en el proceso de diseño del esquema de la base de datos, generalmente mediante el comando `CREATE TABLE`. Por ejemplo:

```sql
CREATE TABLE profesor (
    ID INT PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    nombre_dept VARCHAR(50),
    FOREIGN KEY (nombre_dept) REFERENCES departamento(nombre_dept)
);
```

Además, se pueden añadir restricciones a tablas existentes usando el comando `ALTER TABLE`. Por ejemplo:

```sql
ALTER TABLE departamento 
ADD CONSTRAINT presupuesto_mayor_cero CHECK (presupuesto > 0);
```

#### Verificación de Restricciones

Cuando se añaden restricciones, el sistema de bases de datos verifica que las tablas existentes cumplen con las nuevas reglas. Si no lo hacen, la operación se rechaza, evitando que se introduzcan datos inválidos.

#### Consideraciones de Desempeño

Aunque las restricciones de integridad son cruciales para mantener la calidad de los datos, la verificación de ciertos predicados complejos puede ser costosa en términos de recursos. Por ello, la mayoría de los sistemas de bases de datos se enfocan en restricciones que se pueden comprobar con un costo mínimo.

Las restricciones de integridad son una parte fundamental del diseño de bases de datos. Aseguran que los datos sean válidos y coherentes, protegiendo contra errores accidentales. Al definir y aplicar estas restricciones adecuadamente, se puede garantizar la calidad de la información almacenada en la base de datos.

### Restricciones de Integridad sobre una Sola Relación

Al definir tablas en SQL mediante el comando `CREATE TABLE`, se pueden incluir diversas restricciones de integridad para garantizar la calidad y consistencia de los datos. Además de la restricción de **clave primaria**, se pueden utilizar otros tipos de restricciones, tales como:

1. **NOT NULL:**
   - Esta restricción asegura que un atributo no puede contener valores nulos. Es útil para atributos que deben tener un valor válido en cada registro, como el nombre de un profesor.
   - Ejemplo:
     ```sql
     CREATE TABLE profesor (
         ID INT PRIMARY KEY,
         nombre VARCHAR(100) NOT NULL
     );
     ```

2. **UNIQUE:**
   - Esta restricción garantiza que todos los valores en una columna sean únicos, es decir, no se pueden repetir en la misma tabla. Es útil para atributos que deben ser únicos, como un número de identificación.
   - Ejemplo:
     ```sql
     CREATE TABLE departamento (
         nombre_dept VARCHAR(50) UNIQUE,
         presupuesto DECIMAL(10, 2)
     );
     ```

3. **CHECK** $predicado$:
   - Esta restricción permite definir condiciones que los valores en una columna deben cumplir. Se pueden usar expresiones lógicas para establecer límites o condiciones específicas.
   - 
     ``` sql
     CREATE TABLE asignatura (
         asignatura_id INT PRIMARY KEY,
         nombre VARCHAR(100),
         créditos INT CHECK (créditos > 0)
     );
     ```

### Ejemplo Completo de Definición de Tabla

A continuación, se muestra un ejemplo que combina varias restricciones en la creación de una tabla:

```sql
CREATE TABLE profesor (
    ID INT PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    nombre_dept VARCHAR(50),
    sueldo DECIMAL(10, 2) CHECK (sueldo > 0),
    UNIQUE (nombre, nombre_dept)
);
```

En este ejemplo:
- **ID** es la clave primaria.
- **nombre** no puede ser nulo.
- **sueldo** debe ser mayor que 0.
- La combinación de **nombre** y **nombre_dept** debe ser única.

Las restricciones de integridad son esenciales para mantener la calidad de los datos en una base de datos. Al incluir restricciones como `NOT NULL`, `UNIQUE` y `CHECK` en la definición de tablas, se puede asegurar que los datos cumplen con ciertos criterios, lo que ayuda a prevenir errores y mantener la consistencia en la información almacenada.


### Restricción NOT NULL en SQL

La restricción **NOT NULL** se utiliza en SQL para asegurar que un atributo no pueda contener valores nulos. Esto es fundamental en situaciones donde es esencial tener información completa y válida, ya que un valor nulo puede representar la ausencia de información, lo que puede resultar poco útil o engañoso.

#### Ejemplo de Uso de NOT NULL

Consideremos el caso de una relación `estudiante`, donde los atributos `nombre` y `presupuesto` son críticos:

```sql
CREATE TABLE estudiante (
    ID INT PRIMARY KEY,
    nombre VARCHAR(20) NOT NULL,
    presupuesto NUMERIC(12, 2) NOT NULL
);
```

En este ejemplo:
- **nombre** no puede ser nulo, ya que un estudiante sin nombre no aporta información útil.
- **presupuesto** también se establece como no nulo, ya que un departamento con un presupuesto nulo no puede funcionar adecuadamente.

#### Comportamiento ante Valores Nulos

Cuando se intenta insertar o modificar una tupla en la tabla, el sistema de gestión de bases de datos (SGBD) genera un error si se intenta asignar un valor nulo a un atributo marcado como `NOT NULL`. Por ejemplo:

```sql
INSERT INTO estudiante (ID, nombre, presupuesto) VALUES (1, NULL, 1500.00);
```

Este intento de inserción fallará, ya que `nombre` no puede ser nulo.

#### Restricciones Implícitas en Claves Primarias

Es importante mencionar que SQL automáticamente prohíbe los valores nulos en las claves primarias. Esto significa que si un atributo se declara como clave primaria, no es necesario especificar la restricción `NOT NULL`, ya que es una condición implícita. Por ejemplo:

```sql
CREATE TABLE departamento (
    nombre_dept VARCHAR(50) PRIMARY KEY,
    presupuesto NUMERIC(12, 2)
);
```

En este caso, `nombre_dept` no puede ser nulo, incluso si no se declara explícitamente como `NOT NULL`.

La restricción `NOT NULL` es una herramienta crucial para garantizar la integridad de los datos en una base de datos. Al evitar valores nulos en atributos críticos, se asegura que la información almacenada sea completa y válida, lo que facilita la gestión y análisis de los datos. Esta restricción es especialmente importante en claves primarias, donde la integridad de los datos es fundamental.

### Restricción UNIQUE en SQL

La restricción **UNIQUE** se utiliza en SQL para garantizar que un conjunto de atributos contenga valores únicos en cada fila de una tabla. Es decir, no se permite que dos o más tuplas tengan el mismo valor en todos los atributos especificados en la restricción.

#### Definición de la Restricción UNIQUE

La sintaxis para definir una restricción UNIQUE es la siguiente:

```sql
UNIQUE (A_j1, A_j2, …, A_jm)
```

Donde $( A_j1, A_j2, \ldots, A_jm )$ son los atributos que forman la clave candidata. Esta clave candidata asegura que no se repitan combinaciones de valores en esos atributos a lo largo de la tabla.

#### Comportamiento con Valores Nulos

Es importante destacar que, a diferencia de las restricciones NOT NULL, la restricción UNIQUE permite que los atributos de la clave candidata contengan valores nulos, a menos que se declaren explícitamente como NOT NULL. Esto se debe a que los valores nulos son tratados de manera especial en SQL: no son considerados iguales a otros valores, incluidos otros valores nulos. Por lo tanto, múltiples filas pueden tener un valor nulo en un atributo definido como UNIQUE sin violar la restricción.

#### Ejemplo de Uso

Consideremos una tabla `estudiante` donde queremos garantizar que cada estudiante tenga un número de identificación único, pero también permitir que el campo `email` sea nulo:

```sql
CREATE TABLE estudiante (
    ID INT PRIMARY KEY,
    nombre VARCHAR(100),
    email VARCHAR(100) UNIQUE
);
```

En este ejemplo:
- El atributo `ID` es la clave primaria y debe ser único y no nulo.
- El atributo `email` tiene una restricción UNIQUE, por lo que no puede haber dos estudiantes con el mismo correo electrónico, pero sí puede haber estudiantes sin un correo electrónico (es decir, con `email` nulo).

La restricción UNIQUE es una herramienta fundamental en el diseño de bases de datos que ayuda a mantener la integridad de los datos al garantizar que ciertos atributos no tengan valores duplicados. Esta restricción es flexible en el manejo de valores nulos, permitiendo así una mayor versatilidad en el diseño de esquemas de datos.

### La Cláusula CHECK en SQL

La cláusula **CHECK** se utiliza en SQL para definir restricciones que deben cumplirse para que una tupla sea aceptada en una tabla. Es una forma de asegurar que los datos ingresados en una relación cumplen con ciertos criterios, lo que ayuda a mantener la integridad de la base de datos.

#### Sintaxis de la Cláusula CHECK

La cláusula se puede incluir en la declaración de una tabla de la siguiente manera:

```sql
CHECK (P)
```

Donde \( P \) es el predicado que debe ser verdadero para cada tupla de la relación.

#### Ejemplo de Uso de CHECK

Un uso común de la cláusula CHECK es restringir los valores de los atributos. Por ejemplo, para garantizar que el presupuesto de un departamento no sea negativo:

```sql
CREATE TABLE departamento (
    nombre_dept VARCHAR(50) PRIMARY KEY,
    presupuesto NUMERIC(12, 2) CHECK (presupuesto > 0)
);
```

En este caso, el predicado asegura que cualquier valor asignado al `presupuesto` debe ser mayor que 0.

#### Ejemplo de Uso con Tipos Enumerados

La cláusula CHECK también puede simular tipos enumerados. Por ejemplo, en la creación de una tabla `sección` se puede especificar que el atributo `semestre` solo puede tomar ciertos valores:

```sql
CREATE TABLE sección (
    asignatura_id VARCHAR(8),
    secc_id VARCHAR(8),
    semestre VARCHAR(6),
    año NUMERIC(4, 0),
    edificio VARCHAR(15),
    número_aula VARCHAR(7),
    franja_horaria_id VARCHAR(4),
    PRIMARY KEY (asignatura_id, secc_id, semestre, año),
    CHECK (semestre IN ('Otoño', 'Invierno', 'Primavera', 'Verano'))
);
```

Aquí, la cláusula CHECK asegura que el valor de `semestre` debe ser uno de los cuatro especificados, actuando como un tipo enumerado.

#### Restricciones y Limitaciones

Aunque el predicado de la cláusula CHECK puede ser bastante complejo y arbitrario, actualmente, la mayoría de los sistemas de bases de datos no permiten que contenga subconsultas. Esto limita algunas de las formas en que se pueden aplicar restricciones, pero aún así proporciona un mecanismo potente para mantener la integridad de los datos.

La cláusula CHECK es una herramienta valiosa en SQL para asegurar que los datos insertados en una tabla cumplen con condiciones específicas. Esto no solo ayuda a prevenir errores en los datos, sino que también permite la implementación de reglas de negocio directamente en el esquema de la base de datos, mejorando la calidad de los datos almacenados.

# Integridad referencial
En esta explicación se aborda el concepto de **integridad referencial** y cómo se puede implementar en SQL utilizando claves externas. La **integridad referencial** asegura que un valor en un conjunto de atributos de una relación (tabla) también exista en otro conjunto de atributos en otra relación.

### Claves externas en SQL
Las claves externas se declaran mediante la cláusula `foreign key`, la cual se utiliza al crear una tabla. Esta clave externa hace referencia a un conjunto de atributos en otra relación, y si no se cumple esta relación entre las dos tablas, se puede violar la integridad referencial. Un ejemplo típico es la siguiente definición:

```sql
foreign key (nombre_dept) references departamento
```

En este caso, para cada tupla en la tabla `asignatura`, el valor de `nombre_dept` debe existir en la tabla `departamento`.

### Restricciones de integridad referencial
Se utiliza la integridad referencial para evitar que, por ejemplo, se asignen asignaturas a departamentos que no existen. Este tipo de restricciones se basan en la idea de que el conjunto de valores de un subconjunto de atributos en una tabla debe ser un subconjunto de los valores en los atributos correspondientes de otra tabla.

Sean dos relaciones `r1` y `r2` con conjuntos de atributos `R1` y `R2`, si se exige que, para toda tupla de `r2`, exista una tupla en `r1` tal que ciertos atributos coincidan, esto es una **restricción de integridad referencial**.

### Comportamiento en SQL
En SQL, por defecto, las claves externas hacen referencia a la clave primaria de la tabla objetivo, pero también es posible especificar una lista de atributos explícita usando la cláusula `references`. Estos atributos deben ser una clave candidata (clave primaria o única).

SQL permite manejar violaciones de integridad referencial de distintas maneras. Las acciones más comunes son:

- **Cascade**: Si se borra o actualiza un registro en la tabla referenciada, el cambio se propaga a las tablas que referencian ese registro.
  
  Ejemplo:
  ```sql
  foreign key (nombre_dept) references departamento on delete cascade on update cascade
  ```

  Si se borra un departamento, todas las asignaturas relacionadas se borrarán automáticamente.

- **Set null**: Al borrar o actualizar un registro referenciado, los valores de las columnas referenciadas se establecen a `null`.
  
  Ejemplo:
  ```sql
  foreign key (nombre_dept) references departamento on delete set null
  ```

- **Set default**: Similar a `set null`, pero los valores se establecen a un valor predeterminado.
  
  Ejemplo:
  ```sql
  foreign key (nombre_dept) references departamento on delete set default
  ```

### Ejemplo SQL

Aquí tienes un ejemplo de la definición de varias tablas que implementan integridad referencial:

```sql
create table aula (
  edificio varchar(15),
  numero_aula varchar(7),
  capacidad numeric(4,0),
  primary key (edificio, numero_aula)
);

create table departamento (
  nombre_dept varchar(20),
  edificio varchar(15),
  presupuesto numeric(12,2) check (presupuesto > 0),
  primary key (nombre_dept)
);

create table asignatura (
  asignatura_id varchar(8),
  nombre_asig varchar(50),
  nombre_dept varchar(20),
  creditos numeric(2,0) check (creditos > 0),
  primary key (asignatura_id),
  foreign key (nombre_dept) references departamento
);
```

Este código define una base de datos simple de una universidad con integridad referencial entre las tablas `asignatura` y `departamento`.

### Acciones en violaciones
Cuando ocurre una violación de una restricción de integridad referencial, el sistema puede rechazar la transacción, revertir los cambios, o realizar alguna de las acciones mencionadas (cascade, set null, etc.). Si no es posible resolver la violación con ninguna de estas acciones, se aborta la transacción.

Este conjunto de reglas asegura que las relaciones entre las tablas sean coherentes y se mantenga la integridad de los datos.

