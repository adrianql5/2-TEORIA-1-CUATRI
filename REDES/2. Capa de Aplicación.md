[[archivos/bibliografia/Tema2Redes.pdf|Tema2Redes]]
[[2.1 Ejercicios Capa de Aplicación]]

# Introducción
La capa de aplicación se ocupa de la **comunicación entre procesos.** El esquema típico se muestra en la siguiente figura:
![[archivos/imagenes/Pasted image 20240929172714.png]]

## Protocolo de comunicación
La comunicación de dos procesos, tanto en el **mismo host** como en hosts diferentes, se hace **enviando mensajes**. Para que los mensajes sean comprendidos hay que establecer un **protocolo**.

El **protocolo** facilita la programación. Hay que programar tanto las funciones de envío como las de recepción y si tenemos un protocolo claro de programación será más fácil.

**Especificaciones del protocolo:**
- **Qué mensajes hay**, típicamente qué repeticiones e pueden hacer y qué respuestas les corresponden
- **Las reglas** que especifican cuando se **envían o responden** mensajes.
- La **sintaxis del mensaje**, es decir, los campos de que consta
- La **semántica de cada campo**, su significado.

## Servicios que necesita la aplicación de red
Los protocolos de la capa de aplicación utilizan por debajo los portocolos básicos proporcionados por la capa de transporte. COmo vimos en el tema anterior, estos son: **TCP y UDP**, TCP proporciona un servicio **fiable** y UDP un servicio **sencillo y rapido, pero no garantiza la recepción**.
En este tema veremos los siguientes **protocolos de aplicación:**
![[archivos/imagenes/Pasted image 20240929173650.png]]
Los TCP necesitamos tener la seguridad de que **no se producen errores**. El **DNS** (*servicio de nombres de dominio*), utilizado para realizar traducciones de nombres de **hosts/ direcciones IP**, se usa **UDP** porque se prefiere cambiar de servidos en caso de no obtener respuesta.
Cada **host** suele tener una **lista de servidores de nombres** y cuando se precisa una traducción se va probando sucesivamente con los servidores de la lista. Si el primero no responde porque el mensaje se pierde, se pasa el siguiente y así sucesivamente. SI hay problemas mejor **cambiar de servidor** antes que intentarlo siempre con el mismo, por eso va bien **UDP**
Además de los **protocolos** y la **transferencia fiable/no fiable de datos**, se necesita **ancho de banda** y **temporarización**.

Denominamos **agente de usuario**, a la interfaz entre el usuario y la aplicación. O sea el programa gráfico que permite al usuario trabajar cómodamente con la aplicación, por ejemplo **firefox**.

# Protocolo de Transferencia de Hipertexto HTTP
Este protocolo define la comunicación entre un servidor y un cliente web.

## Tipos de conexiones HTTP
Una **página web** usualmente consta de varios objetos, es decir, de varios **ficheros**:
![[archivos/imagenes/Pasted image 20240929183958.png]]
Cuando un **navegador** solicita una **página web**, el primer objeto que se devuelve es el **documento base**, que contiene el layout de la página usualmente también el texto. El **layout** indica cómo conseguir lo restantes objetos y dónde han de colocarse.
Dependiendo de como se realicen las conexiones para conseguir los distintos objetos, se distinguen las siguientes conexiones **HTTP**:
![[archivos/imagenes/Pasted image 20240929184228.png]]

Con **conexiones no persistentes** se utiliza una conexión **TCP** distinta para transferir cada uno de los objetos. Con **conexiones persistentes** se pueden transferir varios objetos e incluso varias páginas con la misma conexión **TCP**.
![[archivos/imagenes/Pasted image 20240929184416.png]]
Las **conexiones no persistentes** pueden ser **serie** si se espera a que acabe la **conexión TCP** previa antes de que comience la siguiente o bien **paralelas** si se inician varias **conexiones TCP** a la vez. Analogía: al abrir varias pestañas del navegador lo uso en paralelo.
![[archivos/imagenes/Pasted image 20240929184609.png]]

Con **conexiones persistentes** se utiliza la misma **conexión TCP** para conseguir **varios objetos** o incluso varias **páginas web** diferentes. Típicamente el **servidor** cierra la **conexión TCP** cuando no ha sido utilizada durante cierto tiempo.

![[archivos/imagenes/Pasted image 20241005172250.png]]


Existen dos versiones de **conexiones persistentes**. En la versión **sin entubamiento**, el cliente sólo pide un nuevo objeto cuando el previo ha sido recibido. En la versión **con entubamiento** el cliente puede hacer peticiones de varios objetos antes de recibir los anteriores. El modo por defecto de **HTTP/1.1**  es **persistente con entubamiento**.

![[archivos/imagenes/Pasted image 20240929184949.png]]

Podemos sacar la siguiente analogía: **sin entubamiento** es como si un cliente pone sus productos en la cinta del supermercado y el cajero va cobrando. **Con entubamiento** es como si los siguientes clientes ya estuviesen poniendo sus productos en la cinta mientras que el cajero va cobrando los del primer cliente. El **entubamiento** permite que las peticiones avancen en paralelo, lo que aumenta la eficiencia.

## Tiempo de transferencia de una página web
Vamos a calcular el tiempo que se necesita para conseguir el primer objeto de una **página web**. Consideremos una *conexión no persistente en serie*. Como detalle adicional vamos a tener en cuenta que el objeto es un fichero de un determinado tamaño.
![[archivos/imagenes/Pasted image 20241005172705.png]]

- **Tiempo de ida y vuelta (*RTT round-trip time*):** Es el tiempo ncesario para que un paquete pequeño vaya de **cliente a servidor y de nuevo al cliente**. Incluye todos los posibles retardos: *tiempo de propagación en los enlaces, espera en las colas y procesamiento en los routers.* Ya tenemos el tiempo de un bit.
- **Tiempo de transmisión del fichero:** Es el tiempo necesario para **almacenar y reenviar** un fichero y como es lógico depende del tamaño del fichero.
Resulta un tiempo de transferencia del primer objeto *2RTT +Ttransmision*, puede comprobarse que es el mismo en los cuatro tipos de conexiones. En cambio, **el tiempo de transferencia** de los siguientes objetos es dependiente del tipo de conexión.

## Mensajes HTTP
**Separación de los campos**. Antes de nada, veamos como se separan los campos en los mensajes. EN *ASCII* se consideran los siguientes caracteres.
![[archivos/Pasted image 20241005173800.png]]
Los protocolos de **aplicaciones de red**, incluido **HTTP**, definen la separación de líneas en un mensaje con la pareja de caracteres *cr+lf*. Sin embargo, no todos los sistemas operativos usan por defecto estos separadores en los textos. WIndows si lo hace, **Linux** sólo separa las líneas con un *lf*.
![[archivos/Pasted image 20241005174223.png]]
En cuanto a la programación en lengua C, la sentencia:
```C
printf("hola\n");
```
En Windows se inserta *cr+lf*, mientras que en Linux inserta sólo *lf*. Por tanto, en Linux tendremos que escribir
```C
printf("hola\r\n");
```
si queremos insertar *cr+lf*.
De todas formas, los programas de la capa de aplicacioón osn bastante robustos y suelen comprender los separadores de línea en cualquiera de las versiones.

**Peticiones y respuestas**. El protocolo **HTTP** es extremadamente siemple. Sólo hay dos tipos de mensajes: *petición y respuesta.* Las **peticiones** se usan para pedir objetos, por ejemplo, *págians web o imágenes,* mientras que las respuestas contienen los objetos.

**Cabecera y cuerpo**. Ambos tipos de mensajes constan de una cabecera y de un cuerpo. La **cabecera** contiene **información de control** y es texto legible en ASCII de 7 bits (*letras, números, especios, retornos y poco más, no incluye ñ puesto que ésta sólo está incluida en el ASCII de 8 bits*). El cuerpo contiene la informacionl que puede ser un objeto, el contenido de un formulario, etc, y son datos binarios, es decir, no tienen el significado de los caracteres ASCII.

### Mensaje HTTP de petición
Estos mensajes tienen una cabecera que consta e 3 partes y de un cuerpo que consta sólo de una.
![[archivos/imagenes/Pasted image 20241005175747.png]]

- **Línea de petición**. Con ella pedimos un objeto, como un documento base o una imagen. Tiene 3 campos separados por espacios: primero el método, que puede ser **GET**, para pedir una página de **web normal** o **POST** cuando se rellena un **cierto tipo de formulario**. EL segundo campo es la **URL** (localizador de recursos uniforme) que indica el **el directorio y el nombre del objeto** que queremos obtener. Por último, el tercer campo es la versión de protocolo que se desar usar, actualmente *HTTP/1.1*.
- **Líneas de cabecera**: Pude haber el número de líneas que haga falta. Cada línea contiene una opción y consta de dos campos: **el nombre de la opción y su valor**:
![[archivos/imagenes/Pasted image 20241005180434.png]]
- **Línea en blanco:** Separa la cabecera del cuerpo
- **Cuerpo:** Cuando se pide una página o un objeto con el método **GET** el cuerpo va vacío. Cuando se rellena un formulario con el método **POST**, el cuerpo contiene los datos del formulario. En este caso el servidor procesará los datos introducidos y devolverá una página personalizada
*Nota: hay más formas de enviar los datos de un formulario, por ejemplo, incluirlos en la URL, como hace por ejemplo, google*.

### Mensaje HTTP de respuesta
También tienen una **cabecera** que consta de 3 partes, mientras que el cuerpo sólo consta de una.
![[archivos/imagenes/Pasted image 20241005180931.png]]
- **Línea de estado:** tiene 3 campos: el primero es la **versión** que está utilizando el servidos, actualmente *HTTP/1.1*, el segundo es el **código de estado**, que indica el **éxito o fracaso** de le petición, mientras que el tercero es una **frase** con una pequeña explicación e este código. Por ejemplo, algunos códigos y frases
![[archivos/imagenes/Pasted image 20241005181342.png]]
- **Líneas de cabecera:** son las opciones y puede haber el número que haga falta. Cada línea consta de dos campos: **el nombre de la opción y su valor.** Ejemplo:
![[archivos/imagenes/Pasted image 20241005181503.png]]
- **Línea en blanco:** separa la cabecera del cuerpo
- **Cuerpo:** los datos, en este caso el objeto, página web, programa java, animación flash, etc.

**Puerto:** **HTTP** utiliza por defecto el **puerto 80**. En unas de las prácticas veremos el contenido de los mensajes que se envían y reciben en **HTTP** con el comando *telnet*. A este comando haya que indicarle el nombre de un **servidor web** y especificarle el puerto 80 (*telnet www.usc.es 80*)