[[archivos/bibliografia/Tema2Redes.pdf|Tema2Redes]]
[[2.1 Ejercicios Capa de Aplicación]]

# Introducción
La capa de aplicación se ocupa de la **comunicación entre procesos.** El esquema típico se muestra en la siguiente figura:
![[archivos/imagenes/Pasted image 20240929172714.png]]

## Protocolo de comunicación
La comunicación de dos procesos, tanto en el **mismo host** como en hosts diferentes, se hace **enviando mensajes**. Para que los mensajes sean comprendidos hay que establecer un **protocolo**.

El **protocolo** facilita la programación. Hay que programar tanto las funciones de envío como las de recepción y si tenemos un protocolo claro de programación será más fácil.

**Especificaciones del protocolo:**
- **Qué mensajes hay**, típicamente qué repeticiones e pueden hacer y qué respuestas les corresponden
- **Las reglas** que especifican cuando se **envían o responden** mensajes.
- La **sintaxis del mensaje**, es decir, los campos de que consta
- La **semántica de cada campo**, su significado.

## Servicios que necesita la aplicación de red
Los protocolos de la capa de aplicación utilizan por debajo los portocolos básicos proporcionados por la capa de transporte. COmo vimos en el tema anterior, estos son: **TCP y UDP**, TCP proporciona un servicio **fiable** y UDP un servicio **sencillo y rapido, pero no garantiza la recepción**.
En este tema veremos los siguientes **protocolos de aplicación:**
![[archivos/imagenes/Pasted image 20240929173650.png]]
Los TCP necesitamos tener la seguridad de que **no se producen errores**. El **DNS** (*servicio de nombres de dominio*), utilizado para realizar traducciones de nombres de **hosts/ direcciones IP**, se usa **UDP** porque se prefiere cambiar de servidos en caso de no obtener respuesta.
Cada **host** suele tener una **lista de servidores de nombres** y cuando se precisa una traducción se va probando sucesivamente con los servidores de la lista. Si el primero no responde porque el mensaje se pierde, se pasa el siguiente y así sucesivamente. SI hay problemas mejor **cambiar de servidor** antes que intentarlo siempre con el mismo, por eso va bien **UDP**
Además de los **protocolos** y la **transferencia fiable/no fiable de datos**, se necesita **ancho de banda** y **temporarización**.

Denominamos **agente de usuario**, a la interfaz entre el usuario y la aplicación. O sea el programa gráfico que permite al usuario trabajar cómodamente con la aplicación, por ejemplo **firefox**.

# Protocolo de Transferencia de Hipertexto HTTP
Este protocolo define la comunicación entre un servidor y un cliente web.

- **TCP**: Su principal función es **transmitir datos de manera fiable** entre dos dispositivos. Controla la transmisión de los datos en fragmentos llamados **segmentos**, se asegura de que lleguen sin errores y en el orden correcto, y maneja la retransmisión si se pierden o corrompen.
   - **HTTP**: Es un **protocolo de comunicación entre un cliente y un servidor** para **intercambiar datos** en formato de texto o binario, como páginas web, imágenes, archivos, etc. Es lo que usamos cuando navegamos por la web.
## Tipos de conexiones HTTP
Una **página web** usualmente consta de varios objetos, es decir, de varios **ficheros**:
![[archivos/imagenes/Pasted image 20240929183958.png]]
Cuando un **navegador** solicita una **página web**, el primer objeto que se devuelve es el **documento base**, que contiene el layout de la página usualmente también el texto. El **layout** indica cómo conseguir lo restantes objetos y dónde han de colocarse.
Dependiendo de como se realicen las conexiones para conseguir los distintos objetos, se distinguen las siguientes conexiones **HTTP**:
![[archivos/imagenes/Pasted image 20240929184228.png]]

Con **conexiones no persistentes** se utiliza una conexión **TCP** distinta para transferir cada uno de los objetos. Con **conexiones persistentes** se pueden transferir varios objetos e incluso varias páginas con la misma conexión **TCP**.
![[archivos/imagenes/Pasted image 20240929184416.png]]
Las **conexiones no persistentes** pueden ser **serie** si se espera a que acabe la **conexión TCP** previa antes de que comience la siguiente o bien **paralelas** si se inician varias **conexiones TCP** a la vez. Analogía: al abrir varias pestañas del navegador lo uso en paralelo.
![[archivos/imagenes/Pasted image 20240929184609.png]]

Con **conexiones persistentes** se utiliza la misma **conexión TCP** para conseguir **varios objetos** o incluso varias **páginas web** diferentes. Típicamente el **servidor** cierra la **conexión TCP** cuando no ha sido utilizada durante cierto tiempo.

![[archivos/imagenes/Pasted image 20241005172250.png]]


Existen dos versiones de **conexiones persistentes**. En la versión **sin entubamiento**, el cliente sólo pide un nuevo objeto cuando el previo ha sido recibido. En la versión **con entubamiento** el cliente puede hacer peticiones de varios objetos antes de recibir los anteriores. El modo por defecto de **HTTP/1.1**  es **persistente con entubamiento**.

![[archivos/imagenes/Pasted image 20240929184949.png]]

Podemos sacar la siguiente analogía: **sin entubamiento** es como si un cliente pone sus productos en la cinta del supermercado y el cajero va cobrando. **Con entubamiento** es como si los siguientes clientes ya estuviesen poniendo sus productos en la cinta mientras que el cajero va cobrando los del primer cliente. El **entubamiento** permite que las peticiones avancen en paralelo, lo que aumenta la eficiencia.

## Tiempo de transferencia de una página web
Vamos a calcular el tiempo que se necesita para conseguir el primer objeto de una **página web**. Consideremos una *conexión no persistente en serie*. Como detalle adicional vamos a tener en cuenta que el objeto es un fichero de un determinado tamaño.
![[archivos/imagenes/Pasted image 20241005172705.png]]

- **Tiempo de ida y vuelta (*RTT round-trip time*):** Es el tiempo ncesario para que un paquete pequeño vaya de **cliente a servidor y de nuevo al cliente**. Incluye todos los posibles retardos: *tiempo de propagación en los enlaces, espera en las colas y procesamiento en los routers.* Ya tenemos el tiempo de un bit.
- **Tiempo de transmisión del fichero:** Es el tiempo necesario para **almacenar y reenviar** un fichero y como es lógico depende del tamaño del fichero.
Resulta un tiempo de transferencia del primer objeto *2RTT +Ttransmision*, puede comprobarse que es el mismo en los cuatro tipos de conexiones. En cambio, **el tiempo de transferencia** de los siguientes objetos es dependiente del tipo de conexión.

## Mensajes HTTP
El protocolo HTTP define cómo se envían y reciben mensajes entre un cliente (por ejemplo, un navegador web) y un servidor (el sitio web al que se accede). Estos mensajes se separan en **cabeceras** (headers) y un **cuerpo** (body), donde la cabecera contiene información de control y el cuerpo contiene los datos solicitados o enviados, como páginas web o imágenes.

### Separación de líneas en mensajes HTTP

En HTTP, los mensajes utilizan los caracteres de retorno de carro y salto de línea (*CR+LF*) para separar las líneas. Sin embargo, esto varía entre sistemas operativos:
- En **Windows**, el separador de líneas es *CR+LF*.
- En **Linux**, solo se utiliza *LF*.

En programación en C, la sentencia `printf("hola\n");` en **Windows** genera *CR+LF*, mientras que en **Linux** solo inserta *LF*. Para que funcione en ambos sistemas, puedes usar explícitamente `printf("hola\r\n");`.

### Peticiones y Respuestas HTTP

El protocolo HTTP tiene dos tipos principales de mensajes:
1. **Peticiones (Request)**: El cliente las envía al servidor para solicitar recursos, como páginas web o imágenes.
2. **Respuestas (Response)**: El servidor responde con los recursos solicitados o con información sobre el éxito o fracaso de la petición.

### Cabecera y Cuerpo

- **Cabecera**: Contiene información de control. Es texto legible en **ASCII** de 7 bits (sin caracteres especiales como "ñ").
- **Cuerpo**: Contiene los datos solicitados o enviados, que pueden ser binarios (como imágenes o archivos).

### Mensaje HTTP de Petición
![[archivos/imagenes/Pasted image 20241005175747.png]]
Un mensaje de petición consta de:
1. **Línea de petición**:
   - **Método**: Usualmente **GET** (para obtener una página) o **POST** (para enviar datos de un formulario).
   - **URL**: El recurso solicitado (por ejemplo, una página web o una imagen).
   - **Versión de protocolo**: Actualmente *HTTP/1.1*.

   Ejemplo:
   ```
   GET /index.html HTTP/1.1
   ```

2. **Líneas de cabecera**: Opciones que informan al servidor sobre detalles de la solicitud.
   Ejemplo:
   ```
   Host: www.ejemplo.com
   User-Agent: Mozilla/5.0
   ```
![[archivos/imagenes/Pasted image 20241005180434.png]]
3. **Línea en blanco**: Separa la cabecera del cuerpo.

4. **Cuerpo**: En las peticiones **GET** suele estar vacío. En las peticiones **POST**, puede contener datos de formularios.

### Mensaje HTTP de Respuesta
![[archivos/imagenes/Pasted image 20241005180931.png]]
Un mensaje de respuesta consta de:
1. **Línea de estado**:
   - **Versión**: La versión de HTTP usada por el servidor (*HTTP/1.1*).
   - **Código de estado**: Indica si la petición tuvo éxito o no (por ejemplo, 200 para éxito, 404 para "no encontrado").
   - **Frase descriptiva**: Una explicación breve del código de estado.

   Ejemplo:
   ```
   HTTP/1.1 200 OK
   ```
![[archivos/imagenes/Pasted image 20241005181342.png]]
2. **Líneas de cabecera**: Información adicional sobre la respuesta (como el tipo de contenido o la longitud).
   Ejemplo:
   ```
   Content-Type: text/html
   Content-Length: 3456
   ```
![[archivos/imagenes/Pasted image 20241005181503.png]]

3. **Línea en blanco**: Separa la cabecera del cuerpo.
4. **Cuerpo**: Contiene los datos solicitados, como una página HTML, una imagen, etc.

### Puerto

El protocolo HTTP utiliza el **puerto 80** por defecto. Durante las prácticas, puedes usar comandos como **telnet** para ver el contenido de los mensajes HTTP:
```bash
telnet www.ejemplo.com 80
```

Este comando permite conectarse a un servidor web en el puerto 80 y ver los mensajes intercambiados entre cliente y servidor.

**TCP** y **HTTP** son dos protocolos fundamentales en la comunicación en redes, pero operan en **diferentes capas** del modelo de red. Mientras que **TCP** se encarga de cómo se transmiten los datos entre dispositivos, **HTTP** define cómo se estructuran y manejan esos datos. A continuación te explico su relación y diferencias:


| Característica | **TCP** | **HTTP** |
|----------------|---------|----------|
| **Capa**       | Transporte (OSI: capa 4, TCP/IP: capa de transporte) | Aplicación (OSI: capa 7, TCP/IP: capa de aplicación) |
| **Propósito**  | Garantizar la transmisión fiable de datos entre dos dispositivos | Intercambio de datos (solicitudes y respuestas) entre un cliente y un servidor |
| **Conexión**   | Orientado a la conexión (establece, usa y cierra la conexión) | Usa TCP para la conexión, pero no establece directamente la conexión |
| **Fiabilidad** | Garantiza la entrega y orden de los datos | Depende de TCP para la entrega fiable |
| **Formato de mensaje** | Segmentos con encabezados y datos | Solicitudes/respuestas con encabezados HTTP y cuerpo de datos |
| **Puerto**     | Puede usar cualquier puerto (usualmente 80 para HTTP, 443 para HTTPS) | Normalmente usa el puerto 80 (HTTP) o 443 (HTTPS) |

En conclusión, **TCP** proporciona el mecanismo subyacente que permite a **HTTP** funcionar. Mientras **TCP** garantiza la entrega confiable de los datos, **HTTP** define cómo se estructuran y manejan las solicitudes y respuestas que intercambiamos al navegar por la web.


----

# FTP: Protocolo Transferencia Ficheros
El **FTP (File Transfer Protocol)** es un protocolo diseñado para la **transferencia de archivos** entre un cliente y un servidor. A diferencia de otros protocolos, **FTP** utiliza **dos conexiones TCP en paralelo**: una para el **control** y otra para la **transferencia de datos**. A continuación, te explico cada uno de sus elementos de forma más clara:

### Conexión de Control (Puerto 21)
La **conexión de control** es la que se utiliza para gestionar la sesión FTP, enviando y recibiendo **comandos** entre el cliente y el servidor. Este canal permanece **abierto durante toda la sesión**, es decir, **es persistente**.

- **Comandos transmitidos**: Se envían comandos como *nombre de usuario, contraseña, solicitar directorios, pedir archivos, cerrar la sesión, etc.*.
- **Formato de los comandos**: Los comandos son legibles, utilizando texto ASCII de 7 bits, y se componen de palabras de 4 letras en mayúsculas seguidas de parámetros (si los hay). Ejemplo: `USER`, `PASS`, `LIST`, `RETR`.
- **Respuestas del servidor**: El servidor responde con **códigos de 3 dígitos** (que indican el resultado de los comandos) acompañados de una **explicación en texto**. Ejemplo: `230 User logged in, proceed.`

La conexión de control **se mantiene activa** durante toda la sesión de FTP, incluso cuando no se están transfiriendo datos.

### Conexión de Datos (Puerto 20)
La **conexión de datos** se encarga de transferir los archivos o listas de directorios entre el cliente y el servidor. A diferencia de la conexión de control, esta conexión **no es persistente**, es decir, **se abre y se cierra** cada vez que se necesita transferir un archivo o realizar alguna operación que implique datos (como listar directorios).

- **Datos transmitidos**: Puede ser el contenido de los archivos que se están transfiriendo o el resultado de comandos como `LIST` (que devuelve un listado de archivos y directorios).
- **Formato de transmisión**: Los datos se transmiten en **binario**, lo que permite transferir cualquier tipo de archivo (texto, imágenes, vídeos, etc.) sin pérdida de información.
- **Apertura y cierre**: Cada vez que se necesita enviar o recibir un archivo, se establece una nueva conexión TCP para los datos y se cierra al finalizar la transferencia.

### Protocolo con Estado
**FTP es un protocolo con estado**, lo que significa que el servidor mantiene información sobre la sesión mientras está activa. Entre los datos que guarda están:

- El **nombre del usuario** que ha iniciado sesión.
- El **directorio actual** en el que el usuario está navegando.
- Otros detalles que permiten al servidor recordar el contexto de la sesión hasta que el usuario cierra la conexión.

Esto es necesario para que el servidor pueda gestionar múltiples usuarios y archivos de forma ordenada.

### Comandos y Respuestas en FTP
Los **comandos FTP** que envía el cliente son cadenas de texto simples, normalmente de una **palabra de cuatro caracteres** en mayúsculas (como `USER`, `PASS`, `LIST`, `RETR`, `STOR`), y cada uno va acompañado de una acción específica.
![[archivos/imagenes/Pasted image 20241012130721.png]]

Por ejemplo:
- `USER <nombre>`: Enviar el nombre de usuario para autenticar.
- `PASS <clave>`: Enviar la contraseña.
- `LIST`: Listar los archivos del directorio actual.
- `RETR <archivo>`: Descargar un archivo desde el servidor.
- `STOR <archivo>`: Subir un archivo al servidor.

Las **respuestas del servidor** siguen un formato estándar de **códigos de tres dígitos**, que indican el estado de la operación, seguidos de un mensaje explicativo:

- `200`: Operación exitosa.
- `230`: Usuario autenticado correctamente.
- `550`: Error, archivo no encontrado o sin permisos.
![[archivos/imagenes/Pasted image 20241012130805.png]]

### Seguridad en FTP
Una de las limitaciones importantes de FTP es que **no cifra los datos**, incluyendo el **nombre de usuario y la contraseña** que se envían por la red. Esto significa que, en una red insegura, alguien podría interceptar y leer esa información.

- FTP transmite todo en texto plano, al igual que otros protocolos antiguos como **telnet** o versiones no seguras de **HTTP**.
- Para evitar este problema, se han desarrollado alternativas más seguras como:
  - **SSH (Secure Shell)**: Para una sesión cifrada.
  - **SFTP (Secure File Transfer Protocol)**: Una versión segura de FTP que utiliza SSH para cifrar tanto la conexión de control como los datos.
  - **HTTPS**: Protocolo seguro basado en HTTP, usado principalmente para la transferencia de datos web.

### Resumen de las conexiones en FTP

| **Conexión**      | **Propósito**                                                   | **Puerto** | **Persistencia**  | **Formato de datos**    |
|-------------------|-----------------------------------------------------------------|------------|-------------------|-------------------------|
| **Control**       | Enviar comandos y recibir respuestas                            | 21         | Persistente       | Texto ASCII (legible)   |
| **Datos**         | Transferir archivos o listas de directorios                     | 20         | No persistente    | Binario                 |

En resumen, **FTP** es un protocolo que permite la transferencia de archivos entre un cliente y un servidor, con una conexión dedicada para el control de la sesión y otra para los datos. Aunque es eficiente en su función, su principal desventaja es la **falta de seguridad**, lo que ha llevado al desarrollo de protocolos más modernos y seguros como **SFTP** o **SSH**.

----

# SMTP: Protocolo Transferencia. Correo Sencillo
![[archivos/imagenes/Pasted image 20241012131936.png]]
El **SMTP (Simple Mail Transfer Protocol)** es el protocolo estándar para la **transferencia de correo electrónico** entre servidores. SMTP se encarga de **enviar correos** desde el cliente (el remitente) hacia un servidor de correo, y también entre servidores de correo. Veamos en detalle cómo funciona este protocolo y cómo se integra en el sistema de correo:

## Sistema de Correo: Envío y Recepción
El **sistema de correo electrónico** consta de varias partes:

1. **Agente de usuario (Mail User Agent, MUA)**: Es el programa que los usuarios utilizan para gestionar su correo, como **Outlook**, **Thunderbird** o los clientes de correo de un navegador web (Gmail, Yahoo, etc.). El agente de usuario permite:
   - Escribir correos electrónicos.
   - Enviarlos a través de un servidor de correo.
   - Descargar correos recibidos desde un servidor, usando otros protocolos como **POP3**, **IMAP**, o incluso **HTTP** (en el caso de interfaces web).

   Es importante notar que el **buzón de correo** (donde se almacenan los correos que recibes) no está en el ordenador local, sino en un **servidor remoto**. Esto es útil porque los correos pueden llegar en cualquier momento del día, mientras que el ordenador del usuario no siempre está encendido o conectado a internet.

2. **Servidor de correo (Mail Transfer Agent, MTA)**: Cuando el usuario envía un correo, su agente de usuario lo **transfiere al servidor de correo**. Este servidor de correo se encarga de **procesar** y **enviar** el correo al servidor de destino adecuado. Aquí es donde entra en juego **SMTP**.
   
   El servidor de correo **origen** examina la dirección de destino y utiliza el protocolo **SMTP** para buscar el **servidor de correo destino**. Una vez identificado, transfiere el correo a dicho servidor, donde queda almacenado en el **buzón del destinatario**.

## Funcionamiento de SMTP
**SMTP** está diseñado para facilitar la **comunicación entre servidores de correo**. Aunque teóricamente la comunicación es directa entre dos servidores (origen y destino), en la práctica puede haber **servidores intermedios** que retransmitan los correos, especialmente si hay problemas de red o fallos temporales.

### Proceso de Envío de Correo
1. **El usuario escribe un correo** en su agente de usuario y lo envía.
2. **El agente de usuario** lo transfiere al servidor de correo origen.
3. **El servidor de correo origen** utiliza **SMTP** para establecer una conexión con el servidor de correo destino.
4. **SMTP** transmite el correo del servidor origen al servidor destino, donde el mensaje queda almacenado en el buzón del destinatario.
5. **El destinatario** puede, en cualquier momento, acceder a su correo y descargarlo mediante protocolos como **POP3**, **IMAP**, o directamente a través de un navegador web usando **HTTP**.

![[archivos/imagenes/Pasted image 20241012133330.png]]
## Gestión de Errores y Retransmisiones
SMTP también maneja casos en los que no se puede entregar el correo de inmediato:

- Si el **servidor de correo destino** está **fuera de servicio** o no responde, el servidor origen pone el mensaje en una **cola de espera**.
- El servidor de correo intentará reenviar el correo cada cierto tiempo (generalmente, cada 30 minutos).
- Si después de varios intentos fallidos (normalmente, varios días) el correo no ha podido ser entregado, el servidor envía un **mensaje de error** de vuelta al remitente, informando que el correo no ha podido ser entregado.

## Características Técnicas de SMTP
- **Puerto utilizado**: SMTP utiliza el **puerto 25** para comunicarse entre servidores de correo.
- **Conexiones TCP persistentes**: Al igual que FTP, SMTP mantiene una **conexión TCP persistente** mientras dure la sesión de envío del correo.
- **Formato de los mensajes**: Los correos y comandos que se envían a través de SMTP utilizan **ASCII de 7 bits**, por lo que los mensajes y las instrucciones son legibles por humanos.


## Mensajes SMTP

SMTP (Simple Mail Transfer Protocol) utiliza tres tipos principales de mensajes para la comunicación entre el **cliente** (quien envía el correo) y el **servidor** (quien lo recibe):

1. **Comandos**: Son mensajes enviados desde el cliente al servidor para realizar diversas acciones, como iniciar una conexión, especificar destinatarios o finalizar una sesión. Los comandos siguen un formato de **una sola línea** terminada con *carriage return* y *line feed* (CR+LF), es decir, `\r\n`. Los comandos incluyen:
   - Una palabra en mayúsculas que indica el tipo de acción (comando).
   - Opcionalmente, parámetros adicionales separados por espacios.

   Ejemplo:
   ```
   HELO mail.example.com\r\n
   MAIL FROM:<user@example.com>\r\n
   RCPT TO:<recipient@example.com>\r\n
   DATA\r\n
   ```

2. **Respuestas**: Son mensajes enviados por el servidor en respuesta a los comandos del cliente. Las respuestas contienen:
   - Un **código numérico de tres dígitos** que indica el estado del comando.
   - Opcionalmente, una **frase explicativa** en texto plano que aclara el código de estado.

   Ejemplo:
   ```
   250 OK\r\n
   354 Start mail input; end with <CRLF>.<CRLF>\r\n
   221 Bye\r\n
   ```

3. **Datos**: El contenido real del correo electrónico (texto, imágenes, archivos adjuntos, etc.). Este contenido se envía después del comando `DATA` y puede incluir múltiples tipos de información, pero todo se codifica en **ASCII de 7 bits**. El cliente SMTP finaliza el envío de datos con una línea que contiene solo un punto (`.`), seguido de *CR+LF* (`\r\n`).

## Ejemplo de Transacción SMTP

Una transacción típica entre un cliente (`C`) y un servidor (`S`) se ve así:

```
C: HELO mail.example.com\r\n
S: 250 Hello mail.example.com\r\n

C: MAIL FROM:<user@example.com>\r\n
S: 250 OK\r\n

C: RCPT TO:<recipient@example.com>\r\n
S: 250 OK\r\n

C: DATA\r\n
S: 354 Start mail input; end with <CRLF>.<CRLF>\r\n

C: (contenido del correo)
C: .\r\n
S: 250 OK\r\n

C: QUIT\r\n
S: 221 Bye\r\n
```

En esta transacción:
- El cliente comienza saludando al servidor con el comando `HELO` o `EHLO`.
- Luego, el cliente indica quién es el remitente del correo con `MAIL FROM`, seguido del destinatario con `RCPT TO`.
- El comando `DATA` inicia la transmisión del contenido del correo, que el servidor acepta hasta que el cliente envía una línea que contiene solo un punto (`.`).
- Finalmente, el cliente cierra la sesión con `QUIT`.

## Seguridad en SMTP

SMTP, tal como se diseñó originalmente, es un **protocolo inseguro** porque no solicita autenticación del remitente. Esto significa que cualquier cliente puede conectarse a un servidor SMTP y enviar correos a cualquier destinatario sin identificarse, lo que facilita la creación de **spam** (correos no deseados).

## Comparación entre SMTP y HTTP

1. **Protocolo de demanda vs. oferta**:
   - **HTTP**: Es un protocolo de **demanda**. El cliente solicita un recurso (por ejemplo, un archivo o página web) desde el servidor, y el servidor responde con ese recurso.
   - **SMTP**: Es un protocolo de **oferta**. El cliente (remitente del correo) ofrece un mensaje al servidor de destino para que lo entregue al destinatario.

2. **Codificación de los mensajes**:
   - **SMTP**: Tanto la cabecera como el cuerpo del correo deben estar codificados en **ASCII de 7 bits**.
   - **HTTP**: La cabecera se codifica en ASCII de 7 bits, pero el cuerpo del mensaje puede contener **datos binarios**, como imágenes o archivos multimedia.

3. **Envío de objetos**:
   - **HTTP**: Envía múltiples objetos (por ejemplo, texto, imágenes, archivos adjuntos) en **ficheros separados**. Cada objeto tiene su propia petición.
   - **SMTP**: Todos los objetos de un correo (texto, imágenes, archivos adjuntos) se envían juntos dentro del **mismo mensaje** como un único archivo codificado.

4. **Manejo del estado**:
   - **HTTP**: Es un protocolo **sin estado**. Cada petición es independiente de las demás, lo que significa que el servidor no necesita recordar información de sesiones anteriores.
   - **SMTP**: Es un protocolo **con estado**, ya que el servidor debe recordar en qué fase de la sesión de correo se encuentra (por ejemplo, si ha recibido el remitente y los destinatarios antes de recibir el contenido del correo).
---

# Protocolos de acceso al correo
### Protocolos de Acceso al Correo

Una vez que un correo ha llegado al **buzón de destino**, el siguiente paso es transferirlo al ordenador local del usuario. Para esto, no se utiliza SMTP, ya que este protocolo está diseñado para enviar correos (es un protocolo de oferta) y requeriría que el ordenador local estuviera siempre encendido y conectado a Internet, esperando la llegada de mensajes. Por lo tanto, se han diseñado protocolos específicos para **descargar correos**, siendo **POP3**, **IMAP** y **HTTP** los más comunes. Aquí nos centraremos en **POP3**.
![[archivos/imagenes/Pasted image 20241013162059.png]]
## Funcionamiento de POP3

**POP3** (Post Office Protocol 3) permite a los usuarios descargar correos desde un servidor a su ordenador local. El proceso se basa en **tres tipos de mensajes** que se intercambian entre el **agente de usuario** (cliente) y el **servidor de correo**:

1. **Comandos**: Los comandos enviados desde el cliente al servidor están compuestos por una palabra clave de **4 caracteres** seguida de los parámetros necesarios. Por ejemplo:
   - `USER username` para especificar el nombre de usuario.
   - `PASS password` para ingresar la contraseña.
   - `LIST` para obtener la lista de mensajes en el buzón.

   Ejemplo de un comando:
   ```
   RETR 1\r\n
   ```
![[archivos/imagenes/Pasted image 20241013162321.png]]
2. **Respuestas**: Las respuestas del servidor pueden ser de dos tipos:
   - **Respuestas de estado** que indican si un comando se ha ejecutado correctamente (por ejemplo, `OK` o `ERR`).
   - **Respuestas de datos** que contienen la información solicitada, como la lista de mensajes o el contenido de un correo.
![[archivos/imagenes/Pasted image 20241013162401.png]]

3. **Datos**: Los datos en las respuestas del servidor pueden incluir:
   - La **lista de mensajes** disponibles en el buzón.
   - El **contenido completo** de un correo electrónico, que incluye tanto la cabecera como el cuerpo del mensaje. A diferencia de SMTP, donde cada campo de la cabecera genera un mensaje independiente, en POP3 el correo completo se envía como un único mensaje.

## Características de POP3

- **Puerto**: POP3 utiliza el **puerto 110** para la comunicación.
- **Conexiones persistentes**: Durante una sesión de POP3, se utiliza una única conexión TCP que puede ser mantenida abierta mientras el usuario descarga varios correos. Esto ahorra tiempo y recursos en comparación con abrir y cerrar conexiones repetidamente.
- **Autenticación**: A diferencia de SMTP, que permite enviar correos sin necesidad de una cuenta, POP3 requiere que el usuario tenga una cuenta y una contraseña válidas. Esto significa que el servidor verifica la identidad del usuario antes de permitir el acceso a los correos, lo que ayuda a prevenir el acceso no autorizado.

## Modos de Operación de POP3

- **Descargar y borrar**: Con el comando `RETR` seguido de `DELE`, los correos son descargados y luego eliminados del servidor.
- **Descargar y mantener**: Solo se utiliza el comando `RETR`, permitiendo que los correos permanezcan en el servidor después de ser descargados.

## Resumen

POP3 es un protocolo eficiente y seguro para la transferencia de correos, permitiendo a los usuarios gestionar su correspondencia sin necesidad de mantener sus dispositivos siempre conectados. Su estructura de comandos y respuestas proporciona un método sencillo para acceder a los mensajes, lo que lo convierte en una opción popular para el acceso a correos en muchos entornos.

----

# DNS: Servicio de Nombres de Dominio
### DNS: Servicio de Nombres de Dominio

El **Sistema de Nombres de Dominio (DNS)** es fundamental para el funcionamiento de Internet, ya que se encarga de traducir los nombres de host (como `www.ejemplo.com`) a direcciones IP (como `192.0.2.1`) y viceversa. Este sistema permite que los usuarios accedan a sitios web utilizando nombres fáciles de recordar en lugar de tener que memorizar largas cadenas de números.

#### Elementos del DNS

1. **Servidores de Nombres**: El DNS se compone de numerosos servidores de nombres distribuidos por Internet. Estos servidores trabajan en conjunto para traducir los nombres de dominio en direcciones IP.

2. **Base de Datos Distribuida**: La base de datos del DNS está organizada de manera jerárquica. Por ejemplo, para la traducción del nombre de host `jerez.dec.usc.es`, la jerarquía es la siguiente:
   - **Servidor de Primer Nivel**: Maneja el dominio de nivel superior (TLD), como `.es`.
   - **Servidor de Segundo Nivel**: Maneja el dominio `usc`.
   - **Servidor de Tercer Nivel**: Maneja el dominio `dec`.
   - Cada nivel tiene sus propios servidores responsables de almacenar y proporcionar la información correspondiente.

3. **Protocolo de Consulta**: El DNS utiliza un protocolo que permite a los hosts (computadoras) solicitar traducciones a los servidores de nombres y que los servidores intercambien información entre ellos.

#### Protocolo Sin Conexión

- **UDP**: DNS utiliza el protocolo **UDP** (User Datagram Protocol), específicamente el **puerto 53**. Esto se debe a que DNS no necesita mantener el estado de las conexiones. Cada host tiene una lista de direcciones de servidores de nombres, generalmente configurada durante la instalación del sistema operativo.
  
- **Mecanismo de Consulta**: Cuando un host necesita realizar una traducción, se dirige al primer servidor de la lista. Si no recibe respuesta, se mueve al siguiente, y así sucesivamente. Esta estrategia permite que DNS sea más eficiente, ya que, en lugar de intentar reestablecer una conexión con el primer servidor, busca otros.

#### Servicios Proporcionados por DNS

1. **Traducción de Nombres**: Realiza traducciones de nombres de hosts a direcciones IP y viceversa, permitiendo obtener alias de hosts.

2. **Información de Servidores Autorizados**: Indica qué servidor está autorizado para proporcionar información sobre un dominio específico, lo que es crucial para la administración de dominios.

3. **Alias de Servidores de Correo**: Permite simplificar direcciones de correo electrónico. Por ejemplo, `usc.es` puede ser un alias para el servidor de correo `smtp.usc.es`, facilitando la escritura de direcciones como `peptio@usc.es`.

4. **Distribución de Carga**: Un mismo nombre de host puede tener múltiples direcciones IP asociadas, lo cual es útil para servidores espejo (servidores que tienen el mismo contenido). DNS puede configurarse para devolver estas direcciones IP de manera rotativa.

#### Tipos de Servidores DNS

1. **Servidores Locales**: Son los que manejan las consultas de los hosts en una red local. Cada host tiene una lista de estos servidores, que a menudo son proporcionados por el ISP (Proveedor de Servicios de Internet). El host comienza consultando el primer servidor de la lista.

2. **Servidores Autorizados y No Autorizados**: 
   - **No Autorizados**: Son instalados por particulares o empresas y no están registrados en el sistema global del DNS. Solo se conocen internamente y se utilizan dentro de una red local.
   - **Autorizados**: Deben ser registrados en el DNS global para que los nombres de los hosts sean accesibles desde Internet. Estos servidores son típicamente proporcionados por el ISP y cada host debería estar registrado en al menos dos servidores autorizados para garantizar fiabilidad.

3. **Servidores Raíz**: Hay un número limitado de servidores raíz en Internet que proporcionan información sobre los dominios de nivel superior (como `.com`, `.org`, `.es`). Si se pregunta a un servidor raíz sobre el dominio `.es`, proporcionará información sobre servidores de nombres en ese dominio.

4. **Servidores Intermedios**: Estos servidores proporcionan información sobre dominios de niveles intermedios (como `usc.es`). Si se le pregunta a un servidor en la raíz sobre el dominio `usc.es`, puede proporcionar información sobre un servidor en la Universidad de Santiago.

> [!INFO]
> Un **dominio** es un nombre que identifica a un sitio web en Internet. Es una parte fundamental de la dirección de un sitio web y se utiliza para acceder a recursos en la red de manera fácil y comprensible para los usuarios. Por ejemplo, en la URL `www.ejemplo.com`, `ejemplo.com` es el dominio.
> 

#### Tipos de Consultas

- **Consultas Recursivas**: En este tipo de consulta, cada servidor de nombres se encarga de interrogar al siguiente hasta obtener la respuesta final. Esto permite que el servidor de nombres local maneje la totalidad de la consulta.
![[archivos/imagenes/Pasted image 20241013171148.png]]

- **Consultas Iterativas**: En este caso, el servidor de nombres local se pone en contacto con todos los servidores necesarios para obtener la información. A diferencia de las consultas recursivas, el servidor local no delega la consulta a otros servidores.
![[archivos/imagenes/Pasted image 20241013171228.png]]

#### Caché DNS

Cuando un servidor DNS obtiene una traducción, almacena una copia en su memoria local (disco o RAM) para futuras consultas. Esta caché se utiliza para responder a consultas repetidas de manera más rápida. Las entradas de la caché se eliminan después de un tiempo específico (generalmente, cada dos días).

#### Mensajes DNS

Existen **dos tipos de mensajes** en el DNS: **Consultas** y **Respuestas**. Ambos mensajes tienen un formato similar, que consta de una cabecera con información de control y un cuerpo que contiene las consultas y respuestas.

1. **Cabecera**: Contiene 6 campos, algunos de los cuales son en binario:
   - **Identificación**: Un número de 16 bits que identifica la consulta, permitiendo que un host realice múltiples consultas simultáneamente.
   - **Señales**: 4 bits que indican el tipo de mensaje (consulta o respuesta), si la respuesta proviene de un servidor autorizado, si se requiere una consulta recursiva, etc.
   - **Tamaño de Campos del Cuerpo**: Indica la cantidad de preguntas, respuestas, servidores autorizados y datos adicionales en el mensaje.

2. **Cuerpo**: Consta de 4 campos:
   - **Cuestiones**: Preguntas que incluyen el nombre o dirección IP a traducir.
   - **Respuestas**: Respuestas obtenidas, como pares de nombres de host y direcciones IP. Un nombre de host puede corresponder a múltiples direcciones IP.
   - **Servidores Autorizados**: Indica los servidores de nombres autorizados que se pueden consultar para un dominio específico.
   - **Información Adicional**: Incluye datos que no fueron solicitados explícitamente.
 ![[archivos/imagenes/Pasted image 20241013171414.png]]

**TTL (Time to Live)**: Es el tiempo durante el cual una respuesta es considerada válida antes de que se requiera una nueva consulta.
![[archivos/imagenes/Pasted image 20241013171434.png]]

---

# Distribución de contenidos
La distribución de contenidos se refiere a las diversas técnicas utilizadas para gestionar y entregar contenidos digitales (como páginas web, archivos de audio, video, etc.) de manera eficiente, reduciendo el tiempo de carga y mejorando la experiencia del usuario. A continuación, se explican los conceptos clave en esta área:

## 1. Introducción a la Distribución de Contenidos

Los accesos a servidores centralizados pueden ser lentos por dos razones principales:
- **Congestión de red**: El camino que siguen los mensajes puede estar congestionado, lo que provoca retrasos.
- **Sobrecarga del servidor**: Un servidor puede estar manejando demasiadas peticiones al mismo tiempo.

Para abordar estas limitaciones, se utilizan métodos alternativos a los servidores centralizados. En lugar de almacenar todos los contenidos en un solo servidor, se distribuyen y duplican en diferentes ubicaciones geográficas, dirigiendo las peticiones al servidor que ofrezca el menor tiempo de respuesta.

### Opciones para la Distribución de Contenidos

1. **Caché web (servidor proxy)**
2. **Redes de distribución de contenidos (CDN)**
3. **Redes P2P (de igual a igual)**
![[archivos/imagenes/Pasted image 20241013172959.png]]
---

## 2. Caché Web (Servidor Proxy)

La caché web implica la utilización de un servidor intermedio, conocido como **proxy**, que gestiona todas las peticiones web de los usuarios en una red. Este servidor proxy normalmente es proporcionado por el proveedor de servicios de Internet (ISP). Aquí se explica el funcionamiento:
![[archivos/imagenes/Pasted image 20241013173230.png]]
- **Funcionamiento**: 
  - Los usuarios envían sus peticiones web al proxy, que luego redirige esas solicitudes a los servidores web de destino.
  - Cuando el proxy recibe el contenido de los servidores, lo almacena en su caché y lo reenvía a los usuarios.
  - Las próximas peticiones para el mismo contenido se satisfacen a partir de la caché local, mejorando significativamente el tiempo de respuesta.
  
- **Configuración**: 
  - Los usuarios deben configurar sus navegadores para utilizar el servidor proxy, indicando la dirección del mismo.
  
- **Jerarquía de Caché**: 
  - Puede haber un esquema jerárquico de proxies, donde varios proxies se comunican entre sí para optimizar aún más la distribución.

![[archivos/imagenes/Pasted image 20241013173336.png]]

---

## 3. Redes de Distribución de Contenidos (CDN)

Las **CDN** son empresas que poseen una infraestructura de múltiples servidores distribuidos globalmente. Estas empresas no crean contenido, sino que alquilan su infraestructura a otras organizaciones. Por ejemplo, Akamai replica contenidos de sitios como El País en sus centros de hospedaje.

### Técnicas de Acceso a Contenidos en una CDN:

- **Redirección de Objetos**: 
  - Los documentos base de un sitio web están en el servidor del cliente, pero contienen enlaces que redirigen a los objetos almacenados en los servidores CDN.
  
- **Balanceo de Cargas mediante DNS**: 
  - Al traducir un nombre de dominio a una dirección IP, el DNS selecciona automáticamente el servidor CDN más cercano o rápido.

---

## 4. Redes P2P (de Igual a Igual)

Las **redes P2P** permiten a los usuarios actuar tanto como clientes como servidores, compartiendo archivos entre sí. Al unirse a una red P2P, los usuarios pueden descargar y compartir contenido desde sus propios discos duros. 
![[archivos/imagenes/Pasted image 20241013173656.png]]

### 1. Directorio Centralizado

#### Funcionamiento

- **Estructura**: En este modelo, un único host en Internet se encarga de construir y almacenar el directorio de contenidos. Este host centralizado se convierte en el punto de referencia para todos los usuarios de la red P2P.
  
- **Interacción del Usuario**: Cuando un usuario inicia la aplicación P2P (como Napster), primero se conecta al host central. Este usuario envía su lista de archivos compartidos al servidor central, que luego agrega estos datos al directorio general.

- **Consulta de Contenidos**: Cuando un usuario busca un archivo, su consulta es enviada al host central, que responde con las direcciones IP de otros usuarios que tienen el contenido solicitado. Este proceso permite que los usuarios se conecten directamente entre sí para compartir archivos.

- **Actualización del Directorio**: El directorio se actualiza constantemente. Si un usuario obtiene un contenido, su estado cambia a servidor del mismo, y si deja de estar activo, se elimina de la base de datos.

#### Problemas

1. **Único Punto de Fallo**: Si el host central falla (por ejemplo, se apaga o es atacado), toda la red se vuelve inoperativa, ya que no hay un respaldo para las peticiones.

2. **Cuello de Botella**: El servidor central debe manejar un alto volumen de tráfico, lo que puede provocar lentitud en las respuestas, especialmente si hay millones de usuarios realizando consultas simultáneamente.

3. **Infracción de Copyright**: Al ser un host centralizado, puede ser objeto de demandas legales. Si el host es propiedad de una empresa, esta puede ser responsable del contenido compartido en su plataforma.

---

### 2. Directorio Descentralizado

#### Funcionamiento

- **Estructura**: En este modelo, el directorio de archivos se distribuye entre varios usuarios en lugar de estar concentrado en un solo host. Algunos de estos usuarios son designados como "líderes" del grupo, basándose en criterios como velocidad de conexión y antigüedad en la red.
![[archivos/imagenes/Pasted image 20241013173858.png]]
- **Responsabilidad de los Líderes**: Cada líder gestiona consultas dentro de su grupo asignado. Si no puede resolver una consulta, la redirige a otros líderes conectados. Esto permite una gestión más eficiente de las peticiones y reduce la carga en un único punto.
![[archivos/imagenes/Pasted image 20241013173929.png]]
- **Red de Superposición**: La red de usuarios se organiza en una estructura jerárquica que permite que la información fluya entre los diferentes líderes, lo que mejora la resiliencia de la red.

#### Ventajas

1. **Eliminación del Punto de Fallo**: Si un líder falla, otros pueden asumir su papel, lo que significa que la red sigue operando sin interrupciones significativas.

2. **Menor Congestión**: Al distribuir las consultas y los contenidos, se reduce la carga en un único servidor, lo que minimiza la latencia y mejora el tiempo de respuesta.

3. **Menos Riesgo Legal**: Al no haber un solo propietario del contenido, es más difícil para las autoridades demandar a un único ente.

---

### 3. Inundación de Consultas

#### Funcionamiento

- **Estructura**: En este modelo, no existe un directorio; en cambio, las consultas se transmiten de usuario a usuario. Cada usuario retransmite su búsqueda a otros usuarios conectados, hasta que se encuentra el contenido solicitado.

- **Estrategia de Búsqueda**: Las consultas se inician desde un usuario y se envían a todos los nodos vecinos en la red. Cada nodo que recibe la consulta también la retransmite a sus vecinos, creando un "efecto de inundación".

#### Problemas

1. **Alto Tráfico**: Este método puede generar un tráfico enorme en la red, ya que las consultas pueden inundar todos los nodos, lo que puede causar congestión y ralentización.

2. **Limitación de Profundidad**: Para mitigar el problema del tráfico, se puede limitar la profundidad de la inundación. Esto significa que las consultas solo se propagan hasta un número específico de nodos. Cuando se alcanza ese límite, la búsqueda se detiene.

#### Ejemplo

- **Gnutella**: Es un ejemplo de red P2P que utiliza este enfoque. Aunque permite una búsqueda directa de contenido, la inundación de consultas puede resultar en un uso ineficiente del ancho de banda.

---

### 4. Descarga de Archivos

#### Segmentación de Descargas

- **Eficiencia**: En aplicaciones como BitTorrent, la descarga de archivos se puede mejorar al dividir el archivo en segmentos. Un usuario puede descargar un segmento y, mientras tanto, compartirlo con otros usuarios, lo que permite que el archivo completo se descargue más rápidamente y se comparta entre varios nodos simultáneamente.
![[archivos/imagenes/Pasted image 20241013174117.png]]
### Conclusión

Las redes P2P, con sus diferentes arquitecturas de directorio, ofrecen maneras únicas de distribuir y compartir contenidos. Mientras que los sistemas centralizados presentan ventajas en términos de simplicidad, los sistemas descentralizados y de inundación ofrecen más resiliencia y eficiencia en la distribución, aunque también con sus propios desafíos. Esto resalta la evolución de las aplicaciones P2P y su adaptación a las necesidades de los usuarios y a la infraestructura de Internet.
