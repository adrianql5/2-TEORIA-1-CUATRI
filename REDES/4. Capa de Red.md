[[archivos/bibliografia/Tema4Redes.pdf|Tema4Redes]]
[[archivos/bibliografia/[1] Redes de Computadores.pdf|[1] Redes de Computadores]]

# 4.1 Introducción
La **capa de red** en el modelo de Internet es la encargada de transportar los datos desde un host de origen hasta un host de destino, controlando el **encaminamiento y el reenvío de paquetes** a través de la red. A continuación se describe de forma detallada su funcionamiento, incluyendo la encapsulación, los protocolos clave y el control de errores y flujo.
![[archivos/imagenes/Pasted image 20241107162131.png]]

> [!Recordatorio]
> ![[archivos/imagenes/Pasted image 20241108205726.png]]

### Conceptos
#### Host de Origen y Host de Destino
- En el **host de origen**, la capa de red:
  - **Recibe un paquete** de la capa de transporte, que encapsula los datos de la aplicación (por ejemplo, el segmento de TCP o UDP).
  - **Encapsula el paquete** en un datagrama IP, que contiene la información necesaria para su entrega, como la dirección de origen y destino.
  - **Entrega el datagrama a la capa de enlace**, que lo transmitirá físicamente al siguiente nodo de la red.

- En el **host de destino**, el proceso es inverso:
  - **Desencapsula el datagrama** recibido, extrayendo el paquete de la capa de transporte.
  - **Entrega el segmento a la capa de transporte**, que se encarga de reensamblar los datos y entregarlos a la aplicación correspondiente.

#### Routers
Los **routers** juegan un papel crucial en la capa de red. Aunque no interactúan directamente con las capas de transporte o aplicación (excepto para control o gestión de red), manejan el **reenvío y el encaminamiento de los datagramas** basándose en la dirección IP de destino y en su **tabla de reenvío**.

#### Reenvío
**Reenvío (Forwarding)**: Cuando un router recibe un paquete, utiliza la dirección de destino en la **cabecera** del datagrama y la consulta en su **tabla de reenvío** para decidir la **interfaz de salida** a través de la cual enviará el paquete. Este proceso ocurre en cada router a lo largo de la ruta hasta el destino final.

#### Encaminamiento
**Encaminamiento (Routing)**: Es el proceso de determinar la **mejor ruta** para los paquetes que se envían de un emisor a un receptor. Este proceso es dinámico y utiliza **algoritmos de encaminamiento** que construyen y actualizan las **tablas de reenvío** en cada router.

#### Tablas de reenvío
  **Tablas de reenvío**: Estas tablas almacenan la información necesaria para el reenvío de paquetes, indicando la interfaz de salida correcta para cada destino. Los valores en estas tablas son determinados por los protocolos y algoritmos de encaminamiento.

#### Protoclos
- **Protocolo IP (Internet Protocol)**: Es el protocolo principal de la capa de red en Internet. Los paquetes se encapsulan en **datagramas IP** y se envían sin garantía de entrega (best effort). Esto implica que los paquetes pueden perderse, duplicarse o llegar desordenados.

- **ICMP (Internet Control Message Protocol)**: Es un protocolo auxiliar de IP que se utiliza para enviar **mensajes de error y diagnóstico**. Por ejemplo, si un datagrama no puede ser entregado, el router o el host de destino puede enviar un mensaje ICMP de error al host de origen para informarle del problema. Algunos ejemplos de mensajes ICMP incluyen los errores de destino inalcanzable y las peticiones de eco (usadas en el comando `ping`).

- **DHCP (Dynamic Host Configuration Protocol)**: Este protocolo permite que un dispositivo obtenga automáticamente una dirección IP y otros parámetros de configuración necesarios para acceder a la red. Esto facilita la conexión de dispositivos sin necesidad de configuración manual de direcciones IP.

- **NAT (Network Address Translation)**: Es una técnica que permite que múltiples dispositivos en una red local compartan una sola dirección IP pública. NAT es especialmente útil para redes domésticas y oficinas, donde varios dispositivos necesitan acceder a Internet pero no tienen cada uno su propia IP pública.

#### Control de Errores y Congestión
- **Suma de comprobación de la cabecera**: Para detectar errores en la cabecera de un paquete IP, se utiliza una **suma de comprobación** que verifica la integridad de los datos. Si la suma de comprobación no coincide en el receptor, el paquete se descarta.

- **Control de congestión**: Si hay demasiados paquetes en tránsito, los routers pueden **descartar paquetes** para evitar la congestión en la red. Aunque IP no implementa control de congestión, esto es gestionado en capas superiores mediante protocolos como TCP, que ajusta su velocidad de transmisión en función de la capacidad de la red.

- **Calidad de Servicio (QoS)**: Aunque la capa de red no ofrece garantías de entrega, QoS permite priorizar ciertos tipos de tráfico (como multimedia) en las redes modernas. Esto se gestiona generalmente en niveles superiores.

- **Seguridad**: Originalmente, IP no tenía mecanismos de seguridad. Sin embargo, con el tiempo se han añadido tecnologías como IPsec, que permite la **autenticación y cifrado** del tráfico IP, transformando el servicio de conexión sin estado en uno con una capa de seguridad añadida.


La **capa de red** permite la transmisión de paquetes entre hosts a través de routers, usando técnicas de **encapsulación, reenvío y encaminamiento**. La red IP es no fiable y sin estado, proporcionando un servicio de **mejor esfuerzo**. Gracias a protocolos auxiliares como **ICMP, DHCP y NAT**, y mecanismos de control de errores y congestión, la capa de red es capaz de mantener la integridad y eficiencia del flujo de paquetes en redes de gran escala como Internet.

# 4.2 Redes de Conmutacion de Paquetes
Las **redes de conmutación de paquetes** son fundamentales para la comunicación en redes modernas, como Internet. Se emplean para transmitir datos en forma de paquetes a través de la red, y se pueden clasificar en **redes de datagramas** y **redes de circuitos virtuales**. Ambas tienen características distintas, pero ambas permiten que la comunicación entre diferentes dispositivos ocurra de manera eficiente. A continuación, se describen con detalle estos dos tipos de redes, sus características y ejemplos de funcionamiento:

![[archivos/imagenes/Pasted image 20241107162613.png]]

Las **redes de conmutación de paquetes** permiten transmitir datos dividiéndolos en paquetes pequeños. Estos paquetes viajan a través de la red de manera independiente, siguiendo rutas que pueden variar de un paquete a otro. El término "conmutación de paquetes" se refiere al proceso de enviar estos paquetes a través de varios nodos (por ejemplo, routers) que los redirigen hasta su destino.

Existen dos tipos principales de redes de conmutación de paquetes: **redes de datagramas** y **redes de circuitos virtuales**.

### 4.2.1 **Redes de Datagramas:**
Una **red de datagramas** es un tipo de red de conmutación de paquetes donde los paquetes se envían de manera independiente, sin necesidad de establecer una ruta fija entre el origen y el destino antes de la transmisión. Cada paquete incluye la dirección IP del destino en su cabecera, lo que permite que los routers encaminen los paquetes de manera independiente según su propia tabla de enrutamiento.

#### Características de las Redes de Datagramas:
1. **Capa de Red en Internet (IP):**  
   En Internet, la capa de red se basa en el **Protocolo de Internet (IP)**, el cual utiliza el modelo de **datagramas**. Cada paquete contiene información suficiente en su cabecera (como la dirección IP de destino) para que los routers puedan determinar a dónde debe enviarse el paquete siguiente.
  
2. **Sin Estado:**  
   Los **routers** en una red de datagramas no mantienen información sobre el estado de las conexiones previas o el tráfico pasado. Cada paquete es tratado como una entidad independiente, y el router no sabe nada sobre los paquetes que llegaron antes o después. Esto significa que no hay un "seguimiento" del flujo de paquetes.

3. **Red No Fiable (Best Effort):**  
   El servicio proporcionado por las redes de datagramas es de **mejor esfuerzo** (*best effort*). Esto implica que **no se garantiza la entrega de los paquetes, su orden ni el tiempo en que llegarán** al destino. Los paquetes pueden llegar desordenados, con retraso o incluso perderse durante la transmisión debido a problemas como congestión en la red.

4. **Encaminamiento de Paquetes:**  
   Los routers toman decisiones de encaminamiento en función de la dirección IP de destino contenida en la cabecera de cada paquete. Estas decisiones se toman consultando las **tablas de reenvío** de los routers, las cuales pueden actualizarse dinámicamente mediante protocolos de enrutamiento (como **OSPF** o **BGP**).

5. **Interconexión de Redes de Diferentes Tecnologías:**  
   La red de datagramas IP permite que diferentes tipos de redes de enlace de datos (Ethernet, Wi-Fi, 4G, etc.) se conecten entre sí, lo que facilita la **interconexión de redes heterogéneas**.


![[archivos/imagenes/Pasted image 20241107162749.png]]


### 4.2.2 **Redes de Circuitos Virtuales:**
En contraste con las redes de datagramas, las **redes de circuitos virtuales** requieren la **planificación de una ruta fija** antes de que los datos puedan ser enviados. Este proceso implica la creación de un **circuito virtual** (CV), que es una ruta preestablecida que todos los paquetes siguen durante la comunicación.

#### Características de las Redes de Circuitos Virtuales:
1. **Establecimiento de Conexión (Circuito Virtual):**  
   Antes de que los paquetes de datos sean enviados, se establece una conexión en la que los routers **planifican una ruta fija** para todo el flujo de paquetes entre el origen y el destino. Los paquetes de datos, una vez la ruta esté establecida, incluyen un **identificador de circuito virtual (VCI)** en la cabecera, que los routers utilizan para reencaminar los paquetes.


2. **Mantenimiento de Estado en los Routers:**  
   A diferencia de las redes de datagramas, los routers en una red de circuitos virtuales mantienen **información de estado** acerca de las rutas y las conexiones activas. Cada router tiene una **tabla de circuitos virtuales** que almacena los identificadores de los circuitos virtuales y las interfaces de salida correspondientes.

3. **Construcción de la Tabla de Circuitos Virtuales:**  
   El proceso de creación de un circuito virtual comienza cuando el emisor envía una **petición de llamada** al receptor. A medida que esta solicitud pasa por los routers, cada uno de ellos asigna un **identificador de circuito virtual (VCI)** y actualiza su tabla de circuitos.

4. **Reenvío y Establecimiento del Circuito:**  
   Una vez que la conexión ha sido establecida, los paquetes subsiguientes llevan el identificador del circuito (VCI). Los routers no necesitan volver a determinar la ruta, ya que esta ha sido preestablecida, y pueden utilizar el **VCI** para encontrar la interfaz de salida correcta.

![[archivos/imagenes/Pasted image 20241107162941.png]]
---

## **Resumen Comparativo:**

| Característica | **Redes de Datagramas** | **Redes de Circuitos Virtuales** |
|----------------|------------------------|---------------------------------|
| **Establecimiento de Ruta** | Dinámico, cada paquete tiene su propia ruta. | Estática, se establece una ruta fija. |
| **Estado de los Routers** | Sin estado, no mantienen información de paquetes previos. | Con estado, mantienen información de las conexiones. |
| **Identificador de Ruta** | Basado en la dirección IP de destino. | Basado en un identificador de circuito virtual (VCI). |
| **Confiabilidad** | No fiable, no se garantiza la entrega, orden o tiempo. | Más fiable, pero depende de la ruta establecida. |
| **Ejemplo** | Enrutamiento de un paquete en Internet. | Conexión telefónica en una red de conmutación de circuitos. |

Ambos modelos tienen aplicaciones diferentes según las necesidades de la red. Las **redes de datagramas** son más flexibles y escalables, lo que las hace ideales para Internet, mientras que las **redes de circuitos virtuales** proporcionan una calidad de servicio más consistente y son más adecuadas para aplicaciones que requieren un flujo continuo de datos, como las videollamadas o las comunicaciones en tiempo real.

# 4. 3 Algoritmos de Encaminamiento
Los **algoritmos de enrutamiento** son fundamentales para determinar el camino más eficiente que deben seguir los paquetes de datos desde un origen hasta un destino en una red. Estos algoritmos se basan en el concepto de **grafos**, donde los **routers** son los **nodos** y los **enlaces** entre ellos son las **aristas**. El coste de un enlace puede ser determinado por diversos factores, como la distancia, la velocidad, el nivel de congestión o incluso el coste económico del enlace.

### Clasificación de los algoritmos de enrutamiento
1. **Algoritmos globales (de estado de los enlaces, EE)**:
   - Estos algoritmos requieren que cada nodo tenga **conocimiento completo** sobre la topología de la red, es decir, que conozca todos los enlaces y sus costos.
   - Cada router utiliza esta información para calcular de manera **independiente** su **tabla de enrutamiento**, determinando el camino más corto hacia cada destino.
   - El término "estado de los enlaces" hace referencia al hecho de que los nodos conocen el **estado de todos los enlaces**. Esto implica que el algoritmo realiza un proceso similar al de resolver un problema de **camino mínimo en un grafo ponderado**.
   - **Ejemplo de algoritmo global**: **OSPF (Open Shortest Path First)**, que se utiliza en redes de área extensa (WAN) y utiliza el algoritmo de Dijkstra para encontrar la ruta más corta.

2. **Algoritmos descentralizados (de vector de distancias, VD)**:
   - En estos algoritmos, cada nodo **no tiene conocimiento completo** de la topología de la red. En cambio, **colabora** con los nodos vecinos intercambiando información de distancias.
   - Inicialmente, cada nodo conoce únicamente las distancias a sus nodos vecinos. A través de un proceso iterativo, los nodos comparten y actualizan esta información hasta que todos los nodos tienen conocimiento de las distancias a otros nodos de la red.
   - Este tipo de algoritmo se denomina **vector de distancias** porque cada nodo mantiene un vector con las distancias a los nodos vecinos.
   - **Ejemplo de algoritmo de vector de distancias**: **RIP (Routing Information Protocol)**, que envía mensajes periódicos a los vecinos para actualizar la información de enrutamiento.

3. **Algoritmos estáticos y dinámicos**:
   - **Estáticos**: Solo se actualizan cuando cambia la topología de la red (por ejemplo, si se agregan o eliminan nodos o enlaces) o si se realizan cambios manuales en los parámetros.
   - **Dinámicos**: Se ejecutan de forma periódica y automática para adaptarse a cambios en la red, como modificaciones en la carga o el estado de los enlaces. Los algoritmos dinámicos son más comunes en Internet, ya que permiten adaptarse de forma continua a las variaciones en la red.
   - **Ejemplo de algoritmo dinámico**: **BGP (Border Gateway Protocol)**, que es utilizado para el enrutamiento entre diferentes sistemas autónomos (AS) en Internet.

4. **Algoritmos sensibles a la carga e insensibles a la carga**:
   - **Sensibles a la carga**: El coste de los enlaces cambia dinámicamente en función de la carga o congestión de la red. Esto permite que el algoritmo adapte los caminos de enrutamiento según el tráfico.
   - **Insensibles a la carga**: El coste de los enlaces es constante y no cambia con la congestión de la red. La mayoría de los algoritmos de enrutamiento actuales en Internet son insensibles a la carga.
   - **Problemas de oscilación**: Si un algoritmo es sensible a la carga, pueden ocurrir oscilaciones de enrutamiento, donde los caminos más cortos cambian de forma continua. Un enlace muy congestionado podría tener un coste elevado y ser evitado, pero luego, al liberar la congestión, se vuelve atractivo nuevamente, lo que puede generar fluctuaciones en el enrutamiento.

## 4.3.1 Algortimo de Dijkstra
El **algoritmo de Dijkstra** es un algoritmo de búsqueda de caminos mínimos, utilizado principalmente en redes de computadoras y grafos para encontrar el camino más corto desde un nodo de origen a todos los demás nodos en un grafo ponderado (con costes en los arcos o enlaces). Fue desarrollado por Edsger Dijkstra en 1959. 

El enfoque de **"Forward Search"** del algoritmo de Dijkstra se basa en mantener dos listas: **Confirmado** y **Provisional**, para calcular la tabla de rutas de un nodo a partir de los paquetes de estado de enlace (LSP) recibidos. Cada nodo N quiere calcular su tabla de enrutamiento considerando los enlaces con otros nodos y sus costes. Aquí tienes una explicación detallada del algoritmo siguiendo este enfoque:

### Inicialización:
1. **Lista Confirmada**: Es la lista de nodos cuyo camino mínimo ya se ha encontrado. Se inicia con una entrada para el nodo de partida N con un coste de 0, indicando que el coste para llegar a sí mismo es cero. La entrada tiene el formato `(N, 0, -)`:
   - `(Nodo, Coste, Siguiente Salto)`
   - `-` significa que no hay siguiente salto porque es el nodo de partida.

2. **Lista Provisional**: Es la lista de nodos que aún no han sido definitivamente asignados, pero cuyas distancias son conocidas parcialmente. Inicialmente está vacía.

### Pasos del algoritmo:
1. **Seleccionar el Nodo S**: El algoritmo toma el último nodo añadido a la lista **Confirmado**. Este nodo S es el nodo del que se calcularán las distancias hacia sus nodos vecinos.

2. **Examinar los Vecinos de S**:
   - Para cada vecino V de S (según el LSP de S), el algoritmo calcula el coste para alcanzar V como la **suma del coste de N a S** (que es el coste ya conocido en **Confirmado**) y el **coste de S a V** (que se obtiene del LSP de S).
   - Si V no está en ninguna de las listas (ni **Confirmado** ni **Provisional**), se añade a la lista **Provisional** con la entrada `(V, Coste, S)`, donde `Coste` es la suma de las distancias y `S` es el siguiente salto.
   - Si V ya está en la lista **Provisional**, pero el nuevo coste calculado es menor que el coste previamente almacenado en esa lista, se reemplaza la entrada con el nuevo coste y el siguiente salto correspondiente, que es el nodo S.

3. **Actualizar la Lista Confirmado**:
   - Si la lista **Provisional** está vacía, el algoritmo termina, ya que no hay más nodos por explorar.
   - Si no está vacía, se selecciona el nodo de **Provisional** con el menor coste y se mueve a **Confirmado**, marcando ese nodo como definitivamente alcanzado con el coste mínimo.

4. **Repetir el Proceso**:
   - El proceso se repite desde el paso 1, pero ahora se toma el siguiente nodo con el menor coste en la lista **Provisional**. Este nodo se convierte en el nuevo nodo **S** y se repite el proceso de exploración y actualización.
![[archivos/imagenes/Pasted image 20241107165115.png]]


### Complejidad del Algoritmo:
- Si implementamos el algoritmo con una **estructura de datos eficiente** (como una **cola de prioridad**), la complejidad puede reducirse de O(n²) (con listas simples) a O(n log n) (con colas de prioridad o montículos), donde `n` es el número de nodos en el grafo.

### Resumen del Algoritmo Forward Search:
1. Inicializar **Confirmado** con el nodo de partida con coste 0.
2. Para cada nodo en **Confirmado**, examinar sus vecinos y actualizar la lista **Provisional** con las nuevas distancias.
3. Mover el nodo con la menor distancia de **Provisional** a **Confirmado**.
4. Repetir hasta que todos los nodos hayan sido procesados.

Este algoritmo es una implementación eficiente de Dijkstra y es ampliamente utilizado para calcular las rutas más cortas en redes de computadoras y otras aplicaciones de enrutamiento.

## 4.3.2 Algoritmo de Vector de Distancias (VD)
El **encaminamiento de vector de distancias** es un método descentralizado de enrutamiento, donde cada nodo en una red colabora con sus vecinos para determinar la distancia mínima hacia todos los demás nodos. Este método se basa en la propagación gradual de la información de distancias, permitiendo que cada nodo descubra rutas óptimas hacia todos los destinos mediante iteraciones sucesivas.

### Funcionamiento del Algoritmo
1. **Inicialización**:
   - Cada nodo conoce inicialmente solo el **coste directo** hacia sus vecinos inmediatos. Estos costes directos se almacenan en una **tabla de distancias**, donde cada entrada indica el nodo vecino y el coste del enlace hacia él.
   - No tiene información sobre nodos más alejados en la red.

2. **Intercambio de Información**:
   - Cada nodo comunica periódicamente a sus vecinos lo que sabe hasta ese momento sobre las distancias mínimas hacia los otros nodos.
   - La información compartida es esencialmente el vector de distancias del nodo que envía el mensaje, es decir, sus estimaciones actuales de distancia hacia cada destino posible.
   - Al recibir la información de un vecino, cada nodo calcula nuevas rutas y actualiza sus distancias si encuentra valores menores.

3. **Actualización de Distancias**:
   - Para un nodo $x$ con un vecino $z$, cuyo enlace tiene coste $c_{x,z}$:
      - Si $z$ informa de que su distancia a otro nodo $y$ es $d_{z,y}$, el nodo $x$ puede calcular su distancia a $y$ a través de $z$ como:
      $$
      D_{x,y}(z) = c_{x,z} + d_{z,y}
      $$
      - Esto significa que la distancia de $x$ a $y$ a través de $z$ es la suma del coste del enlace de $x$ a $z$ y la distancia de $z$ a $y$ reportada por $z$.
      - Si el valor $D_{x,y}(z)$ es menor que la distancia almacenada actualmente en la tabla de distancias de $x$ hacia $y$, $x$ actualiza su distancia mínima hacia $y$ y marca a $z$ como el **siguiente salto** hacia $y$.

4. **Iteración y Convergencia**:
   - Este proceso continúa iterativamente: cada nodo sigue intercambiando información con sus vecinos y recalculando rutas hasta que ya no se producen cambios en las tablas de distancias de los nodos.
   - En ese momento, el algoritmo **converge**, y cada nodo ha encontrado el camino más corto hacia todos los otros nodos de la red.

### Ejemplo de Cálculo Paso a Paso
![[archivos/imagenes/Pasted image 20241107171800.png]]
![[archivos/imagenes/Pasted image 20241107171852.png]]

Supongamos que queremos calcular la distancia desde el nodo $A$ al nodo $F$ en una red con los nodos $A$, $B$, $C$, $D$, y $F$, y enlaces entre ellos con ciertos costes:

1. Los nodos $B$, $C$ y $D$ envían a $A$ su distancia al nodo $F$:
   - **Nodo $B$**: $d_{B,F} = 8$
   - **Nodo $C$**: $d_{C,F} = 3$
   - **Nodo $D$**: $d_{D,F} = 3$

2. **Nodo $A$ calcula las distancias** a $F$ a través de cada vecino:
   - $D_{A,F}(B) = c_{A,B} + d_{B,F} = 2 + 8 = 10$
   - $D_{A,F}(C) = c_{A,C} + d_{C,F} = 5 + 3 = 8$
   - $D_{A,F}(D) = c_{A,D} + d_{D,F} = 1 + 3 = 4$

3. $A$ elige el menor de estos valores, lo que indica que la ruta más corta a $F$ es a través de $D$ con un coste de 4. Ahora, $A$ actualizaría su tabla de distancias y comunicaría esta distancia a sus vecinos.

### Ejemplo de Tabla de Distancias y Tabla de Rutas
Después de varias iteraciones y tras la convergencia, las tablas de distancia y rutas de $A$ pueden verse de esta forma:

**Tabla de Distancias de $A$**:

| Destino | Distancia por $B$ | Distancia por $C$ | Distancia por $D$ |
|---------|--------------------|--------------------|--------------------|
| $B$     | 2                 | 8                 | 3                 |
| $C$     | 5                 | 5                 | 3                 |
| $D$     | 4                 | 7                 | 1                 |
| $E$     | 5                 | 6                 | 2                 |
| $F$     | 10                | 8                 | 4                 |

**Tabla de Rutas de $A$**:

| Destino | Siguiente Salto |
|---------|------------------|
| $B$     | $B$             |
| $C$     | $D$             |
| $D$     | $D$             |
| $E$     | $D$             |
| $F$     | $D$             |

### Características Clave
- **Intercambio de Actualizaciones**:
  - Los nodos intercambian actualizaciones periódicamente.
  - También se realiza un intercambio si hay un cambio en el coste de un enlace, lo que permite una actualización rápida en caso de disminución del coste.
  - Sin embargo, un aumento del coste puede causar problemas como **bucles temporales**. Para mitigar esto, se usan técnicas como **horizonte dividido** (dividing horizon) y **envenenado inverso** (poison reverse), que ayudan a evitar que los nodos envíen información que pudiera causar errores de enrutamiento en ciertas configuraciones.

- **Iterativo**:
  - El algoritmo puede requerir varias iteraciones antes de alcanzar la convergencia, especialmente en redes grandes, lo cual lo hace más lento que otros métodos como el encaminamiento por estado de enlace (LS).

- **Menos Robustez ante Errores**:
  - Dado que cada nodo confía en la información de sus vecinos, si un nodo calcula mal sus distancias, los demás nodos pueden propagar estos valores incorrectos, lo que podría afectar toda la red hasta que se corrija el error.


## 4.3.3 Encaminamiento Jerárquico
El **ruteo jerárquico** es una estrategia de enrutamiento utilizada en redes grandes, como Internet, para organizar y simplificar la gestión de los datos y mejorar la eficiencia del enrutamiento. En este enfoque, la red completa se divide en **sistemas autónomos (SA)**, que son zonas o regiones bajo un control administrativo común. Cada sistema autónomo (SA) puede pertenecer, por ejemplo, a una empresa o a una organización, y opera su propia red interna.

### ¿Qué es un Sistema Autónomo (SA)?
Un sistema autónomo (SA) es una porción de la red que:
- Es administrada por una entidad, como una empresa de telecomunicaciones o una red de investigación.
- Tiene sus propias reglas y su propio protocolo de enrutamiento interno. 
- Actúa como una unidad independiente, en el sentido de que los routers dentro de un SA conocen todos los detalles sobre cómo enrutar los paquetes dentro de ese sistema, pero no tienen información detallada de otros SAs.

Ejemplos de sistemas autónomos serían la red de una universidad, la red de una empresa de telecomunicaciones en un país o una red de investigación.
![[archivos/imagenes/Pasted image 20241107172236.png]]
### Funcionamiento del Ruteo Jerárquico
El ruteo jerárquico se basa en dos niveles de enrutamiento: **intra-autónomo** e **inter-autónomo**.

1. **Ruteo Intra-autónomo**:
   - Este tipo de enrutamiento ocurre **dentro de cada SA**. 
   - En cada SA, el administrador de la red puede elegir el protocolo de ruteo que prefiera, como **OSPF** (Open Shortest Path First) o **RIP** (Routing Information Protocol).
   - Los routers dentro de un SA conocen los detalles de enrutamiento de todos los demás routers en el mismo SA, lo cual permite que el tráfico se maneje eficientemente dentro de la red interna.
   - Cada router tiene una tabla de enrutamiento que le indica la mejor ruta para llegar a cada nodo dentro del mismo SA.

2. **Ruteo Inter-autónomo**:
   - Este tipo de ruteo ocurre **entre sistemas autónomos**. 
   - No todos los routers participan en el enrutamiento inter-autónomo, sino que este es manejado únicamente por los **routers pasarela de frontera**. Estos routers también son conocidos como **routers de frontera**.
   - Los routers de frontera son los que gestionan el tráfico de entrada y salida de cada SA, y son los únicos que tienen conocimiento sobre cómo comunicarse con otros SAs.
   - El protocolo de ruteo para el tráfico inter-autónomo debe ser común para todos los sistemas autónomos, ya que los routers de frontera de cada SA deben poder comunicarse usando un mismo protocolo. En Internet, el protocolo estándar para el enrutamiento inter-autónomo es el **BGP** (Border Gateway Protocol).

### Ejemplo de Ruteo Jerárquico
Imagina que tenemos tres sistemas autónomos: 
- **SA1** pertenece a una universidad.
- **SA2** pertenece a una empresa de telecomunicaciones.
- **SA3** pertenece a una red de investigación.

1. **Dentro de SA1** (intra-autónomo): 
   - La universidad usa el protocolo **OSPF** para el enrutamiento dentro de su red.
   - Los routers dentro de SA1 tienen tablas de enrutamiento completas para toda la red de la universidad, pero no saben nada sobre las rutas en SA2 o SA3.
   
2. **Entre SA1, SA2 y SA3** (inter-autónomo):
   - Los routers de frontera en SA1 y SA2 se comunican entre sí usando el protocolo **BGP**.
   - Estos routers de frontera permiten que el tráfico fluya entre SA1 y SA2, y también pueden enrutar el tráfico de SA1 a SA3 a través de SA2, si no hay una conexión directa entre SA1 y SA3.
   - Los routers de frontera intercambian información sobre cómo alcanzar los diferentes SAs y gestionan el tráfico entre ellos.

### Ventajas del Ruteo Jerárquico
- **Escalabilidad**: Los routers solo almacenan información detallada sobre su propio sistema autónomo y un conjunto más simple de rutas para alcanzar otros SAs, lo que reduce la cantidad de información que debe manejar cada router.
- **Flexibilidad**: Cada sistema autónomo puede elegir su protocolo de ruteo interno sin afectar a otros SAs, lo cual permite que cada organización optimice el ruteo dentro de su red.
- **Simplicidad en el tráfico de salida y entrada**: Al centralizar el tráfico externo en los routers de frontera, se facilita la gestión y el control del flujo de datos hacia y desde otros SAs.

### Conclusión
El ruteo jerárquico permite que redes grandes, como Internet, se dividan en secciones manejables. Al combinar el ruteo intra-autónomo para el tráfico dentro de un SA y el ruteo inter-autónomo para el tráfico entre SAs, se logra una estructura de red que puede crecer y adaptarse con facilidad y que reduce la complejidad del enrutamiento global.



# 4.4 Encaminamiento en Internet
El encaminamiento en Internet se basa en protocolos de rutado, que permiten a los routers decidir el mejor camino para enviar paquetes de datos a su destino. Internet se divide en diferentes sistemas autónomos (SA), que son redes administradas de forma independiente. Estos sistemas usan distintos protocolos de rutado para decidir cómo enviar datos tanto dentro del SA (rutado intra-autónomo) como entre SAs (rutado inter-autónomo).

![[archivos/imagenes/Pasted image 20241107181413.png]]

### Principales Protocolos de Rutado
1. **RIP (Routing Information Protocol)**:
   - **Tipo**: Rutado intra-autónomo, basado en vector de distancias (VD).
   - **Funciona sobre**: UDP (puerto 520).
   - **Descripción**: En este protocolo, cada router mantiene una tabla con las distancias a otros routers de la red. RIP intercambia información solo entre routers vecinos, con el costo de cada enlace establecido en 1, y puede enviar paquetes a través de un máximo de 15 saltos. Si un router desea información sobre una ruta, envía un mensaje de petición a sus vecinos y recibe como respuesta una lista de redes destino con su distancia.
   ![[archivos/imagenes/Pasted image 20241107181500.png]]
   - **Ejemplo**: Un router A tiene una tabla con las redes B y C. Si B tiene un costo de 1 y C de 2, el mensaje sería algo como: `red destino: B métrica: 1; red destino: C métrica: 2`.

##### Tabla de Rutas en Linux
Los routers mantienen una **tabla de rutas** que indica por dónde deben enviar los paquetes en función de su destino. En sistemas Linux, esta tabla se puede visualizar con el comando `route`. Ejemplo de una tabla de rutas en Linux:

```plaintext
red destino      máscara       interface gateway        métrica
150.1.0.0      255.255.0.0    wlan0     0.0.0.0 (*)      0
200.1.1.0      255.255.255.0  eth0      0.0.0.0 (*)      0
200.1.2.0      255.255.255.0  eth0      200.1.1.1        1
0.0.0.0 (default) 0.0.0.0     eth0      200.1.1.1        0
```

- **Campo red destino**: Dirección de la red de destino.
- **Máscara**: Determina el rango de direcciones IP que cubre cada entrada.
- **Gateway**: El router al que se envía el paquete si el destino no está directamente conectado.
- **Métrica**: Costo o distancia hacia el destino.

![[archivos/imagenes/Pasted image 20241107181540.png]]


2. **OSPF (Open Shortest Path First)**:
   - **Tipo**: Rutado intra-autónomo, basado en estado de enlace (EE).
   - **Funciona sobre**: Propio protocolo (puerto 89).
   - **Descripción**: En lugar de solo conocer distancias a redes vecinas como en RIP, cada router OSPF tiene un mapa completo de la red. Se intercambia información no solo entre vecinos, sino que se difunde por todo el SA. Esto permite calcular el camino más corto usando el algoritmo de Dijkstra.
   - **Ejemplo**: Un router en una red con tres caminos hacia una misma red destino con costos diferentes (A-B y A-C de costo 5; A-D de costo 3) puede elegir el camino con menor costo (A-D en este caso).
   - **Ventajas**: Soporta múltiples caminos con el mismo costo, y permite la creación de áreas jerárquicas dentro de un SA para una mejor organización.

3. **BGP (Border Gateway Protocol)**:
   - **Tipo**: Rutado inter-autónomo, basado en vector de rutas.
   - **Funciona sobre**: TCP (puerto 179).
   - **Descripción**: Es el protocolo que conecta diferentes SAs y permite el intercambio de información entre ellos. En lugar de solo distancia, BGP intercambia la ruta completa hacia cada destino, lo que permite que los routers elijan rutas con base en políticas de enrutamiento definidas por cada SA. Hay dos versiones: E-BGP (para comunicación entre SAs diferentes) e I-BGP (para comunicación dentro del mismo SA).
   
![[archivos/imagenes/Pasted image 20241107181934.png]]

   - **Ejemplo**: Imagina un mensaje BGP que describe cómo llegar a una red `128.19.4.0/24`. La ruta puede ser algo como `SA1/SA2/SA3/SA4`, lo cual indica el camino exacto que debe tomar el paquete al pasar por diferentes SAs.
   - **Políticas de Rutado**: Un SA puede decidir no enviar datos a un proveedor específico configurando sus routers BGP para que no anuncien rutas hacia ese proveedor.


### Resumen
- **RIP**: Intercambia solo distancias con vecinos, limitado a 15 saltos.
- **OSPF**: Usa un mapa completo de la red y algoritmos avanzados (Dijkstra) para hallar el camino más corto.
- **BGP**: Intercambia rutas completas entre SAs, permitiendo políticas de enrutamiento y decisiones más detalladas.

Este sistema asegura que, dentro de cada SA, la ruta óptima se determina eficientemente, mientras que entre SAs los paquetes siguen rutas específicas que cada operador ha optimizado y controlado según sus políticas.


# 4.5 Protocolo de Internet (IP)
La capa de red en Internet es fundamental para la comunicación entre dispositivos conectados a una red global. Esta capa usa varios elementos que permiten que los datos se envíen y reciban de forma eficaz y estructurada. Los componentes clave en esta capa son:

1. **Protocolo Internet (IP)**: Define el formato de las direcciones IP, los campos de los datagramas, y cómo los routers procesan estos datagramas. Los routers leen estos campos para dirigir el tráfico a su destino correcto.
2. **Protocolo de rutado**: Se encarga de definir cómo los routers deben encontrar el mejor camino para enviar los datos a su destino final.
3. **Protocolo de mensajes de control de Internet (ICMP)**: Es utilizado por los routers y otros dispositivos para comunicar errores y otros mensajes importantes, como los que se usan en comandos como `ping` para verificar la conectividad.

## 4.5.1 Direccionamiento IPv4
Las direcciones **IPv4** son números de 4 bytes (32 bits) que se expresan en un formato de cuatro números decimales separados por puntos, donde cada número representa 1 byte (8 bits). Un ejemplo de dirección IPv4 es `192.168.1.1`.

![[archivos/imagenes/Pasted image 20241108215013.png]]

Cada dispositivo conectado a Internet (hosts, routers, etc.) tiene una dirección IP por cada **interfaz** (punto de conexión a la red). Por ejemplo, en Linux, una interfaz de tarjeta Ethernet puede llamarse `eth0`, una conexión serie `ppp0`, una conexión USB `usb0`, y una conexión inalámbrica `wlan0`.

![[archivos/imagenes/Pasted image 20241107182929.png]]

#### Asignación de Direcciones IP a una Red
Una dirección IP tiene dos partes:
- **Parte de red**: Identifica la red en la que está el dispositivo.
- **Parte de host**: Identifica el dispositivo específico en esa red.

**Clases de Dirección IP**:
Las direcciones IP se agrupan en clases, según los primeros bits de la dirección:

- **Clase A**: Comienza con `0`. Tiene una gran cantidad de hosts por red, ideal para organizaciones grandes. 
- **Clase B**: Comienza con `10`. Es adecuada para empresas grandes y medianas. Ejemplo: `172.16.0.0`.
- **Clase C**: Comienza con `110`. Se utiliza para pequeñas redes. Ejemplo: `192.168.0.0`.
- **Clase D**: Comienza con `1110`, destinada para **multicast** (envío de datos a varios dispositivos).
- **Clase E**: Comienza con `1111`, reservada para usos futuros.

![[archivos/imagenes/Pasted image 20241108215124.png]]

En cada red, las direcciones **0** y **255** están reservadas. La dirección que termina en **0** se usa para identificar la red, y la que termina en **255** se usa para **broadcast** (difusión a todos los dispositivos en la red).

> [!Info]
> En cada red, existe una **dirección de broadcast** que se utiliza para enviar mensajes a **todos los dispositivos de la red al mismo tiempo**. Por ejemplo, si un router necesita enviar una actualización de red o un dispositivo quiere buscar otros dispositivos conectados, puede enviar un mensaje a la dirección de broadcast y todos los equipos dentro de esa red lo recibirán.
> Para calcularla basta con poner todos los bits de la parte de host a 1.
> 

### Subredes
**Subredes** (o **subnets**) son divisiones más pequeñas dentro de una red. Crear subredes permite dividir un bloque grande de direcciones IP en varias redes más pequeñas, cada una con su propio rango de direcciones. Las subredes son útiles para mejorar el rendimiento, la organización y la seguridad en una red. Para subdividir una red en varias subredes usamos **máscaras**.

Una **máscara de red** indica la división entre la parte de red y la parte de host en una dirección IP. Define cuántos bits están dedicados a identificar la red y cuántos quedan para identificar dispositivos en esa red. La máscara de red ayuda a los dispositivos a saber si una IP está dentro de su misma red o en otra, lo que afecta cómo se envían los datos.

>[!Ejemplo]
>Imagina una dirección IP como una gran ciudad con muchas calles y casas (dispositivos). La máscara de red sería el "código postal" de esa ciudad, que la divide en vecindarios. Cada vecindario es una subred, y dentro de cada subred puedes identificar cada casa con una dirección específica.

Ejemplos de máscaras comunes en formato decimal:
- `/16` → `255.255.0.0`: Los primeros 16 bits definen la red, y los últimos 16 son para hosts.
- `/24` → `255.255.255.0`: Los primeros 24 bits definen la red, y los últimos 8 son para hosts.
- `/28` → `255.255.255.224`: Los primeros 28 bits definen la red, y los últimos 4 son para hosts.

Supongamos que tenemos la red `193.144.48.0/20`. Queremos dividirla en varias subredes:

**Dividir en dos subredes**:
   - Subred 1: `193.144.48.0/21`
   - Subred 2: `193.144.56.0/21`

   Aquí, estamos usando un bit adicional en la máscara, pasando de `/20` a `/21`, para crear dos subredes.

**Ventajas de usar subredes:**
- **Ahorro de Direcciones IP**: Las subredes permiten asignar direcciones IP de forma más eficiente, adaptándose a la cantidad de dispositivos en cada parte de la red.
- **Mejor Administración**: Las redes grandes pueden ser difíciles de gestionar. Dividir una red en subredes ayuda a segmentar el tráfico y mantener un mejor control.
- **Seguridad**: Las subredes permiten aislar partes de la red, limitando la comunicación entre dispositivos de diferentes subredes, lo cual es útil en entornos empresariales.
- **Optimización del Tráfico**: Reducir el tamaño de las redes permite que el tráfico se mantenga dentro de la subred cuando sea posible, evitando el uso de routers y disminuyendo la congestión.

**Usamos subredes para:**
1. **Organización de Oficinas o Departamentos**: Una empresa con varias oficinas o departamentos puede usar subredes para asignar direcciones IP específicas a cada uno, facilitando la administración y el control.
2. **Aislamiento de Dispositivos Sensibles**: En entornos con dispositivos de seguridad o redes de invitados, crear subredes ayuda a separar estos dispositivos del tráfico general.
3. **Mejorar el Rendimiento**: Las subredes son útiles cuando una red grande se vuelve ineficiente por la congestión del tráfico. Al dividir en subredes, cada parte tiene su propio espacio IP, reduciendo el tráfico en la red principal.

### Redes sin clase, direcciones CIDR (Classless Inter-Domain Routing)
En 1993, el sistema tradicional de direcciones IP basado en clases (A, B, C) fue reemplazado por **CIDR (Classless Inter-Domain Routing)**. Este cambio permitió dividir las direcciones IP en redes y hosts con mayor flexibilidad, lo cual ayudó a mejorar la administración de redes y el uso eficiente de las direcciones IP.

#### ¿Cómo Funciona CIDR?
En CIDR, una dirección IP no está restringida a una clase fija. En su lugar, la división entre la parte de **red** y la parte de **host** de la dirección IP puede ubicarse en cualquier posición. Esto se indica mediante una **máscara** en notación `/x`, donde `x` es el número de bits dedicados a la red.

#### Ejemplo de CIDR
- Dirección CIDR: `193.144.48.0/20`
- Esto indica que los primeros 20 bits representan la **red**, y el resto de los bits, los **hosts**.

   - En binario: `1100 0001 1001 0000 0011 0000 0000 0000`
   - **Parte de red**: Primeros 20 bits → `193.144.48.0`
   - **Parte de host**: Últimos 12 bits → identifican dispositivos dentro de la red `193.144.48.0/20`


### Agregación de rutas
Es un proceso que realizan los routers por el cual toman un grupo de direcciones de redes contiguas (bloque CIDR) y las resumen en una sola dirección de red común a todas esas redes. La ventaja principal es la optimización del enrutamiento en grandes redes corporativas, ya que los routers tienen que mantener menos entradas en sus tablas de enrutamiento y en consecuencia ganan estabilidad. Si un router tiene conectadas 10 redes contiguas, solo publicará el resumen de la ruta CIDR a sus vecinos. Para obtener la dirección IP base de agregación de rutas de debemos comprobar que sean redes contiguas y, a continuación, hacer la operación AND sobre las direcciones base de esas redes. Para obtener la dirección de broadcast debemos poner todos los bits que tenían comunes al hacer la operación AND a 1.


## 4.5.2 Datagrama IP
### Formato del datagrama IP
![[archivos/imagenes/Pasted image 20241107185211.png]]

1. **Versión (4 bits)**: Indica la versión del protocolo IP utilizado. Normalmente es IPv4 (valor 4) o IPv6 (valor 6).

2. **Longitud de Cabecera (lg. cab.) (4 bits)**: Muestra la longitud de la cabecera en múltiplos de 4 bytes. Esto permite determinar dónde comienza la sección de datos.

3. **Tipo de Servicio (8 bits)**: Define la prioridad y calidad del servicio del paquete, permitiendo especificar si debe ser tratado con baja latencia, alta fiabilidad, etc.

4. **Longitud Total (16 bits)**: Es la longitud total del paquete IP, incluida la cabecera y los datos. Permite al receptor saber cuándo termina el paquete.

5. **Identificador (16 bits)**: Usado para identificar de forma única un fragmento de un datagrama IP. Es útil cuando un paquete debe dividirse en fragmentos para atravesar una red con un tamaño de unidad de transmisión más pequeño.

6. **Indicadores (indicad.) (3 bits)**: Indican si el paquete puede ser fragmentado y si es el último fragmento de un conjunto de fragmentos.

7. **Desplazamiento de Fragmento (despl. fragmento) (13 bits)**: Indica la posición de un fragmento dentro del datagrama original, facilitando la reconstrucción del paquete en el receptor.

8. **Tiempo de Vida (8 bits)**: Controla el tiempo de vida del paquete, especificando el número máximo de saltos (routers) que puede atravesar. Se decrementa en cada router, y cuando llega a cero, el paquete es descartado.

9. **Protocolo (8 bits)**: Indica el protocolo de la capa superior que se encuentra en los datos del paquete (por ejemplo, TCP o UDP). Esto ayuda a dirigir el paquete al protocolo adecuado.

10. **Suma de Comprobación de Cabecera (16 bits)**: Campo de verificación para la cabecera IP. Permite comprobar la integridad de la cabecera, detectando errores en la transmisión.

11. **Dirección IP Origen (32 bits)**: La dirección IP del dispositivo que envió el paquete. Permite al receptor saber de dónde proviene el paquete.

12. **Dirección IP Destino (32 bits)**: La dirección IP del destinatario previsto del paquete, necesaria para la entrega del mismo.

13. **Opciones (variable)**: Este campo es opcional y se utiliza para habilitar características avanzadas, como pruebas de conectividad y enrutamiento específico. Si no se utiliza, la longitud del campo es cero.

14. **Datos (variable)**: Contiene la carga útil del paquete IP, que puede ser información de una aplicación o de un protocolo de nivel superior, como TCP o UDP.


### Fragmentación de Datagramas
La fragmentación permite que los datagramas IP atraviesen diferentes tipos de redes, muchas de las cuales tienen límites en el tamaño de los paquetes que pueden manejar. Por ejemplo, Ethernet admite un máximo de 1500 bytes y otras redes de área extensa solo permiten paquetes de 576 bytes. Cuando un datagrama excede el tamaño permitido en una red, se fragmenta en partes más pequeñas.

- **Fragmentación en Ruteadores**: Los ruteadores fragmentan los datagramas cuando es necesario. Los fragmentos no se reensamblan hasta llegar al destino final, donde la capa de red en el host receptor es responsable de unir todos los fragmentos y pasarlos a la capa de transporte.
  
- **Tamaño de Segmentos TCP y UDP**: Para minimizar la fragmentación, TCP y UDP intentan generar segmentos de tamaño reducido (por ejemplo, 536 o 1460 bytes), lo que permite agregar las cabeceras TCP e IP (alrededor de 20 bytes cada una) y mantener el datagrama dentro de los límites de tamaño de las redes comunes.

## 4.5.3 Direccionamiento en IPv6
IPv6 es la versión más reciente del protocolo de Internet que reemplaza al antiguo IPv4. La transición de IPv4 a IPv6 responde principalmente al agotamiento de direcciones IP disponibles en IPv4 (debido a su límite de 32 bits) y a la necesidad de un sistema más eficiente y escalable para manejar el creciente número de dispositivos conectados a Internet. Aquí te explico en detalle las principales diferencias y características de IPv6:

En IPv4, las direcciones IP son de 32 bits, lo que da como resultado alrededor de **4.3 mil millones de direcciones posibles**. Sin embargo, con el rápido crecimiento de dispositivos conectados, estas direcciones se agotaron. En cambio, **IPv6 utiliza direcciones de 128 bits**, lo que da como resultado una cantidad prácticamente ilimitada de direcciones (aproximadamente 340 sextillones de direcciones).
  
![[archivos/imagenes/Pasted image 20241107192018.png]]

1. **Versión (4 bits)**: Indica la versión del protocolo IP. Para IPv6, este valor es 6.

2. **Clase de Tráfico (8 bits)**: Define la prioridad y clase de tráfico del paquete, permitiendo especificar si debe ser tratado con baja latencia, alta prioridad, etc.

3. **Etiqueta de Flujo (Flow Label) (20 bits)**: Utilizado para identificar flujos de paquetes que requieren un manejo especial (como los de una misma conexión o flujo de datos). Ayuda a los routers a procesar los paquetes más eficientemente.

4. **Longitud de Datos (Payload Length) (16 bits)**: Especifica la longitud de los datos contenidos en el paquete, excluyendo la cabecera.

5. **Siguiente Cabecera (Next Header) (8 bits)**: Indica el tipo de cabecera que sigue a esta cabecera IPv6. Puede ser un protocolo de capa superior (como TCP o UDP) o una cabecera de extensión de IPv6.

6. **Límite de Saltos (Hop Limit) (8 bits)**: Similar al "Tiempo de Vida" (TTL) en IPv4, especifica el número máximo de saltos que el paquete puede realizar antes de ser descartado. Se decrementa en cada router que atraviesa.

7. **Dirección IPv6 Origen (128 bits)**: Contiene la dirección IP del dispositivo que envió el paquete, permitiendo que el destinatario sepa de dónde proviene.

8. **Dirección IPv6 Destino (128 bits)**: Contiene la dirección IP del dispositivo de destino, necesaria para la entrega del paquete.

9. **Datos (variable)**: Contiene la carga útil del paquete, que incluye la información de la aplicación o de un protocolo de nivel superior.

La cabecera IPv6 tiene un tamaño fijo de 40 bytes y es más simple que la de IPv4, eliminando algunos campos y facilitando el procesamiento. Esta estructura fue diseñada para mejorar la eficiencia y el enrutamiento en redes IPv6.

### **Fragmentación en IPv6**
En IPv6, se ha eliminado la **fragmentación en los routers**. En IPv4, los routers fragmentan los paquetes si son demasiado grandes para la red siguiente. En IPv6, los routers **no fragmentan los paquetes**, y si un paquete es demasiado grande, se descarta y se envía un mensaje ICMP ("paquete demasiado grande") al emisor, quien debe reenviar el paquete en fragmentos más pequeños.

- La **fragmentación y reensamblado** se realiza **únicamente en el host de origen** y no en los routers intermedios, lo que mejora la eficiencia en el procesamiento de paquetes.

### **Transición de IPv4 a IPv6**
La transición de IPv4 a IPv6 es un proceso gradual, dado que IPv4 sigue siendo el estándar ampliamente utilizado. Durante esta transición, se usa una técnica conocida como **tunelización**. Esta técnica permite encapsular paquetes IPv6 dentro de paquetes IPv4, para que puedan ser enviados a través de redes que solo admiten IPv4.

**Ejemplo de tunelización:**
- Si un paquete IPv6 tiene que pasar por un router que solo entiende IPv4, el paquete IPv6 se encapsula dentro de un paquete IPv4.
- La dirección de origen y destino de IPv4 que se utiliza en la tunelización son las de los routers que realizan la encapsulación, no las direcciones IPv6 originales.
- Una vez que el paquete llega a un router que soporta IPv6, se desencapsula y se envía como un paquete IPv6 normal.

### Resumen de las mejoras de IPv6
- **Direcciones más largas (128 bits)**, lo que soluciona el problema de agotamiento de direcciones en IPv4.
- **Eliminación de campos innecesarios** en la cabecera para simplificar el proceso de enrutamiento.
- **No hay fragmentación en routers**, lo que reduce la carga de trabajo de estos.
- **Mejor calidad de servicio** gracias al campo de **etiqueta de flujo**.
- **Transición gradual** de IPv4 a IPv6 mediante técnicas como la tunelización.

En conjunto, IPv6 está diseñado para ser más eficiente, escalable y flexible que IPv4, permitiendo una mejor gestión del creciente tráfico de datos en Internet.

## 4.5.4 VPN (Redes Privadas Virtuales)
Las VPNs permiten conectar redes privadas a través de Internet de forma segura, simulando que están en el mismo lugar. Utilizan encriptación y autenticación para proteger la privacidad e integridad de los datos, evitando que sean interceptados o modificados.

### ¿Qué es una VPN?
Una VPN es una red privada virtual que conecta redes en distintas ubicaciones a través de Internet, permitiendo el acceso seguro a la red corporativa desde cualquier lugar.

### Componentes Clave
- **Encriptación**: Protege los datos transmitidos para evitar que sean leídos por terceros.
- **Autenticación**: Verifica la identidad de los dispositivos conectados, previniendo accesos no autorizados.

### Protocolos de Seguridad: IPsec
- **IPsec**: Protocolo para encriptar y autenticar datos en la VPN.
  - **Modo Transporte**: Protege solo el contenido del paquete IP.
  - **Modo Túnel**: Encripta el paquete completo para una mayor seguridad entre redes.

### Túneles IP
- **Túnel IP**: Encapsula datos de una red privada en paquetes IP que viajan por Internet, formando un "pasadizo seguro".

### Ejemplo de Funcionamiento
1. **Inicio**: Un dispositivo de Red 1 envía datos a Red 2.
2. **Encapsulación y Encriptado**: El router de Red 1 cifra y encapsula el paquete con una cabecera IP pública.
3. **Viaje por Internet**: El paquete encriptado viaja por Internet.
4. **Recepción y Desencriptado**: El router de Red 2 descifra y entrega el paquete original.
5. **Entrega al Destino Final**: El paquete llega al dispositivo de destino en Red 2.

### Tabla de Encaminamiento
Cada router de la VPN tiene una tabla de encaminamiento para saber cómo manejar el tráfico seguro.

### Tipos de Direcciones en la VPN
- **Dirección Interna**: Dirección del dispositivo en la red privada.
- **Dirección del Túnel**: Dirección pública del router para que el paquete viaje por Internet.

### Beneficios de las VPN
- **Seguridad**: Protege los datos mediante encriptación.
- **Privacidad**: Solo dispositivos autorizados acceden a la red.
- **Conexión Remota**: Permite a usuarios remotos acceder de forma segura.

--
**Resumen Visual:**

1. **Red 1** (privada) <--> **Router R1** -- [ Túnel VPN Encriptado ] -- **Router R2** <--> **Red 2** (privada)

2. Los routers encriptan y descifran los datos, creando un ambiente seguro.


# 4.6 ICMP (Internet Control Message Protocol)
ICMP es un protocolo que opera sobre IP y permite a hosts y routers enviar mensajes de control y error relacionados con el estado de la red. Aunque funciona en la capa de red, no transporta datos de aplicaciones de usuario, sino que se usa para reportar problemas y mantener la salud de la red. 

El protocolo ICMP tiene un formato de mensaje simple, compuesto principalmente por:
1. **Tipo y código**: Determinan la naturaleza del mensaje (ej. solicitud de eco, host inaccesible, TTL expirado).
2. **8 primeros bytes del datagrama original**: Permiten identificar qué paquete causó el error.

#### Tipos y códigos de mensajes ICMP más comunes:
- **Tipo 0, Código 0**: Respuesta de eco, usada para el comando `ping`, que mide el tiempo de ida y vuelta.
- **Tipo 3, Código 0-7**: Errores de "destino inaccesible" con diferentes causas:
  - `0`: Red inaccesible.
  - `1`: Host inaccesible.
  - `3`: Puerto inaccesible (si el servicio o aplicación en el destino no está disponible en el puerto indicado).
- **Tipo 8, Código 0**: Solicitud de eco, utilizada por `ping` para enviar un paquete de prueba.
- **Tipo 11, Código 0**: TTL (Time to Live) expirado. Se usa para notificar cuando un paquete ha alcanzado el límite de saltos permitido en su trayecto sin llegar al destino.

Ejemplo: Cuando se intenta llegar a un host que no existe, el router envía un mensaje `Destination host unreachable` (Tipo 3, Código 1) al origen.

# DHCP (Dynamic Host Configuration Protocol)

DHCP permite a los hosts obtener una dirección IP automáticamente de un servidor, ideal para redes donde las IPs se asignan de manera dinámica, como en redes domésticas o ISP.

Pasos básicos del DHCP:
1. **Descubrimiento**: El host envía un mensaje broadcast (255.255.255.255) para encontrar el servidor DHCP.
2. **Oferta**: El servidor responde con una IP y su máscara, especificando por cuánto tiempo puede usarse.
3. **Solicitud**: El cliente acepta la oferta elegida.
4. **Confirmación (ACK)**: El servidor confirma la asignación de IP.

# NAT (Network Address Translation)
NAT permite que múltiples dispositivos en una red privada compartan una sola IP pública para acceder a Internet. Esto se logra traduciendo las direcciones IP privadas (como 192.168.x.x) a una dirección pública única asignada por el ISP. 

Proceso de NAT:
1. El servidor NAT tiene dos interfaces: uno con IP pública y otro con IP privada.
2. Cambia las IPs y puertos de los paquetes salientes para que todos parezcan venir de la IP pública.
3. Lleva un registro (tabla NAT) de las conexiones para redirigir correctamente las respuestas entrantes al dispositivo correcto en la red privada.

Así, cada dispositivo en la red local se comunica externamente mediante la IP pública del NAT.


