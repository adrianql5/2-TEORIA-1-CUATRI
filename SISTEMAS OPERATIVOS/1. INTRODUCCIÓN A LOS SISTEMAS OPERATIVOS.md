[[archivos/bibliografia/2-Sistemas operativos moderno 3ed Tanenbaum.pdf|2-Sistemas operativos moderno 3ed Tanenbaum]]
 
 **Sistema Operativo**: Es un modelo de computador fácil de usar y que administra los recursos. Se podría decir que es la capa entre la parte fea del ordenador (hardware) y la parte bonita (aplicaciones de usuario).

### Funciones
- Proporciona a los programadores un conjunto abstracto de recursos, haciendo que los **programas de aplicaciones interaccionen con el SO y los usuarios finales solo interaccionen con la interfaz de usuario** (*shell o GUI, graphical user interface*).

- **Administra los recursos de hardware**, asignándolos ordenadamente entre los programas, resolviendo conflictos entre usuarios y programas y coordinando la compartición de recursos (*tiempo de cpu, espacio de memoria...*).

![[archivos/imagenes/Pasted image 20241116160550.png]]

Un sistema operativo tiene dos modos de ejecución:
- **Modo kernel (o root/modo supervisor):** el sistema operativo tiene **acceso completo a todo el hardware** y puede ejecutar cualquier instrucción que la máquina sea capaz.

- **Modo usuario:** solo permite un subconjunto de instrucciones (*las del control de la máquina o las de E/S no están permitidas*). En modo usuario el nivel más bajo de software es el **shell** o el **GUI**(*Graphical User Interface*), que nos permiten interactuar con el S.O. Estos programas nos permiten ejecutar otros como un navegador Web, lector de correo...

![[archivos/imagenes/Pasted image 20241116160610.png]]


Una **instrucción de trap** es una instrucción especial utilizada en sistemas operativos para transferir el control del flujo de ejecución desde un programa de usuario hacia el sistema operativo. Esto permite al programa realizar operaciones privilegiadas que no puede ejecutar directamente, como llamadas al sistema o manejo de excepciones. 

El mecanismo de **trap** se utiliza para manejar eventos que requieren la intervención del sistema operativo, tales como:

- **Llamadas al sistema:** Cuando un programa necesita realizar operaciones como leer un archivo, asignar memoria o comunicarse con dispositivos de hardware, usa una instrucción de trap para invocar la función del sistema operativo que realiza esa tarea.
- **Manejo de excepciones:** Como errores de división por cero o acceso inválido a memoria.
- **Cambio de modo:** Cambiar del modo usuario al modo kernel para realizar operaciones restringidas.

El flujo típico de un trap incluye:
1. La instrucción de trap interrumpe la ejecución del programa de usuario.
2. El control pasa al kernel del sistema operativo.
3. El kernel ejecuta el servicio solicitado o maneja el evento.
4. El control regresa al programa de usuario.


Aunque **traps** e **interrupciones** involucran la transferencia de control al sistema operativo, son distintos en su naturaleza y propósito:

| **Aspecto**               | **Trap**                                     | **Interrupción**                              |
|---------------------------|---------------------------------------------|-----------------------------------------------|
| **Origen**                | Generado intencionalmente por el programa, por ejemplo, al ejecutar una llamada al sistema o al ocurrir una excepción (software). | Generado externamente por hardware, como un temporizador o un dispositivo de entrada/salida. |
| **Propósito**             | Permitir la ejecución de operaciones privilegiadas o manejar excepciones. | Indicar un evento externo que requiere atención del sistema operativo. |
| **Ejemplo de uso**        | Llamadas al sistema, como `read()` o `write()`. | Interrupciones de teclado, red o disco.       |
| **Frecuencia**            | Se genera bajo condiciones controladas (planificadas). | Puede ocurrir de manera asíncrona e impredecible. |
| **Modo de activación**    | Normalmente explícito (instrucción en el programa). | Impulsado por eventos externos o hardware.   |

**En resumen**, un trap es interno al sistema y provocado intencionalmente por el programa, mientras que una interrupción es externa y suele ser causada por el hardware. Ambos, sin embargo, permiten al sistema operativo tomar control para manejar la situación.
 

# Hardware
Un sistema operativo debe conocer el hardware del que dispone, ya que está muy ligado a este, pues es el que se encarga de administrar sus recursos. Las principales partes de este hardware son:

### Procesadores
La **CPU** es el componente central de la computadora, encargado de obtener, decodificar y ejecutar instrucciones almacenadas en memoria, repitiendo este ciclo hasta que el programa finaliza. Cada CPU tiene un **conjunto específico de instrucciones**, lo que limita su compatibilidad entre arquitecturas (e.g., Pentium y SPARC).  

Para optimizar su funcionamiento, las CPU cuentan con **registros internos** que almacenan variables y resultados temporales, además de registros especiales como:  
- **Contador de programa (Program Counter):** Indica la dirección de la próxima instrucción a ejecutar.  
- **Apuntador de pila (Stack Pointer):** Apunta a la parte superior de la pila en memoria, usada para parámetros y variables locales.  
- **PSW (Program Status Word):** Contiene información del estado del programa, como el modo de operación (usuario o kernel) y los códigos de condición.  

Hay dos tipos de procesadores:
1. **Multihilamiento (Multithreading):**  
   - Permite que la CPU maneje el estado de múltiples hilos (*threads*), alternando entre ellos en nanosegundos.  
   - No ofrece verdadero paralelismo, pero reduce la inactividad de la CPU al alternar hilos mientras uno espera recursos.  
   - Para el sistema operativo, cada hilo aparece como una CPU separada, lo que puede llevar a ineficiencias en la planificación.  

2. **Procesadores multinúcleo (Multicore):**  
   - Integran varios núcleos de CPU en un chip, cada uno actuando como un procesador independiente.  
   - Requieren sistemas operativos optimizados para multiprocesamiento para aprovechar al máximo su capacidad.  


### Memoria
La **memoria** es esencial en cualquier computadora y se organiza en una **jerarquía de capas** para balancear velocidad, capacidad y costo. Las principales capas incluyen:  

1. **Registros:**  
   - Son extremadamente rápidos y están dentro de la CPU.  
   - Tienen capacidad limitada (menos de 1 KB).  

2. **Memoria caché:**  
   - Mejora el rendimiento al mantener datos frecuentemente utilizados.  
   - Se divide en niveles:  
     - **Caché L1:** Muy rápida, dentro de la CPU, con acceso inmediato.  
     - **Caché L2:** Más grande pero más lenta, puede ser compartida o separada en sistemas multinúcleo.  
   - El diseño de las cachés influye en la consistencia y eficiencia del sistema.  

3. **Memoria principal (RAM):**  
   - Es el "caballo de batalla," con tamaños entre cientos de MB y varios GB.  
   - Todas las solicitudes que no se atienden en la caché pasan a la RAM.  

4. **Memorias no volátiles:**  
   - **ROM:** Almacena datos permanentes como el cargador de arranque.  
   - **EEPROM y memoria flash:** Permiten reescritura, aunque más lenta que la RAM. Usadas en dispositivos portátiles.  
   - **CMOS:** Guarda configuraciones del sistema, con bajo consumo de energía gracias a una batería.  

La jerarquía permite manejar eficientemente las necesidades de velocidad y almacenamiento, asegurando un balance entre rendimiento y costo.

![[archivos/imagenes/Pasted image 20241116161334.png]]

### Discos, cintas y jerarquía
1. **Discos Magnéticos (Disco Duro):**  
   - Son significativamente más baratos que la RAM, con un costo por bit mucho menor y mayor capacidad.  
   - Sin embargo, el acceso aleatorio es mucho más lento, debido a su naturaleza mecánica.  
   - Un disco tiene platos giratorios (a 5400, 7200 o 10,800 rpm) y un brazo mecánico que lee/escribe en las pistas concéntricas de los platos.  
   - El tiempo de acceso depende de dos factores: el movimiento del brazo y el tiempo que tarda el sector en alinearse bajo la cabeza de lectura/escritura.  
   - La velocidad de transferencia de datos varía, con discos de bajo rendimiento a 50 MB/s y los más rápidos a 160 MB/s.  
   - **Memoria Virtual:** Utiliza el disco como extensión de la memoria RAM, permitiendo ejecutar programas más grandes de lo que la memoria física permitiría.

![[archivos/imagenes/Pasted image 20241116165629.png]]

2. **Cintas Magnéticas:**  
   - Usadas principalmente para almacenamiento de respaldo y grandes conjuntos de datos.  
   - Acceder a datos en una cinta puede ser lento, ya que requiere el posicionamiento de la cinta en el punto adecuado, lo que puede tardar varios minutos.  
   - Son muy económicas por bit y removibles, lo que las hace ideales para almacenar copias de seguridad fuera del sitio para protección ante desastres.

3. **Jerarquía de Memoria:**  
   - A medida que se desciende en la jerarquía (de registros a discos y cintas), el tiempo de acceso aleatorio aumenta, la capacidad crece y el costo por bit disminuye.  
   - Aunque algunos sistemas pueden no tener todas las capas de esta jerarquía o pueden usar otras tecnologías como discos ópticos, el principio sigue siendo aplicable: hay un equilibrio entre velocidad, capacidad y costo.

### Dispositivos de E/S
1. **Dispositivos de Entrada/Salida (E/S):**  
   - Los dispositivos de E/S consisten en dos partes: el **dispositivo controlador** (*que gestiona el dispositivo físico*) y el dispositivo en sí (*que realiza la función específica, como un disco duro o un teclado*).  
   - El **controlador recibe comandos del sistema operativo** para leer/escribir datos, realiza complejas conversiones y operaciones, y finalmente transfiere los datos a la memoria.  
   - **Drivers:** Cada dispositivo controlador necesita un **software específico** (*driver*) para interactuar con el sistema operativo. Los drivers permiten que los dispositivos, como impresoras o escáneres, funcionen con distintos sistemas operativos (*e.g., Windows, Linux*).

2. **Interfaz y Registros del Dispositivo:**  
   - Los dispositivos tienen una interfaz simple para estandarizar su funcionamiento. El sistema operativo solo interactúa con la interfaz del controlador, no directamente con el dispositivo.  
   - Los controladores usan registros específicos para controlar los dispositivos. Estos registros pueden estar en el espacio de direcciones de la memoria o en un espacio de puertos de E/S especial.  
   - **Espacio de puertos de E/S:** Donde cada registro tiene una dirección de puerto, y se usan instrucciones especiales como IN/OUT en modo kernel para interactuar con ellos.

3. **Métodos de Realización de E/S:**
   - **Esperas Ocupadas:** El driver mantiene la CPU ocupada esperando que el dispositivo termine su tarea, sondeando continuamente al dispositivo.  
   - **Interrupciones:** El dispositivo genera una interrupción cuando termina su tarea. El sistema operativo bloquea el proceso llamador y espera la señal de la interrupción. Cuando llega, el sistema operativo maneja la interrupción, ejecuta el manejador de interrupciones, y retoma el proceso interrumpido.  

![[archivos/imagenes/Pasted image 20241116165952.png]]

   - **Acceso Directo a Memoria (DMA):** Un chip DMA controla la transferencia de datos entre la memoria y el dispositivo sin intervención constante de la CPU, lo que reduce la carga sobre el procesador. Al completar la transferencia, el chip DMA genera una interrupción.

4. **Interrupciones y Manejo de Prioridades:**  
   - Las interrupciones permiten que la CPU reaccione a eventos, pero pueden ocurrir en momentos inconvenientes. Para evitar conflictos, la CPU puede deshabilitar temporalmente las interrupciones y luego reactivarlas.  
   - Si varios dispositivos generan interrupciones, el controlador de interrupciones maneja la prioridad de cada dispositivo, permitiendo que el de mayor prioridad sea atendido primero.


### Buses
1. **Evolución de los Buses:**
   - A medida que los procesadores y la memoria se volvieron más rápidos, el bus único de las primeras minicomputadoras (como el de la IBM PC original) no podía manejar todo el tráfico. Como resultado, se introdujeron más buses para mejorar la transferencia de datos entre la CPU, la memoria y los dispositivos de E/S.  
   - Un sistema moderno, como el Pentium, utiliza varios buses especializados, como los de caché, memoria, PCI, IDE, USB y SCSI, cada uno con diferentes velocidades y funciones.

2. **Tipos de Buses:**
   - **ISA (Industry Standard Architecture):** El bus original de la IBM PC, con una velocidad de 8.33 MHz y transferencia de 16.67 MB/seg. Es obsoleto, pero aún se usa para compatibilidad con dispositivos antiguos.
   - **PCI (Peripheral Component Interconnect):** Sucesor del bus ISA, con una velocidad de hasta 528 MB/seg. Es utilizado por dispositivos de E/S de alta velocidad y es compatible con sistemas no Intel.
   - **PCI Express:** Versión actualizada de PCI, usada en sistemas modernos, con una arquitectura que mejora la comunicación entre la CPU, la memoria y los dispositivos periféricos.
   - **Bus de Caché:** Conecta la CPU con la caché de nivel 1 (en chip) y la de nivel 2 (fuera del chip), optimizando el acceso a datos rápidos.
   - **Buses Especializados (IDE, USB, SCSI):**
     - **IDE (Integrated Drive Electronics):** Usado para conectar discos duros y CD-ROM.
     - **USB (Universal Serial Bus):** Conecta dispositivos de E/S lentos como teclados y ratones. La versión USB 2.0 permite transferencias de hasta 60 MB/seg.
     - **SCSI (Small Computer System Interface):** Bus de alto rendimiento para dispositivos rápidos como discos y escáneres, con velocidades de hasta 160 MB/seg.
     - **IEEE 1394 (FireWire):** Similar al USB, pero diseñado para transferencias de hasta 100 MB/seg, ideal para cámaras de video y dispositivos multimedia.

3. **Plug and Play:**
   - Con el tiempo, se introdujo la función **plug and play** para simplificar la instalación de dispositivos. Esto permite que el sistema operativo detecte automáticamente los dispositivos de E/S y configure sus niveles de interrupción y direcciones sin intervención manual, resolviendo conflictos que ocurrían con las configuraciones fijas anteriores.
   - Este proceso está estrechamente relacionado con el arranque de la computadora, mejorando la facilidad de uso y reduciendo errores en la asignación de recursos.

![[archivos/imagenes/Pasted image 20241116170139.png]]

# Arranque del ordenador
El proceso de arranque en un sistema Pentium involucra los siguientes pasos clave:

1. **BIOS (Basic Input Output System):**
   - El **BIOS** es un programa de bajo nivel contenido en la tarjeta madre (motherboard), encargado de gestionar operaciones básicas como leer el teclado, escribir en la pantalla y manejar las E/S de disco.
   - Se encuentra en una memoria **flash RAM** no volátil, lo que permite su actualización si se detectan errores.
   
2. **Pruebas Iniciales:**
   - Al encender la computadora, el **BIOS** ejecuta pruebas de hardware, como verificar la cantidad de RAM instalada y la respuesta de dispositivos básicos como el teclado.
   - Luego, explora los buses ISA y PCI para detectar dispositivos conectados, tanto los heredados como los de tipo **plug and play**, asignando configuraciones cuando sea necesario.

3. **Determinación del Dispositivo de Arranque:**
   - El **BIOS** consulta una lista en la memoria **CMOS** para determinar el dispositivo de arranque. Los dispositivos probados en orden suelen ser:
     - **Disco flexible** (si está presente),
     - **CD-ROM** (si contiene un disco arrancable),
     - **Disco duro** (si los anteriores fallan).
   
4. **Carga del Sistema Operativo:**
   - El BIOS lee el primer sector del dispositivo de arranque y lo coloca en memoria. Este sector contiene un programa que examina la **tabla de particiones** para determinar qué partición está activa.
   - Se lee y ejecuta el **cargador de arranque secundario** de esa partición, que carga el sistema operativo desde la partición activa.

5. **Inicialización del Sistema Operativo:**
   - El sistema operativo consulta al **BIOS** para obtener información de configuración y verifica si los **drivers** de los dispositivos están presentes. Si faltan, pide al usuario que inserte un CD-ROM con los drivers correspondientes.
   - Una vez que los drivers están cargados en el **kernel**, el sistema operativo inicializa las tablas necesarias, crea procesos de segundo plano y arranca un programa de inicio de sesión o **GUI**.

Este proceso permite que el sistema operativo gestione los dispositivos y comience a funcionar adecuadamente.

# Tipos de Sistemas Operativos
- **Mainframe:** procesamiento de muchos trabajos y E/S. Para servidores de alto rendimiento. Ocupan salas enteras (UNIX).
- **Servidores:** dan servicios a varios usuarios y comparten recursos de hardware y software (Linux, Windows, Solaris).
- **Multicomputadoras:** sistemas de varias CPUs (Windows, Linux, Mac OS X).
- **PC (Personal Computer):** buen soporte a un sólo usuario (Windows, Linux, Mac OS).
- **Smartphones, Tablets:** telefonía, fotografía digital... (Android, IOS, Windows Phone, Firefox OS).
- **Embedded (Empotrados):** aplicaciones cerradas para microondas, DVDs... (QNX, VxWorks).
- **Tiempo real:** tienen el tiempo como parámetro clave. Control de máquinas de fábrica...

# Conceptos
### Procesos
Un **proceso** es un programa en ejecución y es un concepto fundamental en todos los sistemas operativos. Aquí se describen sus características esenciales:

1. **Espacio de Direcciones**:
   - Cada proceso tiene asociado un **espacio de direcciones**, que es una serie de ubicaciones de memoria donde puede leer y escribir datos. Este espacio contiene:
     - **El programa ejecutable**,
     - **Los datos del programa**, y
     - **La pila** del proceso.

2. **Recursos Asociados**:
   - Además del espacio de direcciones, cada proceso tiene un conjunto de recursos asociados, como:
     - Registros del procesador (*por ejemplo, el contador de programa y el apuntador de pila*),
     - Una lista de **archivos abiertos**,
     - Alarmas pendientes, listas de procesos relacionados, y
     - Toda la información necesaria para ejecutar el programa correctamente.

3. **Imagen del Proceso**:
   - Cuando un proceso se suspende temporalmente, toda la información relevante (*como los archivos abiertos y su posición*) se guarda para poder reiniciar el proceso en el mismo estado cuando vuelva a ejecutarse. Esta información se almacena en la **tabla de procesos** del sistema operativo.

4. **Multiprogramación**:
   - En un sistema de **multiprogramación**, varios procesos pueden estar activos simultáneamente. El sistema operativo se encarga de **interrumpir un proceso y asignar tiempo de CPU a otro**, gestionando el intercambio entre procesos mediante suspensiones temporales.

5. **Tabla de Procesos**:
   - La **tabla de procesos** es una estructura de datos que almacena la información sobre todos los procesos activos, incluyendo su espacio de direcciones y su entrada en la tabla, que contiene los registros y el estado del proceso.

> [!Info]
> La **tabla de procesos** es esencial en un sistema de tiempo compartido porque:
> - **Almacena el estado de los procesos:** Contiene información sobre cada proceso, como su ID, estado (ejecutando, listo, bloqueado), registros, contador de programa, y recursos asignados.
> - **Facilita la multitarea:** Permite al sistema operativo gestionar varios procesos a la vez, realizando cambios de contexto de manera eficiente.
> - **Rastrea recursos:** Ayuda a garantizar que los recursos asignados a cada proceso (como memoria y archivos abiertos) estén correctamente administrados.

6. **Creación y Terminación de Procesos**:
   - Los procesos pueden crear otros procesos (llamados **procesos hijos**) y estos, a su vez, pueden crear más procesos. Así se forma una estructura de árbol de procesos.

![[archivos/imagenes/Pasted image 20241116171607.png]]

   - El sistema operativo ofrece llamadas al sistema para gestionar la creación y terminación de procesos, como cuando un proceso **shell** crea un proceso para ejecutar un compilador.

7. **Comunicación entre Procesos (IPC)**:
   - Los procesos pueden necesitar comunicarse entre sí o sincronizar sus actividades, lo que se llama **comunicación entre procesos (IPC)**. Esto se detalla en el capítulo 2, pero incluye mecanismos como **señales o el paso de información a través de canales**.

8. **Señales**:
   - Las **señales** son mecanismos que permiten a un proceso recibir notificaciones de eventos, como la **expiración de un temporizador o errores de hardware**. Por ejemplo, si un proceso no recibe una respuesta a tiempo, el sistema operativo puede enviar una **señal de alarma** para notificar al proceso, que luego maneja la situación y se reinicia en el mismo estado previo.

9. **Identificación de Usuario (UID)**:
   - Cada proceso tiene asociado un **UID** (*Identificación de usuario*) que se asigna al usuario que lo inicia. Los procesos hijos heredan el mismo UID que su proceso padre. Existen también **grupos** de usuarios, con un **GID** (*Identificación de grupo*), y ciertos procesos pueden tener privilegios especiales, como el **superusuario**.

El concepto de proceso es clave para entender cómo los sistemas operativos gestionan la ejecución de programas, la asignación de recursos y la sincronización entre múltiples tareas. Este tema se profundiza en el capítulo 2, que aborda aspectos más detallados de los procesos y la comunicación entre ellos.

### Espacio de Direcciones
Cada computadora tiene **memoria principal** utilizada para almacenar los programas en ejecución. En un sistema operativo simple, solo puede haber un programa en la memoria a la vez, pero los sistemas operativos más avanzados permiten que varios programas coexistan simultáneamente en la memoria. Para evitar que interfieran entre sí y con el sistema operativo, se implementan mecanismos de protección, controlados por el sistema operativo pero basados en el hardware.

Los **espacios de direcciones** son áreas de memoria que un proceso puede usar, generalmente desde 0 hasta un valor máximo. En un sistema básico, el espacio de direcciones de un proceso es menor que la memoria principal, por lo que el proceso puede ocupar todo su espacio sin exceder la capacidad de la memoria física.

Sin embargo, en sistemas con direcciones de **32 o 64 bits**, los procesos pueden tener un espacio de direcciones mucho mayor que la memoria física. Para manejar esta situación, los sistemas operativos modernos utilizan una técnica llamada **memoria virtual**. Esta técnica permite que un proceso tenga un espacio de direcciones más grande que la memoria física real, dividiendo el espacio de direcciones en partes que se mantienen en la memoria principal y en el disco duro. El sistema operativo gestiona el movimiento de estos fragmentos entre la memoria principal y el disco según sea necesario.

En resumen, el espacio de direcciones de un proceso es una **abstracción** que permite que los programas utilicen más memoria de la que físicamente tiene la computadora, lo que facilita la ejecución simultánea de múltiples procesos y la gestión eficiente de la memoria. La administración de estos espacios y la memoria física es una de las tareas fundamentales de un sistema operativo.

### Memoria virtual
La **memoria virtual** es una técnica utilizada por los sistemas operativos para simular una cantidad de memoria mayor a la que físicamente tiene la computadora. Este concepto permite que los programas ejecuten más datos de los que la memoria RAM puede manejar directamente, moviendo partes de esos datos entre la **memoria RAM** y el **disco duro** cuando es necesario. En esencia, la memoria virtual extiende la capacidad de la memoria física de la computadora, haciendo que parezca que hay más memoria disponible de la que realmente existe.
#### Características importantes:
- **Intercambio entre RAM y disco**: La memoria virtual permite que partes de un programa se carguen en la **RAM** solo cuando se necesiten, mientras que el resto se guarda en el disco duro. Esto se conoce como **paginación** o **segmentación**.
- **Bibliotecas dinámicas**: La memoria virtual también permitió que los programas se "ligaran" dinámicamente a **bibliotecas** en tiempo de ejecución, en lugar de hacerlo durante la compilación. Esto aumentó la flexibilidad y eficiencia en el uso de recursos.
- **MUL-TICS**: El sistema operativo **MUL-TICS** fue el primero en implementar de manera integral la capacidad de utilizar memoria virtual, y muchas ideas de MUL-TICS influyeron en sistemas operativos posteriores como **UNIX**.

En resumen, la memoria virtual es una técnica que ha permitido a los sistemas operar con más memoria de la que físicamente tienen disponible, mediante la gestión dinámica de la memoria entre la RAM y el disco, lo que ha sido clave para la evolución de la computación desde grandes mainframes hasta sistemas más modernos.


### Sistema de Archivos
El **sistema de archivos** es un concepto esencial en los sistemas operativos. Su función principal es ocultar las peculiaridades de los dispositivos de E/S (*entrada/salida*) y ofrecer al programador una **vista abstracta de los archivos, independiente del dispositivo físico**. Para interactuar con los archivos, el sistema operativo proporciona llamadas para **crear, eliminar, leer y escribir en ellos**. Además, los archivos se organizan en **directorios** que agrupan los archivos de forma jerárquica. Cada directorio puede contener archivos o subdirectorios, y la estructura jerárquica permite representar archivos a través de rutas, como `/Docentes/Prof.Brown/Cursos/CS101` en UNIX.

![[archivos/imagenes/Pasted image 20241116173021.png]]

El sistema de archivos puede estar **montado**, lo que significa que un dispositivo, como un CD-ROM o disco duro externo, se conecta al sistema de archivos principal. Por ejemplo, el comando `mount` permite que el contenido de un dispositivo sea accesible dentro de la estructura de directorios.

Otro concepto importante son los **archivos especiales**, que permiten tratar a los dispositivos de E/S (*como impresoras o discos*) como archivos. Existen dos tipos de archivos especiales: de **bloques** (*para dispositivos de almacenamiento*) y de **carácter** (*para dispositivos de flujo continuo, como impresoras*). Estos archivos especiales se ubican generalmente en el directorio `/dev` en UNIX.

Además, en UNIX, los **canales** (*pipes*) permiten la **comunicación entre procesos**. Un canal actúa como un archivo que conecta la salida de un proceso con la entrada de otro, facilitando la comunicación entre ellos mediante operaciones de lectura y escritura. Los canales permiten una forma sencilla de intercomunicación entre procesos, similar a la manipulación de archivos convencionales.

En resumen, el sistema de archivos es fundamental para la gestión de archivos y dispositivos en un sistema operativo, y su estructura jerárquica, la capacidad de montar dispositivos y los archivos especiales son componentes clave que se desarrollan más a fondo en los capítulos posteriores.

### Entrada 
Las computadoras tienen dispositivos físicos para la **entrada** y **salida** de información, como teclados, monitores e impresoras. Estos dispositivos permiten que los usuarios interactúen con la computadora, indicándole qué hacer y obteniendo los resultados de su trabajo. Es responsabilidad del sistema operativo gestionar estos dispositivos a través de un **subsistema de entrada/salida (E/S)**.

![[archivos/imagenes/Pasted image 20241116173309.png]]

El subsistema de E/S está compuesto por software que puede ser **independiente de los dispositivos** (aplicable a varios dispositivos) y software **específico para dispositivos** (como los drivers, que son programas diseñados para manejar dispositivos específicos). El sistema operativo coordina estos elementos para asegurar la correcta interacción con los dispositivos de entrada y salida.

### Protección
Las computadoras almacenan gran cantidad de información sensible que debe protegerse y mantenerse confidencial, como correos electrónicos, planes de negocios y declaraciones fiscales. El sistema operativo tiene la responsabilidad de gestionar la **seguridad** del sistema, asegurando que solo los usuarios autorizados puedan acceder a ciertos archivos.

En el sistema operativo **UNIX**, los archivos están protegidos mediante un **código de protección binario de 9 bits**. Este código se divide en tres campos de 3 bits: uno para el propietario, uno para los miembros del grupo del propietario, y otro para todos los demás usuarios. Cada campo tiene bits para los permisos de **lectura**, **escritura** y **ejecución**. Por ejemplo, el código `rwxr-x--x` permite que el propietario tenga acceso completo, los miembros del grupo puedan leer y ejecutar, y todos los demás solo puedan ejecutar el archivo.

Además de la protección de archivos, el sistema operativo también debe protegerse contra **intrusos** (humanos y virus). Estos aspectos de la seguridad se tratan en el capítulo 9.

### Shell
El **shell** es un **intérprete de comandos** que actúa como una **interfaz entre el usuario y el sistema operativo**. Aunque no es parte central del sistema operativo, el shell utiliza muchas de sus características y permite a los usuarios interactuar con él mediante comandos escritos. A través del shell, los usuarios pueden ejecutar programas, gestionar archivos y realizar tareas en el sistema operativo.

Cuando un usuario inicia sesión en el sistema, se inicia automáticamente un shell. Este shell muestra un **indicador de comandos** (generalmente un símbolo como `$`), que señala que está esperando a que el usuario ingrese un comando. Por ejemplo, al escribir `date`, el shell crea un proceso hijo para ejecutar el comando y, una vez que termina, muestra nuevamente el indicador.

#### Funcionalidades clave del shell:
1. **Redirección de entrada y salida**: 
   - La **salida estándar** de un programa puede ser redirigida a un archivo, como `date > archivo`, donde la salida del comando `date` se guarda en un archivo.
   - De manera similar, la **entrada estándar** puede redirigirse desde un archivo: `sort < archivo1 > archivo2` ordena las líneas de `archivo1` y guarda la salida en `archivo2`.

2. **Canales (pipes)**: 
   - Se pueden conectar varios programas para que la salida de uno sirva como entrada para otro. Por ejemplo: `cat archivo1 archivo2 archivo3 | sort > /dev/lp` concatena los archivos y los ordena antes de enviarlos a la impresora (`/dev/lp`).

3. **Ejecutar en segundo plano**:
   - Si se coloca un `&` al final de un comando, el shell no espera a que termine. En vez de eso, ejecuta el comando en segundo plano, permitiendo que el usuario siga trabajando en otras tareas.

4. **Interfaz gráfica de usuario (GUI)**:
   - Las **GUI** (*como GNOME o KDE en Linux, o Windows Explorer en Windows*) son programas que también se ejecutan sobre el sistema operativo, como si fueran **shells gráficos**. Esto permite a los usuarios interactuar con el sistema de manera visual en lugar de por comandos de texto.

En resumen, el shell es una herramienta poderosa que permite interactuar con el sistema operativo, ejecutar programas y realizar diversas operaciones a través de comandos, y a pesar de ser un programa adicional, usa y facilita muchas de las funcionalidades del sistema operativo.s.

# Llamadas al Sistema
Los sistemas operativos proporcionan un conjunto de funciones (*llamadas al sistema*) que permiten a los programas de usuario interactuar con el hardware y otros servicios de bajo nivel sin tener que acceder directamente a ellos. Estos servicios son esenciales para realizar tareas comunes de programación, como **manipular archivos, gestión de procesos, comunicación entre procesos y gestión de memoria y dispositivos hardware**.

Una **llamada al sistema** (system call) es el mecanismo que permite a los programas en modo usuario solicitar servicios o recursos del sistema operativo en modo kernel.

### Proceso de una llamada al sistema:
1. **Llamada desde un programa de usuario**: Cuando un programa necesita realizar una operación que requiere acceso al sistema operativo, invoca una llamada al sistema a través de un procedimiento en la biblioteca estándar. Por ejemplo, al ejecutar `read(fd, bufer, nbytes)` en un programa en C, se está invocando una llamada al sistema `read` para leer datos de un archivo.
   
2. **Transferencia de control al kernel**: Debido a que las aplicaciones en modo usuario no pueden ejecutar operaciones del sistema operativo directamente, cuando se invoca una llamada al sistema, el control pasa al **modo kernel**. Esto ocurre mediante una **instrucción TRAP**, que cambia el estado de la CPU de modo usuario a modo kernel. Este cambio de modo permite que el sistema operativo controle el acceso a los recursos.

3. **Ejecutar la llamada al sistema**: El kernel recibe los parámetros de la llamada (por ejemplo, el descriptor de archivo, el búfer de datos y el número de bytes a leer) y ejecuta la operación solicitada, como leer datos de un archivo. La ejecución se maneja mediante un **manejador de llamadas al sistema** que se encarga de la lógica de cada operación, por ejemplo, leyendo desde un disco o gestionando la memoria.

4. **Retorno a la aplicación**: Una vez que el kernel ha completado la tarea solicitada, el control regresa al programa de usuario. La llamada a la función de la biblioteca (como `read`) regresa con un valor que indica el resultado de la operación (por ejemplo, el número de bytes leídos o un error si algo salió mal). En caso de un error, el código de error se guarda en una variable global llamada `errno`.

### Ejemplo de llamada al sistema `read`:
1. El programa de usuario llama al procedimiento de la biblioteca `read(fd, bufer, nbytes)`, pasando tres parámetros: el descriptor de archivo (`fd`), un búfer para los datos leídos (`bufer`) y el número de bytes a leer (`nbytes`).
2. Los parámetros se colocan en la pila y luego se hace una **llamada al procedimiento**.
3. El procedimiento de la biblioteca coloca el número de la llamada al sistema en un registro y ejecuta la instrucción TRAP, que cambia al modo kernel.
4. El sistema operativo recibe el número de la llamada al sistema y la procesa mediante el **manejador correspondiente** (en este caso, la operación de lectura).
5. Una vez completada la operación, el control se devuelve al programa de usuario con el resultado de la operación.

![[archivos/imagenes/Pasted image 20241116180342.png]]
> [!IMPORTANTE] 
> Esta imagen cayó en un final

### Consideraciones:
- **Bloqueo de procesos**: Si la llamada al sistema necesita esperar (por ejemplo, leer de un archivo que no tiene datos disponibles en ese momento), el proceso puede bloquearse. Mientras tanto, el sistema operativo puede ejecutar otros procesos.
- **Verificación de errores**: Es fundamental que los programas verifiquen el resultado de las llamadas al sistema. Si ocurre un error (como un archivo no encontrado), la llamada al sistema devuelve un valor de error, y el programa puede consultar la variable global `errno` para obtener más detalles.

### Llamadas al sistema en POSIX:
POSIX (*un estándar para sistemas operativos*) define aproximadamente 100 llamadas al sistema que cubren tareas como:
- **Creación y terminación de procesos**.
- **Operaciones con archivos y directorios**.
- **Operaciones de entrada/salida**.

Estas llamadas al sistema permiten realizar las tareas fundamentales para que el sistema operativo administre los recursos de la computadora y ejecute programas de usuario de manera eficiente.

#### Llamadas al sistema para la administración de procesos
Algunas de las funciones clave que permiten manejar procesos en sistemas operativos como POSIX:
1. **fork**: Es la llamada al sistema que permite crear un nuevo proceso, duplicando el proceso actual (*padre*) y creando un proceso hijo. Ambos procesos continúan ejecutándose independientemente, pero comparten ciertas características (*como los descriptores de archivo*). `fork` devuelve un valor que indica si el proceso está en el padre o en el hijo (*el hijo recibe 0, y el padre recibe el PID del hijo*).

2. **waitpid**: Permite que el proceso padre **espere la terminación de uno o más procesos hijos**. El proceso puede esperar a un hijo específico o a cualquier hijo. El estado de salida del hijo se puede obtener en el parámetro `statloc`.

3. **execve**: Permite **reemplazar la imagen del proceso actual con un nuevo programa**. Un proceso hijo creado por `fork` generalmente ejecutará un nuevo programa usando esta llamada, sustituyendo su espacio de memoria por el del nuevo programa.

4. **exit**: Utilizada por los procesos para **finalizar** su ejecución. El estado de terminación (un valor entre 0 y 255) es devuelto al proceso padre a través de `waitpid`.

5. **Segmentación de memoria**: Los procesos en UNIX tienen su memoria dividida en tres segmentos: texto (*código del programa*), datos (*variables*), y pila. La pila crece hacia abajo, y los datos crecen hacia arriba, con un espacio libre entre ambos. La expansión de la pila es automática, pero la expansión del segmento de datos se maneja con llamadas al sistema como `brk`, aunque este no está en el estándar POSIX y se recomienda usar `malloc` para la gestión dinámica de memoria.

![[archivos/imagenes/Pasted image 20241116180738.png]]

Estas llamadas al sistema son fundamentales para la gestión de procesos en los sistemas operativos, permitiendo la creación, ejecución y finalización de procesos, así como la interacción entre ellos.

#### Llamadas al Sistema para la Gestión de Archivos
Muchas llamadas al sistema están relacionadas con la gestión de archivos. Esta sección se centra en las llamadas al sistema que tratan con archivos individuales. Para leer o escribir en un archivo, primero debe abrirse utilizando `open`. Esta llamada especifica el nombre del archivo (ya sea una ruta absoluta o relativa), y un código como `O_RDONLY`, `O_WRONLY` o `O_RDWR`, que indica si el archivo se abre para lectura, escritura o ambos. Para crear un nuevo archivo, se utiliza el parámetro `O_CREAT`. Después de abrirlo, un archivo puede ser leído o escrito utilizando el descriptor de archivo devuelto. Al finalizar, el archivo puede cerrarse con `close`, lo que hace que el descriptor de archivo esté disponible para su reutilización en llamadas posteriores a `open`.

Las llamadas al sistema más utilizadas para operaciones con archivos son `read` y `write`. `read` lee datos de un archivo a un búfer, mientras que `write` escribe datos de un búfer a un archivo. Para aplicaciones que requieren acceso aleatorio a archivos, el archivo tiene un puntero asociado que indica la posición actual en el archivo. Para cambiar este puntero, se utiliza la llamada `lseek`. `lseek` acepta tres parámetros: el descriptor del archivo, la posición dentro del archivo y una bandera que indica si la posición es relativa al inicio, a la posición actual o al final del archivo. El valor devuelto por `lseek` es la posición absoluta en el archivo después de la modificación.

UNIX mantiene metadatos sobre cada archivo, como su modo (archivo regular, directorio, etc.), tamaño y la última hora de modificación. Para acceder a esta información, se utiliza la llamada al sistema `stat`. El primer parámetro especifica el archivo a inspeccionar, y el segundo es un puntero a una estructura donde se almacena la información. `fstat` cumple el mismo propósito pero opera sobre un archivo abierto.

#### Llamadas al Sistema para la Gestión de Directorios
Esta sección se centra en las llamadas al sistema relacionadas con directorios o con el sistema de archivos en su totalidad. Las dos primeras llamadas al sistema son `mkdir` (para crear un directorio) y `rmdir` (para eliminar un directorio vacío). Otra llamada importante es `link`, que permite que un archivo aparezca bajo varios nombres, a menudo en diferentes directorios. Esto facilita el acceso compartido a un mismo archivo a través de distintos directorios. A diferencia de copiar, donde cada usuario tiene su propia versión del archivo, un enlace permite que los cambios realizados por un usuario sean inmediatamente visibles para los demás.

Cada archivo en UNIX tiene un número único de inode, que lo identifica. Un directorio es un archivo especial que contiene pares de números de inode y nombres ASCII. La llamada al sistema `link` crea una nueva entrada en el directorio utilizando el número de inode de un archivo existente. Si un archivo tiene varias entradas en el directorio con el mismo número de inode, todas se refieren al mismo archivo. El archivo solo se elimina del disco cuando se eliminan todas las entradas del directorio que lo hacen referencia, utilizando la llamada al sistema `unlink`.

![[archivos/imagenes/Pasted image 20241116181409.png]]

Otra llamada clave es `mount`, que permite combinar dos sistemas de archivos en uno. Esto es común para integrar medios extraíbles, como CD-ROMs, en el sistema de archivos existente. Después de montar, los archivos del nuevo sistema pueden accederse como parte de la jerarquía principal del sistema de archivos. Cuando ya no se necesite, el sistema de archivos puede desmontarse utilizando la llamada al sistema `umount`.

![[archivos/imagenes/Pasted image 20241116181350.png]]

#### Llamadas al Sistema Misceláneas
También existen otras llamadas al sistema. La llamada `chdir` cambia el directorio de trabajo actual, por lo que cualquier operación posterior con archivos hará referencia a rutas relativas al nuevo directorio. La llamada `chmod` modifica el modo de un archivo, como sus permisos de lectura/escritura/ejecución.

La llamada al sistema `kill` envía señales a procesos. Si un proceso está configurado para manejar una señal específica, se ejecuta un manejador de señales; de lo contrario, el proceso es terminado.

La llamada al sistema `time` devuelve la hora actual en segundos, con la hora base establecida en el 1 de enero de 1970. En sistemas de 32 bits, este valor puede desbordarse después de aproximadamente 136 años, lo que causará problemas similares al error del año 2000. Se recomienda a los sistemas actualizarse a arquitecturas de 64 bits para evitar este problema en el futuro.

![[archivos/imagenes/Pasted image 20241116181028.png]]


# Estructura del Sistema Operativo UNIX

![[archivos/imagenes/Pasted image 20241117130107.png]]

La imagen describe la **estructura del sistema operativo UNIX** de forma jerárquica, dividiendo sus componentes en tres niveles principales: **usuario**, **núcleo (kernel)** y **hardware**. A continuación, te explico cada nivel y cómo interactúan entre ellos:

### **1. Nivel de Usuario**
Este es el nivel más alto de la estructura, donde interactúan los usuarios y los programas.

- **Programas:** 
  Son las aplicaciones o procesos que los usuarios ejecutan, como editores de texto, navegadores o compiladores. Estos programas requieren servicios del sistema operativo, como leer archivos, escribir datos o manejar memoria.

- **Librerías:**  
  Son colecciones de funciones que facilitan la interacción de los programas con el núcleo. Muchas de estas funciones invocan llamadas al sistema, pero lo hacen de manera más accesible para el programador.  
  Ejemplo: La función de biblioteca `printf()` en C puede usar una llamada al sistema como `write` para escribir datos en la salida estándar.

- **Trap:**  
  Es el mecanismo mediante el cual un programa solicita servicios al núcleo, desencadenando una **llamada al sistema**. Cuando un trap ocurre, se transfiere el control desde el programa en modo usuario hacia el núcleo en modo privilegiado.

---

### **2. Nivel del Núcleo (Kernel)**
El núcleo es el corazón del sistema operativo. Se encarga de manejar los recursos de hardware y proporcionar servicios esenciales a los programas en el nivel de usuario.

- **Interfaz de llamadas al sistema:**  
  Es el punto de entrada al núcleo desde el nivel de usuario. Los programas utilizan llamadas al sistema para realizar operaciones como abrir un archivo, crear un proceso o asignar memoria.

- **Subsistema de ficheros:**  
  Maneja todo lo relacionado con la administración de archivos, como:
  - Creación, apertura, lectura, escritura y cierre de archivos.
  - Gestión de permisos y atributos.
  - Organización de los datos en el disco (mediante sistemas de archivos).

- **Caché de buffers:**  
  Es una memoria intermedia que almacena temporalmente datos de E/S (entrada/salida) para mejorar el rendimiento. Permite minimizar las operaciones directas en el disco al almacenar información frecuentemente utilizada.

- **Drivers de dispositivos (modo carácter y modo bloque):**  
  - **Modo carácter:** Maneja dispositivos que transmiten datos en forma de flujo continuo, como un teclado o un ratón.
  - **Modo bloque:** Maneja dispositivos que transmiten datos en bloques, como discos duros. Estos controladores convierten las solicitudes del subsistema de ficheros en comandos entendibles por el hardware.

- **Subsistema de control de procesos:**  
  Este subsistema gestiona los procesos que se ejecutan en el sistema, incluyendo:
  - **Comunicación entre procesos (IPC):** Permite que los procesos se comuniquen entre sí mediante mecanismos como tuberías, colas de mensajes o memoria compartida.
  - **Planificador:** Decide qué proceso obtiene tiempo de CPU y durante cuánto tiempo, según algoritmos de planificación.
  - **Administración de memoria:** Se encarga de asignar y gestionar la memoria utilizada por los procesos, permitiendo funciones como la paginación o la segmentación.

- **Control del hardware:**  
  El núcleo traduce las solicitudes del subsistema de ficheros y de procesos en comandos para el hardware. Aquí, los controladores de dispositivos juegan un rol crucial para establecer esta comunicación.

---

### **3. Nivel de Hardware**
Este nivel incluye los dispositivos físicos de la computadora, como:
- CPU.
- Memoria.
- Dispositivos de almacenamiento (discos duros, SSDs).
- Dispositivos de entrada/salida (teclados, pantallas, impresoras).

El núcleo actúa como un puente entre el hardware y los programas del nivel de usuario, garantizando que los recursos del sistema sean usados de manera segura y eficiente.

---

### **Relación entre niveles**
1. Los programas de usuario realizan solicitudes al sistema operativo mediante **llamadas al sistema** (a través de traps), que son procesadas por el núcleo.
2. El núcleo, en función de la solicitud, interactúa con los distintos subsistemas y controladores para cumplir las peticiones.
3. El núcleo se comunica directamente con el hardware para acceder a dispositivos o ejecutar operaciones de bajo nivel.

![[archivos/imagenes/Pasted image 20241117130215.png]]

Esta estructura jerárquica asegura una clara separación entre las aplicaciones del usuario y el hardware, proporcionando seguridad, eficiencia y un entorno multitarea robusto.



![[archivos/imagenes/Pasted image 20241117130954.png]]
La imagen describe la **estructura del núcleo del sistema operativo Linux**, organizada en componentes funcionales que interactúan para gestionar los recursos del sistema y atender las solicitudes de los programas de usuario. Aquí tienes una explicación de cada parte:

### **1. System Calls (Llamadas al sistema)**
Las llamadas al sistema son el principal mecanismo de comunicación entre las aplicaciones en el espacio de usuario y el núcleo.  
- Proveen acceso controlado a recursos como archivos, memoria y dispositivos.
- Los procesos solicitan servicios del núcleo mediante estas llamadas.

Ejemplos de llamadas al sistema incluyen:
- Operaciones de E/S: `read`, `write`.
- Manejo de procesos: `fork`, `exec`.
- Gestión de memoria: `mmap`, `brk`.

---

### **2. I/O Component (Componente de Entrada/Salida)**
Este componente gestiona todas las operaciones relacionadas con dispositivos de entrada/salida, como discos, terminales y redes. Se basa en una abstracción conocida como **sistema de archivos virtual (VFS)**, que permite un acceso uniforme a diferentes sistemas de archivos y dispositivos.

- **Virtual File System (Sistema de archivos virtual):**  
  Es una capa de abstracción que unifica el acceso a diferentes sistemas de archivos (ext4, FAT32, NTFS) y dispositivos.  
  - **File Systems:** Maneja la organización de datos en discos y otros medios de almacenamiento.
  - **Generic Block Layer:** Proporciona una interfaz genérica para operaciones con bloques de datos, como lectura/escritura en discos.
  - **I/O Scheduler:** Organiza y optimiza las operaciones de E/S para mejorar el rendimiento.
  - **Block Device Drivers:** Controlan dispositivos que operan en bloques, como discos duros y SSDs.

- **Character Device Drivers:**  
  Manejan dispositivos que envían o reciben datos como un flujo continuo (por ejemplo, teclados o ratones).

- **Sockets y Network Protocols:**  
  Estos elementos habilitan la comunicación en red mediante protocolos como TCP/IP, proporcionando conectividad y transferencia de datos entre máquinas.

---

### **3. Memory Management Component (Gestión de Memoria)**
Este componente es responsable de administrar la memoria física y virtual del sistema.

- **Virtual Memory (Memoria virtual):**  
  Permite que cada proceso tenga su propio espacio de direcciones, independientemente de la memoria física disponible. Implementa paginación para cargar solo las partes necesarias de un programa en memoria.

- **Paging y Page Replacement:**  
  Gestionan la asignación de páginas de memoria. Cuando no hay memoria física suficiente, se reemplazan páginas menos utilizadas (swap) para liberar espacio.

- **Page Cache:**  
  Es una memoria intermedia para datos frecuentemente accedidos en discos, mejorando el rendimiento al reducir las operaciones de E/S directas.

---

### **4. Process Management Component (Gestión de Procesos)**
Este componente administra los procesos y su ejecución.

- **Signal Handling (Manejo de señales):**  
  Permite la comunicación entre procesos y el manejo de eventos. Las señales son notificaciones que interrumpen un proceso para ejecutar una acción específica (por ejemplo, `SIGINT` para interrumpir un proceso).

- **Process/Thread Creation & Termination:**  
  Cubre la creación de procesos (`fork`), su terminación (`exit`) y la gestión de subprocesos (threads).

- **CPU Scheduling (Planificación de la CPU):**  
  Decide qué proceso o hilo obtiene acceso al procesador y durante cuánto tiempo. Esto es crucial para implementar multitarea y garantizar un uso eficiente de los recursos.

---

### **5. Interrupts (Interrupciones)**
Las interrupciones son señales enviadas por hardware o software que requieren atención inmediata del núcleo.  
- El núcleo pausa la ejecución actual para manejar la interrupción mediante un controlador.
- Ejemplo: Una tecla presionada en el teclado genera una interrupción que el núcleo debe procesar.

---

### **6. Dispatcher**
El despachador es responsable de transferir el control del procesador entre diferentes procesos.  
- Actúa como el "coordinador" que asegura una ejecución fluida y eficiente de múltiples tareas.
- Se basa en las decisiones del planificador para asignar tiempo de CPU.

---

### **Resumen de la estructura**
El núcleo de Linux está organizado en módulos especializados que trabajan en conjunto para:
1. Gestionar procesos y recursos.
2. Manejar la memoria de manera eficiente.
3. Abstraer las operaciones de entrada/salida.
4. Responder a interrupciones de hardware y software.

Esta modularidad y abstracción hacen que Linux sea altamente eficiente, flexible y adaptable a diferentes plataformas y usos.