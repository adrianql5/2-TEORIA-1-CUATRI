[[archivos/bibliografia/2-Sistemas operativos moderno 3ed Tanenbaum.pdf|2-Sistemas operativos moderno 3ed Tanenbaum]]

Escrito por **Adrián Quiroga Linares**.

 **Sistema Operativo**: Capa de software cuyo trabajo es proporcionar a los program de usuario un modelo de computadora mejor, más simple y pulcro, encargado de administrar los recursos del ordenador. Se encuentra entre el hardware y las aplicaciones de ususario.


Un sistema operativo tiene dos modos de ejecución:
- **Modo kernel (o root/modo supervisor):** el sistema operativo tiene **acceso completo a todo el hardware** y puede ejecutar cualquier instrucción que la máquina sea capaz.

- **Modo usuario:** solo permite un subconjunto de instrucciones (*las del control de la máquina o las de E/S no están permitidas*). En modo usuario el nivel más bajo de software es el **shell** o el **GUI**(*Graphical User Interface*), que nos permiten interactuar con el S.O. Estos programas nos permiten ejecutar otros como un navegador Web, lector de correo...

![[archivos/imagenes/Pasted image 20241116160610.png]]


**Definición formal:** capa de softeare encargada de proporcionar a los programadores de aplicaciones un conjunto abstracto de recursos simples, en vez de complejos conjuntos de hardware; y administrar estos recursos hardware.

# Hardware
Un sistema operativo debe conocer el hardware del que dispone, ya que está muy ligado a este, pues es el que se encarga de administrar sus recursos. Las principales partes de este hardware son:

## Procesadores
La **CPU** es el componente central de la computadora, encargado de **obtener, decodificar y ejecutar instrucciones** almacenadas en memoria, repitiendo este ciclo hasta que el programa finaliza. 

Para optimizar su funcionamiento, las CPU cuentan con **registros internos** que almacenan variables y resultados temporales, además de registros especiales como:  
- **Contador de programa (Program Counter):** Indica la dirección de la próxima instrucción a ejecutar.  
- **Apuntador de pila (Stack Pointer):** Apunta a la parte superior de la pila en memoria, usada para parámetros y variables locales.  
- **PSW (Program Status Word):** Contiene información del estado del programa, como el modo de operación (usuario o kernel) y los códigos de condición.  Los programas de usuario rara vez lo pueden modificar.

Cuando se **multiplexan** programas se debe almacenar el contenido de los registros. SI **PSW** está activado se permite ejecutar cualquier tipo de instrucción.

**Modelo de Canalización:** Se usa para mejorar el rendimiento. Permite ejecutar varias instrucciones al mismo tiempo.

**Modelo Superescalar:** tienes varias unidades de ejecución

![[archivos/imagenes/Pasted image 20241212094932.png]]


### Llamadas al sitema, traps e interrupciones
- **Llamada al sistema:** para obtener servicios del sistema operativo, un **programa de usuario** lanza una **llamada al sitema**, que se recibe en el **kernel** e iniia el SO. Producen **Traps**. Un ejemplo sería un programa que llama a un read, que necesita acceso privilegiado para acceder al disco y lee.

- **Intrucción de Trap:** cambia de **modo usuario** a **modo kernel** e inicia el SO. Cuando se completa el trabajo, el control de devuelve al programa de usuario.

- **Interrupción:** producen la mayoría de **traps**, se originan el en hardware de forma impredecible (*generalmente por un temporizador o dispositivo de E/S*). También se generan por operaciones ilegales como dividir entre cero o en un subdesbordamiento en punto flotante.


### Multihilamiento y Multinúcleo.
1. **Multihilamiento (Multithreading):**  
   - Permite que la CPU maneje el estado de múltiples hilos (*threads*), **alternando** entre ellos en nanosegundos.  
   - **No ofrece verdadero paralelismo**, pero reduce la inactividad de la CPU al alternar hilos mientras uno espera recursos.  
   - Para el sistema operativo, **cada hilo aparece como una CPU separada, lo que puede llevar a ineficiencias en la planificación**.  

2. **Procesadores multinúcleo (Multicore):**  
   - Integran **varios núcleos de CPU en un chip**, cada uno actuando como un procesador independiente.  
   - Requieren sistemas operativos optimizados para multiprocesamiento para aprovechar al máximo su capacidad. 
   - Pueden brindar un **verdadero paralelismo.**

## Memoria
La **memoria** es esencial en cualquier computadora y se organiza en una **jerarquía de capas** para balancear velocidad, capacidad y costo. Las principales capas incluyen:  

1. **Registros:**  
   - Son extremadamente rápidos y están dentro de la CPU.  
   - Tienen capacidad limitada (menos de 1 KB).  

2. **Memoria caché:**  
   - Mejora el rendimiento al mantener datos frecuentemente utilizados.  
   - Se divide en niveles:  
     - **Caché L1:** Muy rápida, dentro de la CPU, con acceso inmediato.  
     - **Caché L2:** Más grande pero más lenta, puede ser compartida o separada en sistemas multinúcleo.  
   - El diseño de las cachés influye en la consistencia y eficiencia del sistema.  

3. **Memoria principal (RAM):**  
   - Es el "caballo de batalla," con tamaños entre cientos de MB y varios GB.  
   - Todas las solicitudes que no se atienden en la caché pasan a la RAM.  

4. **Memorias no volátiles:**  
   - **ROM:** Almacena datos permanentes como el cargador de arranque.  
   - **EEPROM y memoria flash:** Permiten reescritura, aunque más lenta que la RAM. Usadas en dispositivos portátiles.  
   - **CMOS:** Guarda configuraciones del sistema, con bajo consumo de energía gracias a una batería.  

La jerarquía permite manejar eficientemente las necesidades de velocidad y almacenamiento, asegurando un balance entre rendimiento y costo.

![[archivos/imagenes/Pasted image 20241116161334.png]]

### Discos
Tienen un acceso muy lento pero tienen gran capacidad de almacenamiento.

![[archivos/imagenes/Pasted image 20241116165629.png]]

El **disco** está formado por platos giratorios que van a unos determinadas **rmp**.  Un **brazo mecánico**, con un punto de giro colocado en una esquina, se mueve sobre los platos de manera similar al brazo de la aguja en un viejo tocadiscos. La información se escribe en el disco en una serie de círculos concéntricos. En cualquier posición dada del brazo, cada una de las cabezas puede leer una región anular conocida como **pista** (*track*). En conjunto, todas las pistas para una posición dada del brazo forman un **cilindro**.

![[archivos/imagenes/Pasted image 20241212102354.png]]

Además el **disco** introduce el concepto de **memoria virtual**, que se puede entender como usar el disco como una extension de la **RAM**. La memoria virtual nos va a permitir la ejecución de programas más grandes que la memoria física al colocarlos en el disco y usar la **RAM como una especie de caché** para las partes que más se usan. Este esquema requiere la reasignación de direcciones de memoria al instante, para convertir la dirección generada por el programa a la RAM.
Esta **traducción** se realiza en el procesador mediante la **MMU**.

### Cambio de contexto
Se produce cuando en un sistema de **multiprogramación**, se cambia de un programa a otro. Cuando se produce puede ser necesario **vaciar** los bloques modificados de la **caché** y modificar los registros de asignación en la MMU.


## Dispositivos de E/S  
Los dispositivos de E/S consisten en dos partes: el **dispositivo controlador** (*que gestiona el dispositivo físico*) y el dispositivo en sí (*que realiza la función específica, como un disco duro o un teclado*).  

   - El **dispositivo controlador** se ubica dentro del dispositivo y consiste en un chip o conjunto de chips que presentan al SO una interfaz más sencilla. Por ejemplo si leemos de un disco, el dispositivo controlador se puede encargar del movimiento del brazo tras haber realizado una traducción de la dirección

   - **Drivers:** Cada dispositivo controlador necesita un **software específico** (*driver*) para interactuar con el sistema operativo. Se colocan en el SO de forma que se pueden usar en **modo kernel**. Cada sistema operativo puede implicar el uso de un driver diferente. El driver conecta al SO con el **dispositivo controlador**


Todo dispositivo controlador tiene un **número pequeño de registros que sirven para comunicarse con él**.  Para activar el dispositivo controlador, el **driver recibe un comando** del sistema operativo y después lo traduce en los valores apropiados para escribirlos en los registros del dispositivo. La colección de todos los registros del dispositivo forma el ** **


Las operaciones de E/S se realizan de 3 formas posibles:

- **Llamada al sistema:** que después el **kernel** traduce a en una llamada al procedimiento para el driver apropiado. Después el driver inicial el procedimiento E/S, y una vez acabado, coloca los datos. Esto se conoce como una **espera ocupada** porque mantiene ocupada a la CPU sondeando al dispositivo. Por ejemplo al usar un `scanf`.

- **Interrupciones:** primero el **driver** le indica al **dispositivo controlador** lo que debe hacer y lo inicia.  Cuando el dispositivo controlador termina su trabajo, envía una **interrupción** y avisa al **controlador de interrupciones**.  El controlador de interrupciones avisa a la CPU y le pasa el **id** del dispositivo para que sepa que dispositivo ha acabado.
  Se toma la interrupción, se envía al controlador (*manejador*) de interrupciones y regresa al programa de usuario.


![[archivos/imagenes/Pasted image 20241116165952.png]]

Cuando se recibe la **interrupción**, el **PC** y el **PSW** son agregados a la pila actual y mediante un **trap** la CPU pasa a modo kernel. El **ide del dispositivo** se puede usar como índice en parte de la memoria para encontrar la dirección del controlador de interrupciones para ese dispositivo. Esta parte de la memoria se concoe como **vector de interrupciones.**


## Buses
Conectan a los diferentes componentes del ordenador.
   - Con el tiempo, se introdujo la función **plug and play** para simplificar la instalación de dispositivos. Esto permite que el sistema operativo detecte automáticamente los dispositivos de E/S y configure sus niveles de interrupción y direcciones sin intervención manual, resolviendo conflictos que ocurrían con las configuraciones fijas anteriores.
   - Este proceso está estrechamente relacionado con el arranque de la computadora, mejorando la facilidad de uso y reduciendo errores en la asignación de recursos.

![[archivos/imagenes/Pasted image 20241116170139.png]]

# Arranque del ordenador
El proceso de arranque en un sistema Pentium involucra los siguientes pasos clave:

1. **BIOS (Basic Input Output System):**
   - El **BIOS** es un programa de bajo nivel contenido en la tarjeta madre (motherboard), encargado de gestionar operaciones básicas como leer el teclado, escribir en la pantalla y manejar las E/S de disco.
   - Se encuentra en una memoria **flash RAM** no volátil, lo que permite su actualización si se detectan errores.
   
2. **Pruebas Iniciales:**
   - Al encender la computadora, el **BIOS** ejecuta pruebas de hardware, como verificar la cantidad de RAM instalada y la respuesta de dispositivos básicos como el teclado.
   - Luego, explora los buses ISA y PCI para detectar dispositivos conectados, tanto los heredados como los de tipo **plug and play**, asignando configuraciones cuando sea necesario.

3. **Determinación del Dispositivo de Arranque:**
   - El **BIOS** consulta una lista en la memoria **CMOS** para determinar el dispositivo de arranque. Los dispositivos probados en orden suelen ser:
     - **Disco flexible** (si está presente),
     - **CD-ROM** (si contiene un disco arrancable),
     - **Disco duro** (si los anteriores fallan).
   
4. **Carga del Sistema Operativo:**
   - El BIOS lee el primer sector del dispositivo de arranque y lo coloca en memoria. Este sector contiene un programa que examina la **tabla de particiones** para determinar qué partición está activa.
   - Se lee y ejecuta el **cargador de arranque secundario** de esa partición, que carga el sistema operativo desde la partición activa.

5. **Inicialización del Sistema Operativo:**
   - El sistema operativo consulta al **BIOS** para obtener información de configuración y verifica si los **drivers** de los dispositivos están presentes. Si faltan, pide al usuario que inserte un CD-ROM con los drivers correspondientes.
   - Una vez que los drivers están cargados en el **kernel**, el sistema operativo inicializa las tablas necesarias, crea procesos de segundo plano y arranca un programa de inicio de sesión o **GUI**.

Este proceso permite que el sistema operativo gestione los dispositivos y comience a funcionar adecuadamente.

# Conceptos Básicos
## Tipos de Sistemas Operativos
- **Mainframe:** procesamiento de muchos trabajos y E/S. Para servidores de alto rendimiento. Ocupan salas enteras (UNIX).
- **Servidores:** dan servicios a varios usuarios y comparten recursos de hardware y software (Linux, Windows, Solaris).
- **Multicomputadoras:** sistemas de varias CPUs (Windows, Linux, Mac OS X).
- **PC (Personal Computer):** buen soporte a un sólo usuario (Windows, Linux, Mac OS).
- **Smartphones, Tablets:** telefonía, fotografía digital... (Android, IOS, Windows Phone, Firefox OS).
- **Embedded (Empotrados):** aplicaciones cerradas para microondas, DVDs... (QNX, VxWorks).
- **Tiempo real:** tienen el tiempo como parámetro clave. Control de máquinas de fábrica...


## Procesos
Un **proceso** es un programa en ejecución y es un concepto fundamental en todos los sistemas operativos. 

Cada proceso tiene asociado un **espacio de direcciones**, que es una serie de ubicaciones de memoria donde puede leer y escribir datos. Este espacio contiene:
     - **El programa ejecutable**,
     - **Los datos del programa**, y
     - **La pila** del proceso.


Además del espacio de direcciones, cada proceso tiene un conjunto de recursos asociados, como:
     - Registros del procesador (*por ejemplo, el contador de programa y el apuntador de pila*),
     - Una lista de **archivos abiertos**,
     - Alarmas pendientes, listas de procesos relacionados, y
     - Toda la información necesaria para ejecutar el programa correctamente.


Cuando un proceso se suspende temporalmente, toda la información relevante (*como los archivos abiertos y su posición*) se guarda para poder reiniciar el proceso en el mismo estado cuando vuelva a ejecutarse. Esta información se almacena en la **tabla de procesos** del sistema operativo, laa cual es un arreglo (*o lista enlazada*) de estructuras, una para cada proceso que se encuentre actualmente en **existencia**.

En un sistema de **multiprogramación**, varios procesos pueden estar activos simultáneamente. El sistema operativo se encarga de **interrumpir un proceso y asignar tiempo de CPU a otro**, gestionando el intercambio entre procesos mediante suspensiones temporales.


> [!Info]
> La **tabla de procesos** es esencial en un sistema de tiempo compartido porque:
> - **Almacena el estado de los procesos:** Contiene información sobre cada proceso, como su ID, estado (ejecutando, listo, bloqueado), registros, contador de programa, y recursos asignados.
> - **Facilita la multitarea:** Permite al sistema operativo gestionar varios procesos a la vez, realizando cambios de contexto de manera eficiente.
> - **Rastrea recursos:** Ayuda a garantizar que los recursos asignados a cada proceso (como memoria y archivos abiertos) estén correctamente administrados.


   Los procesos pueden crear otros procesos (llamados **procesos hijos**) y estos, a su vez, pueden crear más procesos. Así se forma una estructura de árbol de procesos.

![[archivos/imagenes/Pasted image 20241116171607.png]]

 El sistema operativo ofrece llamadas al sistema para gestionar la creación y terminación de procesos, como cuando un proceso **shell** crea un proceso para ejecutar un compilador.

Cuando ha transcurrido el número especificado de segundos, el **sistema operativo envía una señal de alarma al proceso**. La señal **provoca que el proceso suspenda** en forma temporal lo que esté haciendo, almacene sus registros en la pila y empiece a ejecutar un procedimiento manejador de señales especial. Cuando termina el manejador de señales, el proceso en ejecución **se reinicia en el estado en el que se encontraba** justo antes de la señal. Las señales son la analogía en software de las **interrupciones de hardware** y se pueden generar mediante una variedad de causas además de la expiración de los temporizadores

Cada proceso tiene asociado un **UID** (*Identificación de usuario*) que se asigna al usuario que lo inicia. Los procesos hijos heredan el mismo UID que su proceso padre. Existen también **grupos** de usuarios, con un **GID** (*Identificación de grupo*), y ciertos procesos pueden tener privilegios especiales, como el **superusuario**.



## Espacio de Direcciones
Cada computadora tiene **memoria principal** utilizada para almacenar los programas en ejecución. Los sistemas operativos más avanzados permiten que **varios programas coexistan simultáneamente en la memoria**. Para evitar que interfieran entre sí y con el sistema operativo, se implementan mecanismos de protección, controlados por el sistema operativo pero basados en el hardware.

Los **espacios de direcciones** son áreas de memoria que un proceso puede usar, generalmente **desde 0 hasta un valor máximo**. 

Sin embargo, en sistemas con direcciones de **32 o 64 bits**, los procesos pueden tener un espacio de direcciones mucho mayor que la memoria física. Para manejar esta situación, los sistemas operativos modernos utilizan una técnica llamada **memoria virtual**. Esta técnica permite que un proceso tenga un espacio de **direcciones más grande que la memoria física real**, dividiendo el espacio de direcciones en partes que se mantienen en la memoria principal y en el disco duro. El sistema operativo gestiona el **movimiento de estos fragmentos entre la memoria principal y el disco** según sea necesario.


## Sistema de Archivos
El **sistema de archivos** es un concepto esencial en los sistemas operativos. Su función principal es ocultar las peculiaridades de los dispositivos de E/S (*entrada/salida*) y ofrecer al programador una **vista abstracta de los archivos, independiente del dispositivo físico**. Para interactuar con los archivos, el sistema operativo proporciona llamadas para **crear, eliminar, leer y escribir en ellos**. Además, los archivos se organizan en **directorios** que agrupan los archivos de forma jerárquica. Cada directorio puede contener archivos o subdirectorios, y la estructura jerárquica permite representar archivos a través de rutas, como `/Docentes/Prof.Brown/Cursos/CS101` en UNIX.

![[archivos/imagenes/Pasted image 20241116173021.png]]

El sistema de archivos puede estar **montado**, lo que significa que un dispositivo, como un CD-ROM o disco duro externo, se conecta al sistema de archivos principal. Por ejemplo, el comando `mount` permite que el contenido de un dispositivo sea accesible dentro de la estructura de directorios.

Otro concepto importante son los **archivos especiales**, que permiten tratar a los dispositivos de E/S (*como impresoras o discos*) como archivos. Existen dos tipos de archivos especiales: de **bloques** (*para dispositivos de almacenamiento*) y de **carácter** (*para dispositivos de flujo continuo, como impresoras*). Estos archivos especiales se ubican generalmente en el directorio `/dev` en UNIX.

Además, en UNIX, los **canales** (*pipes*) permiten la **comunicación entre procesos**. Un canal actúa como un archivo que conecta la salida de un proceso con la entrada de otro, facilitando la comunicación entre ellos mediante operaciones de lectura y escritura. Los canales permiten una forma sencilla de intercomunicación entre procesos, similar a la manipulación de archivos convencionales.

En resumen, el sistema de archivos es fundamental para la gestión de archivos y dispositivos en un sistema operativo, y su estructura jerárquica, la capacidad de montar dispositivos y los archivos especiales son componentes clave que se desarrollan más a fondo en los capítulos posteriores.

## Entrada 
Las computadoras tienen dispositivos físicos para la **entrada** y **salida** de información, como teclados, monitores e impresoras. Estos dispositivos permiten que los usuarios interactúen con la computadora, indicándole qué hacer y obteniendo los resultados de su trabajo. Es responsabilidad del sistema operativo gestionar estos dispositivos a través de un **subsistema de entrada/salida (E/S)**.

![[archivos/imagenes/Pasted image 20241116173309.png]]

El subsistema de E/S está compuesto por software que puede ser **independiente de los dispositivos** (aplicable a varios dispositivos) y software **específico para dispositivos** (como los drivers, que son programas diseñados para manejar dispositivos específicos). El sistema operativo coordina estos elementos para asegurar la correcta interacción con los dispositivos de entrada y salida.

## Protección
Las computadoras almacenan gran cantidad de información sensible que debe protegerse y mantenerse confidencial, como correos electrónicos, planes de negocios y declaraciones fiscales. El sistema operativo tiene la responsabilidad de gestionar la **seguridad** del sistema, asegurando que solo los usuarios autorizados puedan acceder a ciertos archivos.

En el sistema operativo **UNIX**, los archivos están protegidos mediante un **código de protección binario de 9 bits**. Este código se divide en tres campos de 3 bits: uno para el propietario, uno para los miembros del grupo del propietario, y otro para todos los demás usuarios. Cada campo tiene bits para los permisos de **lectura**, **escritura** y **ejecución**. Por ejemplo, el código `rwxr-x--x` permite que el propietario tenga acceso completo, los miembros del grupo puedan leer y ejecutar, y todos los demás solo puedan ejecutar el archivo.

## Shell
El **shell** es un **intérprete de comandos** que actúa como una **interfaz entre el usuario y el sistema operativo**. Aunque no es parte central del sistema operativo, el shell utiliza muchas de sus características y permite a los usuarios interactuar con él mediante comandos escritos. A través del shell, los usuarios pueden ejecutar programas, gestionar archivos y realizar tareas en el sistema operativo.

Cuando un usuario inicia sesión en el sistema, se inicia automáticamente un shell. Este shell muestra un **indicador de comandos** (generalmente un símbolo como `$`), que señala que está esperando a que el usuario ingrese un comando. Por ejemplo, al escribir `date`, el shell crea un proceso hijo para ejecutar el comando y, una vez que termina, muestra nuevamente el indicador.

#### Funcionalidades clave del shell:
1. **Redirección de entrada y salida**: 
   - La **salida estándar** de un programa puede ser redirigida a un archivo, como `date > archivo`, donde la salida del comando `date` se guarda en un archivo.
   - De manera similar, la **entrada estándar** puede redirigirse desde un archivo: `sort < archivo1 > archivo2` ordena las líneas de `archivo1` y guarda la salida en `archivo2`.

2. **Canales (pipes)**: 
   - Se pueden conectar varios programas para que la salida de uno sirva como entrada para otro. Por ejemplo: `cat archivo1 archivo2 archivo3 | sort > /dev/lp` concatena los archivos y los ordena antes de enviarlos a la impresora (`/dev/lp`).

3. **Ejecutar en segundo plano**:
   - Si se coloca un `&` al final de un comando, el shell no espera a que termine. En vez de eso, ejecuta el comando en segundo plano, permitiendo que el usuario siga trabajando en otras tareas.

4. **Interfaz gráfica de usuario (GUI)**:
   - Las **GUI** (*como GNOME o KDE en Linux, o Windows Explorer en Windows*) son programas que también se ejecutan sobre el sistema operativo, como si fueran **shells gráficos**. Esto permite a los usuarios interactuar con el sistema de manera visual en lugar de por comandos de texto.

En resumen, el shell es una herramienta poderosa que permite interactuar con el sistema operativo, ejecutar programas y realizar diversas operaciones a través de comandos, y a pesar de ser un programa adicional, usa y facilita muchas de las funcionalidades del sistema operativo.s.

# Llamadas al Sistema
SI un programa de usuario en **modo usuario** necesita un servicio del sistema, como **leer del disco** ejecuta un **trap** para pasar el SO. Después este averigua que quiere el proceso llamador, lleva a cabo la llamada al sistema y devuelve el control a la siguiente instrucción.

Una **llamada al sistema** (system call) es el mecanismo que permite a los programas en modo usuario solicitar servicios o recursos del sistema operativo en modo kernel.

Por ejemplo tenemos un programa y se va a ejecutar la llamada:
`cuenta= read(fd, buffer, nbytes)`

> [!Nota]
> `printf()`es una función de una librería que usa la llamada al sistema `write`

- El programa de usuario **llamador** introduce los datos en la **pila**
- Se llama al procedimiento `read` de la **biblioteca** correspondiente.
- El código de la librería coloca en un **registro** el número de llamada correspondiente para que el SO pueda determinar que hacer con ella.
- Se ejecuta el **trap** para cambiar a **modo kernel** y así poder empezar la ejecución en una dirección de memoria fija en el **kernel**.
- El en el **kernel**, el **despachador** analiza el número de la llamada y a través de una **tabla de apuntadores** a **manejadores de llamadas** indexados en base al número de llamada, se pasa el control al manejador de llamada correspondiente
- Se ejecuta el **manejador de esa llamada**.
- Cuando acaba su trabajo, **el control se devuelve** al procedimiento de la biblioteca
- Después este procedimiento vuelve al programa de usuario
- Se incremente el libera la pila incrementando el **SP**.

![[archivos/imagenes/Pasted image 20241116180342.png]]
> [!IMPORTANTE] 
> Esta imagen cayó en un final

## Consideraciones:
- **Bloqueo de procesos**: Si la llamada al sistema necesita esperar (por ejemplo, leer de un archivo que no tiene datos disponibles en ese momento), el proceso puede bloquearse. Mientras tanto, el sistema operativo puede ejecutar otros procesos.
- **Verificación de errores**: Es fundamental que los programas verifiquen el resultado de las llamadas al sistema. Si ocurre un error (como un archivo no encontrado), la llamada al sistema devuelve un valor de error, y el programa puede consultar la variable global `errno` para obtener más detalles.


## Miscelánea de Llamadas al Sistema
![[archivos/imagenes/Pasted image 20241116181028.png]]


# Estructura del Sistema Operativo UNIX

![[archivos/imagenes/Pasted image 20241117130107.png]]

La imagen describe la **estructura del sistema operativo UNIX** de forma jerárquica, dividiendo sus componentes en tres niveles principales: **usuario**, **núcleo (kernel)** y **hardware**. A continuación, te explico cada nivel y cómo interactúan entre ellos:

### **1. Nivel de Usuario**
Este es el nivel más alto de la estructura, donde interactúan los usuarios y los programas.

- **Programas:** 
  Son las aplicaciones o procesos que los usuarios ejecutan, como editores de texto, navegadores o compiladores. Estos programas requieren servicios del sistema operativo, como leer archivos, escribir datos o manejar memoria.

- **Librerías:**  
  Son colecciones de funciones que facilitan la interacción de los programas con el núcleo. Muchas de estas funciones invocan llamadas al sistema, pero lo hacen de manera más accesible para el programador.  
  Ejemplo: La función de biblioteca `printf()` en C puede usar una llamada al sistema como `write` para escribir datos en la salida estándar.

- **Trap:**  
  Es el mecanismo mediante el cual un programa solicita servicios al núcleo, desencadenando una **llamada al sistema**. Cuando un trap ocurre, se transfiere el control desde el programa en modo usuario hacia el núcleo en modo privilegiado.

---

### **2. Nivel del Núcleo (Kernel)**
El núcleo es el corazón del sistema operativo. Se encarga de manejar los recursos de hardware y proporcionar servicios esenciales a los programas en el nivel de usuario.

- **Interfaz de llamadas al sistema:**  
  Es el punto de entrada al núcleo desde el nivel de usuario. Los programas utilizan llamadas al sistema para realizar operaciones como abrir un archivo, crear un proceso o asignar memoria.

- **Subsistema de ficheros:**  
  Maneja todo lo relacionado con la administración de archivos, como:
  - Creación, apertura, lectura, escritura y cierre de archivos.
  - Gestión de permisos y atributos.
  - Organización de los datos en el disco (mediante sistemas de archivos).

- **Caché de buffers:**  
  Es una memoria intermedia que almacena temporalmente datos de E/S (entrada/salida) para mejorar el rendimiento. Permite minimizar las operaciones directas en el disco al almacenar información frecuentemente utilizada.

- **Drivers de dispositivos (modo carácter y modo bloque):**  
  - **Modo carácter:** Maneja dispositivos que transmiten datos en forma de flujo continuo, como un teclado o un ratón.
  - **Modo bloque:** Maneja dispositivos que transmiten datos en bloques, como discos duros. Estos controladores convierten las solicitudes del subsistema de ficheros en comandos entendibles por el hardware.

- **Subsistema de control de procesos:**  
  Este subsistema gestiona los procesos que se ejecutan en el sistema, incluyendo:
  - **Comunicación entre procesos (IPC):** Permite que los procesos se comuniquen entre sí mediante mecanismos como tuberías, colas de mensajes o memoria compartida.
  - **Planificador:** Decide qué proceso obtiene tiempo de CPU y durante cuánto tiempo, según algoritmos de planificación.
  - **Administración de memoria:** Se encarga de asignar y gestionar la memoria utilizada por los procesos, permitiendo funciones como la paginación o la segmentación.

- **Control del hardware:**  
  El núcleo traduce las solicitudes del subsistema de ficheros y de procesos en comandos para el hardware. Aquí, los controladores de dispositivos juegan un rol crucial para establecer esta comunicación.

---

### **3. Nivel de Hardware**
Este nivel incluye los dispositivos físicos de la computadora, como:
- CPU.
- Memoria.
- Dispositivos de almacenamiento (discos duros, SSDs).
- Dispositivos de entrada/salida (teclados, pantallas, impresoras).

El núcleo actúa como un puente entre el hardware y los programas del nivel de usuario, garantizando que los recursos del sistema sean usados de manera segura y eficiente.

---

### **Relación entre niveles**
1. Los programas de usuario realizan solicitudes al sistema operativo mediante **llamadas al sistema** (a través de traps), que son procesadas por el núcleo.
2. El núcleo, en función de la solicitud, interactúa con los distintos subsistemas y controladores para cumplir las peticiones.
3. El núcleo se comunica directamente con el hardware para acceder a dispositivos o ejecutar operaciones de bajo nivel.

![[archivos/imagenes/Pasted image 20241117130215.png]]

Esta estructura jerárquica asegura una clara separación entre las aplicaciones del usuario y el hardware, proporcionando seguridad, eficiencia y un entorno multitarea robusto.



![[archivos/imagenes/Pasted image 20241117130954.png]]
La imagen describe la **estructura del núcleo del sistema operativo Linux**, organizada en componentes funcionales que interactúan para gestionar los recursos del sistema y atender las solicitudes de los programas de usuario. Aquí tienes una explicación de cada parte:

### **1. System Calls (Llamadas al sistema)**
Las llamadas al sistema son el principal mecanismo de comunicación entre las aplicaciones en el espacio de usuario y el núcleo.  
- Proveen acceso controlado a recursos como archivos, memoria y dispositivos.
- Los procesos solicitan servicios del núcleo mediante estas llamadas.

Ejemplos de llamadas al sistema incluyen:
- Operaciones de E/S: `read`, `write`.
- Manejo de procesos: `fork`, `exec`.
- Gestión de memoria: `mmap`, `brk`.

---

### **2. I/O Component (Componente de Entrada/Salida)**
Este componente gestiona todas las operaciones relacionadas con dispositivos de entrada/salida, como discos, terminales y redes. Se basa en una abstracción conocida como **sistema de archivos virtual (VFS)**, que permite un acceso uniforme a diferentes sistemas de archivos y dispositivos.

- **Virtual File System (Sistema de archivos virtual):**  
  Es una capa de abstracción que unifica el acceso a diferentes sistemas de archivos (ext4, FAT32, NTFS) y dispositivos.  
  - **File Systems:** Maneja la organización de datos en discos y otros medios de almacenamiento.
  - **Generic Block Layer:** Proporciona una interfaz genérica para operaciones con bloques de datos, como lectura/escritura en discos.
  - **I/O Scheduler:** Organiza y optimiza las operaciones de E/S para mejorar el rendimiento.
  - **Block Device Drivers:** Controlan dispositivos que operan en bloques, como discos duros y SSDs.

- **Character Device Drivers:**  
  Manejan dispositivos que envían o reciben datos como un flujo continuo (por ejemplo, teclados o ratones).

- **Sockets y Network Protocols:**  
  Estos elementos habilitan la comunicación en red mediante protocolos como TCP/IP, proporcionando conectividad y transferencia de datos entre máquinas.

---

### **3. Memory Management Component (Gestión de Memoria)**
Este componente es responsable de administrar la memoria física y virtual del sistema.

- **Virtual Memory (Memoria virtual):**  
  Permite que cada proceso tenga su propio espacio de direcciones, independientemente de la memoria física disponible. Implementa paginación para cargar solo las partes necesarias de un programa en memoria.

- **Paging y Page Replacement:**  
  Gestionan la asignación de páginas de memoria. Cuando no hay memoria física suficiente, se reemplazan páginas menos utilizadas (swap) para liberar espacio.

- **Page Cache:**  
  Es una memoria intermedia para datos frecuentemente accedidos en discos, mejorando el rendimiento al reducir las operaciones de E/S directas.

---

### **4. Process Management Component (Gestión de Procesos)**
Este componente administra los procesos y su ejecución.

- **Signal Handling (Manejo de señales):**  
  Permite la comunicación entre procesos y el manejo de eventos. Las señales son notificaciones que interrumpen un proceso para ejecutar una acción específica (por ejemplo, `SIGINT` para interrumpir un proceso).

- **Process/Thread Creation & Termination:**  
  Cubre la creación de procesos (`fork`), su terminación (`exit`) y la gestión de subprocesos (threads).

- **CPU Scheduling (Planificación de la CPU):**  
  Decide qué proceso o hilo obtiene acceso al procesador y durante cuánto tiempo. Esto es crucial para implementar multitarea y garantizar un uso eficiente de los recursos.

---

### **5. Interrupts (Interrupciones)**
Las interrupciones son señales enviadas por hardware o software que requieren atención inmediata del núcleo.  
- El núcleo pausa la ejecución actual para manejar la interrupción mediante un controlador.
- Ejemplo: Una tecla presionada en el teclado genera una interrupción que el núcleo debe procesar.

---

### **6. Dispatcher**
El despachador es responsable de transferir el control del procesador entre diferentes procesos.  
- Actúa como el "coordinador" que asegura una ejecución fluida y eficiente de múltiples tareas.
- Se basa en las decisiones del planificador para asignar tiempo de CPU.

---

### **Resumen de la estructura**
El núcleo de Linux está organizado en módulos especializados que trabajan en conjunto para:
1. Gestionar procesos y recursos.
2. Manejar la memoria de manera eficiente.
3. Abstraer las operaciones de entrada/salida.
4. Responder a interrupciones de hardware y software.

Esta modularidad y abstracción hacen que Linux sea altamente eficiente, flexible y adaptable a diferentes plataformas y usos.