En C, los hilos (threads) permiten ejecutar múltiples tareas en paralelo dentro de un mismo proceso, mejorando la eficiencia en programas con operaciones concurrentes. Usar hilos es útil en aplicaciones que requieren realizar varias tareas simultáneamente, como en servidores web, programas de procesamiento de datos, y simulaciones.

### 1. Configuración del Entorno de Hilos
En C, la librería **POSIX Threads (pthreads)** es la más común para trabajar con hilos. Para utilizarla, incluye el encabezado:

```c
#include <pthread.h>
```

Además, compila el programa con la opción `-lpthread` para enlazar la librería de hilos:

```bash
gcc -o programa programa.c -lpthread
```

### 2. Creación de Hilos
Para crear un hilo, usa la función `pthread_create`, que necesita los siguientes parámetros:

- **Identificador del hilo**: un puntero a `pthread_t`, donde se almacenará el ID del hilo.
- **Atributos**: típicamente `NULL` para los valores predeterminados.
- **Función a ejecutar**: una función que el hilo ejecutará, de tipo `void *(*func)(void *)`.
- **Argumento**: un puntero a los datos que quieres pasar a la función.

Ejemplo de uso:

```c
#include <pthread.h>
#include <stdio.h>

void *funcion_hilo(void *arg) {
    int valor = *(int *)arg;  // Conversión de void* a int*
    printf("Hola desde el hilo, valor recibido: %d\n", valor);
    pthread_exit(NULL);  // Finaliza el hilo
}

int main() {
    pthread_t hilo;  // Identificador del hilo
    int argumento = 5;

    // Crear hilo
    if (pthread_create(&hilo, NULL, funcion_hilo, &argumento) != 0) {
        perror("Error al crear el hilo");
        return 1;
    }

    pthread_join(hilo, NULL);  // Espera a que el hilo termine
    return 0;
}
```

### 3. Sincronización entre Hilos
Al trabajar con múltiples hilos que acceden a recursos compartidos, es crucial evitar **condiciones de carrera** (race conditions), donde los hilos intentan modificar los mismos datos simultáneamente. Para controlar el acceso concurrente a estos recursos, se usan mecanismos de sincronización, como los **mutexes**.

#### Usando Mutexes

Un **mutex** (de "mutual exclusion") es un tipo de bloqueo que asegura que solo un hilo puede acceder a una sección crítica a la vez. Para usar un mutex:

1. Declara e inicializa el mutex.
2. Bloquea el mutex antes de acceder a la sección crítica.
3. Desbloquea el mutex al salir de la sección crítica.
4. Destruye el mutex al finalizar.

Ejemplo:

```c
#include <pthread.h>
#include <stdio.h>

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;  // Inicialización del mutex
int contador = 0;

void *incrementar(void *arg) {
    pthread_mutex_lock(&mutex);   // Bloqueo del mutex
    contador++;
    printf("Contador incrementado a: %d\n", contador);
    pthread_mutex_unlock(&mutex); // Desbloqueo del mutex
    pthread_exit(NULL);
}

int main() {
    pthread_t hilos[5];

    // Crear múltiples hilos
    for (int i = 0; i < 5; i++) {
        pthread_create(&hilos[i], NULL, incrementar, NULL);
    }

    // Esperar a que todos los hilos terminen
    for (int i = 0; i < 5; i++) {
        pthread_join(hilos[i], NULL);
    }

    pthread_mutex_destroy(&mutex); // Destruir el mutex
    printf("Valor final del contador: %d\n", contador);
    return 0;
}
```

### 4. Variables de Condición
Las **variables de condición** permiten a los hilos suspenderse y esperar a que se cumpla una condición específica antes de continuar. Se utilizan junto con los mutexes.

Ejemplo de productor-consumidor usando variables de condición:

```c
#include <pthread.h>
#include <stdio.h>

#define MAX_ITEMS 5

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
int buffer[MAX_ITEMS];
int count = 0;

void *productor(void *arg) {
    for (int i = 0; i < MAX_ITEMS; i++) {
        pthread_mutex_lock(&mutex);
        buffer[count++] = i;
        printf("Produjo: %d\n", i);
        pthread_cond_signal(&cond);   // Notifica al consumidor
        pthread_mutex_unlock(&mutex);
    }
    pthread_exit(NULL);
}

void *consumidor(void *arg) {
    for (int i = 0; i < MAX_ITEMS; i++) {
        pthread_mutex_lock(&mutex);
        while (count == 0) {  // Espera hasta que haya algo en el buffer
            pthread_cond_wait(&cond, &mutex);
        }
        int item = buffer[--count];
        printf("Consumió: %d\n", item);
        pthread_mutex_unlock(&mutex);
    }
    pthread_exit(NULL);
}

int main() {
    pthread_t hilo_productor, hilo_consumidor;

    pthread_create(&hilo_productor, NULL, productor, NULL);
    pthread_create(&hilo_consumidor, NULL, consumidor, NULL);

    pthread_join(hilo_productor, NULL);
    pthread_join(hilo_consumidor, NULL);

    pthread_mutex_destroy(&mutex);
    pthread_cond_destroy(&cond);
    return 0;
}
```

### 5. Finalización de Hilos
Para finalizar un hilo:

- **`pthread_exit`**: termina el hilo y opcionalmente devuelve un valor.
- **`pthread_join`**: espera a que un hilo específico termine, similar a `wait` para procesos.

### 6. Resumen de Funciones Básicas de `pthread`

| Función                 | Descripción                                                           |
| ----------------------- | --------------------------------------------------------------------- |
| `pthread_create`        | Crea un nuevo hilo.                                                   |
| `pthread_exit`          | Termina un hilo.                                                      |
| `pthread_join`          | Espera a que un hilo específico termine.                              |
| `pthread_mutex_init`    | Inicializa un mutex.                                                  |
| `pthread_mutex_lock`    | Bloquea un mutex para asegurar acceso exclusivo a la sección crítica. |
| `pthread_mutex_unlock`  | Desbloquea un mutex.                                                  |
| `pthread_mutex_destroy` | Destruye un mutex.                                                    |
| `pthread_cond_init`     | Inicializa una variable de condición.                                 |
| `pthread_cond_wait`     | Suspende un hilo hasta que se cumple una condición.                   |
| `pthread_cond_signal`   | Notifica a un hilo suspendido en una condición que puede continuar.   |
| `pthread_cond_destroy`  | Destruye una variable de condición.                                   |
|                         |                                                                       |

### Conclusión
Programar con hilos en C permite ejecutar tareas en paralelo, aumentando la eficiencia y capacidad de respuesta del programa. Sin embargo, manejar correctamente la sincronización es clave para evitar problemas de concurrencia.