Las **señales** son un mecanismo de comunicación **asíncrono** utilizado en los sistemas operativos basados en POSIX para notificar a un proceso de eventos del sistema o para sincronización entre procesos. Son esenciales para **manejar interrupciones, errores y acciones específicas del sistema operativo o de otros procesos.**

# **Características principales de las señales**
1. **Identificación:**
   - Las señales se identifican mediante **enteros** (números) que representan eventos específicos.
   - También se utilizan **constantes simbólicas** (ej., `SIGKILL`, `SIGTERM`) para facilitar su uso.

2. **Finalidad:**
   - **Notificar eventos:** Señalar que ocurrió algo relevante, como un temporizador que expiró.
   - **Control de procesos:** Finalizar, suspender, o reanudar un proceso.
   - **Sincronización:** Coordinar procesos, como en el caso de señales definidas por el usuario (`SIGUSR1`, `SIGUSR2`).

3. **Comportamiento:**
   - Para la mayoría de las señales, se puede definir un manejador específico (custom signal handler) que ejecute acciones personalizadas.
   - Algunas señales (como `SIGKILL`) no se pueden ignorar ni manejar de forma personalizada.

#### **Señales comunes en POSIX**
| Señal      | Descripción                                                                 |
|------------|-----------------------------------------------------------------------------|
| **SIGABRT**| Solicita que el proceso aborte y genere un núcleo de depuración (*core dump*).|
| **SIGALRM**| Indica que expiró un temporizador configurado por el proceso.               |
| **SIGFPE** | Error matemático (como división por cero o error de punto flotante).        |
| **SIGHUP** | Indica que se desconectó la terminal o línea telefónica asociada.           |
| **SIGILL** | Instrucción ilegal detectada en el proceso.                                 |
| **SIGKILL**| Termina el proceso inmediatamente (no se puede capturar ni ignorar).       |
| **SIGPIPE**| Escritura en un *pipe* sin lectores activos.                                |
| **SIGSEGV**| Violación de memoria (acceso a una dirección no válida).                   |
| **SIGTERM**| Solicita la finalización ordenada del proceso.                             |
| **SIGUSR1**| Señal personalizada definida por el usuario.                               |
| **SIGUSR2**| Otra señal personalizada para propósitos definidos por el usuario.         |

# **Generación de señales**
Las señales pueden generarse por diferentes causas:
1. **Acciones del usuario:**
   - Pulsar teclas específicas como `Ctrl+C` (`SIGINT`) o `Ctrl+\` (`SIGQUIT`).
2. **Eventos del sistema:**
   - Temporizadores (`SIGALRM`), acceso inválido a memoria (`SIGSEGV`), etc.
3. **Otros procesos:**
   - Usando la llamada al sistema `kill()` para enviar una señal a un proceso.

```c
int kill(pid_t pid, int sig);
```
- **`pid`**: Identifica el proceso al que se envía la señal.
- **`sig`**: Especifica la señal a enviar.

# **Manejo de señales**
El sistema operativo proporciona funciones para manejar señales:
1. **Definir un manejador con `signal`:**
   Permite asignar un manejador (*función*) personalizado para una señal.

   ```c
   sighandler_t signal(int signum, sighandler_t handler);
   ```
   - **`signum`**: Señal a manejar (ej., `SIGTERM`).
   - **`handler`**: Acción asociada (puede ser:
     - `SIG_DFL`: Acción predeterminada.
     - `SIG_IGN`: Ignorar la señal.
     - Una función definida por el usuario).

2. **Uso avanzado con `sigaction`:**
   Ofrece mayor control sobre las acciones de las señales.

   ```c
   int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);
   ```
   - **`act`**: Define la nueva acción.
   - **`oldact`**: Guarda la acción anterior.

```C
#include <signal.h>
#include <stdio.h>

// Definimos un manejador (gestor) para las señales
void gestor(int signo) {
    printf("Señal recibida: %d\n", signo);
}

int main() {
    // Declaramos conjuntos de señales para bloquear y verificar señales pendientes
    sigset_t bloqueo, pendientes;

    // Estructura para manejar las acciones de las señales
    struct sigaction sa;

    // Configuramos el manejador para las señales
    sa.sa_handler = gestor;           // Asignamos la función 'gestor' como manejador de la señal
    sa.sa_flags = SA_RESTART;         // Reinicia llamadas al sistema interrumpidas por señales
    sigemptyset(&sa.sa_mask);         // Limpia la máscara de señales de esta acción

    // Asignamos la acción a las señales SIGUSR1, SIGUSR2 y SIGINT
    sigaction(SIGUSR1, &sa, NULL);
    sigaction(SIGUSR2, &sa, NULL);
    sigaction(SIGINT, &sa, NULL);

    // Inicializamos el conjunto de señales de bloqueo y añadimos SIGUSR1
    sigemptyset(&bloqueo);
    sigaddset(&bloqueo, SIGUSR1);

    // Bloqueamos las señales del conjunto 'bloqueo' (en este caso, SIGUSR1)
    sigprocmask(SIG_BLOCK, &bloqueo, NULL);

    // Verificamos señales pendientes
    sigpending(&pendientes); // Llenamos 'pendientes' con las señales que están en espera

    // Comprobamos si SIGUSR1 está en el conjunto de señales pendientes
    if (sigismember(&pendientes, SIGUSR1)) {
        printf("SIGUSR1 está pendiente\n");
    }

    // Desbloqueamos SIGUSR1
    sigprocmask(SIG_UNBLOCK, &bloqueo, NULL);

    return 0;
}
```

---

### **Otros mecanismos asociados**
1. **Alarma (`alarm`):**
   Configura un temporizador que envía `SIGALRM` cuando expira.

   ```c
   unsigned int alarm(unsigned int seconds);
   ```
   Ejemplo: `alarm(5)` enviará `SIGALRM` al proceso después de 5 segundos.

2. **Suspender con `pause`:**
   **Suspende** el proceso hasta que reciba una señal.

   ```c
   int pause(void);
   ```

---

### **Resumen**
- **Señales** son herramientas potentes para la comunicación y sincronización asíncrona en sistemas POSIX.
- **Envío:** Con `kill`.
- **Manejo:** Con `signal`, `sigaction`, y otros.
- **Usos:** Finalización de procesos, temporizadores, manejo de errores y comunicación entre procesos.
