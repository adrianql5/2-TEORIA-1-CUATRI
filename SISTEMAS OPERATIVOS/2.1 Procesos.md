# Crear un proceso
Usamos la llamada al sistema `fork()` que devuelve `-1` si hubo un error al crear el proceso hijo, `0` si se trata del proceso hijo y el **pid** si se trata del proceso **padre** (*creador*).

```C
int main(){
	pid_t hijo;

	hijo=fork();

	if(hijo==0){
		//Código del hijo
	}

	else{
		//Código del padre
	}
}
```

## Ejemplos avanzados de creación de procesos

```C 
//Crear un arbol de procesos de tamaño N

int main(){
	pid_t pid;
	for(int i =0; i<N; i++){
		pid=fork();
	}
}

//Crear un padre con N hijos
int main(){
	int espadre;
	pid_t arr[i];

	for(int i=0; i<N; i++){
		espadre=1;
		for(int j=0; j<N; j++){
			if(!H[j]) espadre=0;
		}
		
		if(espadre){
			arr[i]=fork();
		}	
	}
}

//Crear un padre de n hijo, nieto, bisnieto...
int main(){
	pid_t arr[i];
	int espadre=1;
	for(int i=0; i<n; i++){
		if(espadre){
			arr[i]=fork();
			if(!arr[i]){
				espadre=0;
			}
		}
	}
}
```

# Terminación de un proceso
**Termina de forma voluntaria invocado a `exit` o a `return`**.

> [!Importante]
> **Tipos de procesos:**
> - **Proceso Zombi:** proceso que **ya ha terminado su tarea**, es decir, está muerto, pero no ha sido eliminado del sistema, es decir, sigue en la tabla de procesos. Esto se debe a que los procesos solo se borran de la tabla cuando su padre finaliza o hasta que ejecute un **wait** o **waitpid** asociado a él. Todos los procesos al acabar pasan a ser **zombies** hasta que se realice una de las dos acciones que provocan su eliminación de la tabla de procesos
> 
> - **Proceso huérfano:** es posible que un proceso padre cree a un hijo y **finalice antes el padre que el hijo**, creando así un hijo **huérfano**. Cuando un huérfano finaliza, **no se convierte en zombi** porque ya no tiene un padre que esté esperando por él, a pesar de haber sido adoptado, por que lo una ver terminado **se elimina directamente de la tabla de procesos**. Los procesos huérfanos son adoptados por el **proceso init**

# Esperar a que termine un proceso
## Wait:
  ```c
  pid_t wait(int *status);
  ```

  - `int *status`: Dirección de memoria donde se almacenará el estado de finalización del proceso hijo.

- **Retorno:**
  - Devuelve el **PID** del hijo que terminó.
  - Retorna **-1** si ocurre un error, por ejemplo:
    - El proceso no tiene hijos activos.
    - Una señal interrumpe la llamada.

- **Comportamiento:**
  - **El proceso padre se bloquea** (queda en espera) hasta que cualquiera de sus procesos hijos finalice.


## ** WaitPid**
  ```c
  pid_t waitpid(pid_t pid, int *stat_loc, int options);
  ```
  
  - `pid`: Identifica al proceso hijo específico que se está esperando:
    - **-1:** Espera a cualquier hijo (similar a `wait`).
    - **PID específico:** Espera por ese hijo en particular.
  - `int *stat_loc`: Igual que en `wait`, almacena el estado del proceso hijo.
  - `options`: Opciones adicionales que controlan el comportamiento de la función, como:
    - `WNOHANG`: No bloquea al padre; si no hay procesos que hayan terminado, regresa de inmediato.

- **Retorno:**
  - Devuelve el PID del hijo esperado que terminó.
  - Retorna **0** si no hay procesos finalizados y se utiliza `WNOHANG`.
  - Retorna **-1** en caso de error.



## **Estado de finalización del hijo (`status`):**
El contenido del parámetro `status` puede ser interpretado mediante macros como:
- **`WIFEXITED(status)`**: Devuelve verdadero si el hijo terminó normalmente.
- **`WEXITSTATUS(status)`**: Recupera el código de salida del hijo si terminó normalmente.
- **`WIFSIGNALED(status)`**: Devuelve verdadero si el hijo terminó debido a una señal.
- **`WTERMSIG(status)`**: Recupera la señal que terminó al hijo.

# **Invocación de otros programas**
Cuando un proceso necesita reemplazar su contenido actual (código, datos, pila) con el de un programa diferente, utiliza funciones de la familia `exec`. Una de las más generales es **`execve`**.

#### **Uso de `execve`**
  ```c
  int execve(const char *path, char *const argv[], char *const envp[]);
  ```

  - `const char *path`: Ruta al archivo ejecutable que se desea cargar.
  - `char *const argv[]`: Arreglo de cadenas que representa los argumentos del programa.
    - El primer argumento suele ser el nombre del programa.
    - Equivalente a los argumentos del `main(argc, argv)` en C.
  - `char *const envp[]`: Arreglo de cadenas que representan el entorno del programa.
    - Equivalente a `envp` en C, contiene variables de entorno.

- **Funcionamiento:**
  - Reemplaza completamente el contenido del proceso actual con el del programa especificado.
  - No crea un nuevo proceso; el proceso actual mantiene su PID.
  - Si tiene éxito, **no regresa**, ya que el proceso anterior deja de existir.
  - Si falla (por ejemplo, el archivo no existe o no tiene permisos), retorna **-1**.

- **Casos de uso:**
  - Un shell típico usa `fork` para crear un proceso hijo y luego `execve` en el hijo para ejecutar el comando que el usuario solicita.

> **Ejemplo típico:**
```c
#include <unistd.h>
#include <stdio.h>

int main() {
    char *argv[] = { "/bin/ls", "-l", NULL };
    char *envp[] = { NULL };
    
    if (execve("/bin/ls", argv, envp) == -1) {
        perror("execve failed");
    }
    return 0;
}
```
En este ejemplo:
- Se ejecuta el comando `ls -l`.
- El proceso actual se reemplaza por el programa `ls`.
- Si `execve` falla, imprime un mensaje de error.

Esto viene siendo lo mismo que **cambiar la imagen del proceso**

Un **proceso** se compone de varias regiones en memoria:

- **Código**: Instrucciones que el proceso ejecuta.
- **Datos**: Variables y estructuras de datos que utiliza.
- **Pila (stack)**: Espacio para llamadas a funciones, parámetros y variables locales.
- **Segmento de entorno**: Variables de entorno y configuración del sistema.

Cuando cambiamos la imagen de un proceso, **se reemplazan todas estas regiones con las correspondientes al programa nuevo**, manteniendo el mismo **PID**. Es como si el proceso existente se "transformara" en otro programa.

En sistemas basados en UNIX, esto se logra con las funciones de la familia `exec`, como `execve`, `execl`, `execvp`, etc. Estas funciones:

1. Descargan la imagen actual del proceso (su código, datos, pila y demás).
2. Cargan en su lugar la imagen del programa especificado.
3. Inician la ejecución del nuevo programa desde su punto de entrada (generalmente la función `main`).

Cambiar la imagen de un proceso es diferente de crear uno nuevo porque:

- **No se genera un nuevo PID**: El proceso original sigue existiendo, pero con un contenido completamente distinto.
- **No se heredan las características del programa anterior**: Toda la memoria (código, datos, pila) se sobrescribe, excepto algunos atributos del sistema operativo como el PID o los descriptores de archivo abiertos.

**Utilidades:**
1. **Eficiencia**: En lugar de cerrar un proceso y abrir otro, se reutiliza el proceso existente.
2. **Control**: Permite que un programa, como un shell, controle la ejecución del nuevo programa (por ejemplo, esperar a que termine o manejar su salida).
3. **Simplicidad del diseño**: Un sistema operativo no necesita gestionar el cambio de contexto entre dos procesos diferentes.