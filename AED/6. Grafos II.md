[[archivos/bibliografia/7. GrafosII.pdf|7. GrafosII]]
[[archivos/bibliografia/ApuntesAED_070119184232.pdf|ApuntesAED_070119184232]]

### Ordenación Topológica
#### GDA - Grado Dirigido Acíclico

Un GDA (Grafo Dirigido Acíclico) es un tipo de grafo donde no existen ciclos, es decir, no hay caminos que comiencen y terminen en el mismo vértice. Este tipo de grafo es útil para representar procesos que tienen una secuencia o un orden, como una lista de tareas donde algunas dependen de otras.

Ejemplo:
Imagina que tienes que realizar tres tareas: 
1. Comprar ingredientes.
2. Cocinar.
3. Servir la comida.

Es claro que **no puedes cocinar antes de comprar ingredientes**, y no puedes servir antes de cocinar. Estas tareas se pueden representar en un GDA:

- Comprar ingredientes → Cocinar → Servir comida.
![[archivos/imagenes/Pasted image 20241104134833.png]]
#### Ordenación Topológica
La ordenación topológica es un orden lineal de los vértices en un GDA tal que si existe un camino de un vértice \( A \) a un vértice \( B \), entonces \( A \) aparece antes que \( B \) en el orden. Solo los GDAs permiten esta ordenación, pues un ciclo rompería la lógica del orden.

**Algoritmo para la Ordenación Topológica**:
1. Identifica los nodos con **grado entrante cero** (nodos sin arcos que lleguen a ellos) y agrégalos a una cola.
2. Extrae el vértice de la cola y añádelo a la ordenación.
3. Elimina todos los arcos salientes de ese vértice y actualiza los grados entrantes de los vértices afectados.
4. Repite hasta que la cola esté vacía.

#### Ejemplo Paso a Paso

Imagina un grafo con tareas interdependientes:
- Tarea A → Tarea B
- Tarea A → Tarea C
- Tarea B → Tarea D
- Tarea C → Tarea D

1. **Grado entrante 0**: \( A \).
2. Extraemos \( A \), lo ponemos en la ordenación y eliminamos sus arcos.
3. Ahora, \( B \) y \( C \) tienen grado 0. Los añadimos a la cola.
4. Continuamos este proceso hasta obtener un orden posible como: \( A \to B \to C \to D \).
![[archivos/imagenes/Pasted image 20241104134905.png]]
### 7.2 Cálculo de la Matriz de Caminos: Algoritmo de Warshall
### Algoritmo de Warshall: Explicación Completa para Cálculo de la Matriz de Caminos

El **Algoritmo de Warshall** es un método de programación dinámica que se usa para calcular la **matriz de caminos** en un grafo. La matriz de caminos indica la conectividad entre todos los pares de vértices: en cada posición \((i, j)\), el valor es 1 si hay un camino desde el vértice \(i\) al vértice \(j\), y 0 si no lo hay. Este algoritmo permite conocer si dos vértices están conectados directamente o a través de otros vértices intermedios.

#### 1. Preparación del Algoritmo de Warshall

Para empezar, supongamos que tenemos un grafo dirigido representado mediante una **matriz de adyacencia**, en la cual:

- Si existe un arco directo de un vértice \(i\) a un vértice \(j\), entonces la posición \((i, j)\) en la matriz de adyacencia es 1.
- Si no hay arco directo, la posición \((i, j)\) es 0.

**Ejemplo inicial de la matriz de adyacencia para un grafo con tres vértices (1, 2 y 3):**

Supongamos un grafo con los siguientes arcos:
- 1 → 2
- 2 → 3

La matriz de adyacencia sería:
$$
\begin{bmatrix}
0 & 1 & 0 \\
0 & 0 & 1 \\
0 & 0 & 0 \\
\end{bmatrix}
$$

#### 2. Matriz de Caminos: Concepto

La **matriz de caminos** amplía esta información para reflejar todas las conexiones posibles, tanto directas como indirectas, entre los vértices. En otras palabras, si puedes ir del vértice \(i\) al vértice \(j\) pasando a través de otros vértices, la posición \((i, j)\) en la matriz de caminos se marcará como 1. 

El objetivo del algoritmo de Warshall es completar esta matriz de caminos.

#### 3. Cómo Funciona el Algoritmo de Warshall

La clave del algoritmo es una serie de pasos iterativos donde, en cada paso, se evalúa si un vértice intermedio \(k\) ayuda a conectar otros dos vértices \(i\) y \(j\).

##### Procedimiento del algoritmo:

1. **Inicialización**: Comienza con la matriz de adyacencia inicial, que refleja solo las conexiones directas. Esta será la base sobre la cual se construirá la matriz de caminos.

2. **Iteraciones**: Para cada vértice \(k\) del grafo, revisa cada par de vértices \(i\) y \(j\).
   
   - Si existe un camino desde \(i\) hasta \(k\) (es decir, si `matriz[i][k] = 1`) y también un camino desde \(k\) hasta \(j\) (`matriz[k][j] = 1`), entonces también existe un camino indirecto desde \(i\) hasta \(j\) a través de \(k\).
   - En este caso, se actualiza la matriz poniendo `matriz[i][j] = 1`.

3. **Repetición**: Este proceso se repite para cada vértice intermedio \(k\) en el grafo. Al final de las iteraciones, la matriz reflejará todos los caminos posibles entre los vértices.

##### Ejemplo de Aplicación del Algoritmo de Warshall

Supongamos que comenzamos con el siguiente grafo:
- $(1 \rightarrow 2)$
- $(2 \rightarrow 3)$

La matriz de adyacencia inicial es:
$$
\begin{bmatrix}
0 & 1 & 0 \\
0 & 0 & 1 \\
0 & 0 & 0 \\
\end{bmatrix}
$$

###### Iteración con \(k = 1\)
- Se evalúan todos los pares $((i, j))$, pero no hay cambios porque ningún par puede alcanzar otro vértice nuevo a través del vértice 1.

###### Iteración con \(k = 2\)
- Revisamos el par $((1, 3))$: 
  - Como $(1 \rightarrow 2)$ y $(2 \rightarrow 3)$, podemos deducir que existe un camino de $(1)$ a $(3)$ a través de \(2\).
  - Actualizamos `matriz[1][3]` a 1.

Ahora, la matriz de caminos es:
$$
\begin{bmatrix}
0 & 1 & 1 \\
0 & 0 & 1 \\
0 & 0 & 0 \\
\end{bmatrix}
$$

###### Iteración con \(k = 3\)
- Revisamos todos los pares \((i, j)\) nuevamente, pero no hay cambios adicionales, ya que el vértice 3 no ayuda a conectar otros vértices en este caso.

##### Resultado Final

Al finalizar el algoritmo, la matriz de caminos refleja todas las conexiones posibles en el grafo:

$$
\begin{bmatrix}
0 & 1 & 1 \\
0 & 0 & 1 \\
0 & 0 & 0 \\
\end{bmatrix}
$$

Esta matriz nos dice que:
- Existe un camino de 1 a 2 (valor en \((1, 2)\) es 1).
- Existe un camino de 1 a 3 (valor en \((1, 3)\) es 1) a través del vértice 2.
- Existe un camino de 2 a 3 (valor en \((2, 3)\) es 1).


![[archivos/imagenes/Pasted image 20241104134959.png]]
### 7.3 Camino más Corto entre un Par de Vértices: Algoritmo de Dijkstra

Dijkstra permite encontrar el **camino más corto** entre un vértice origen y todos los demás vértices en un grafo ponderado.

**Ejemplo:**
Considera las ciudades conectadas con costos de viaje:
- A → B (4), A → C (2), B → C (5), B → D (10), C → D (3)

1. Desde A, elige la ruta más corta entre ciudades adyacentes.
2. Actualiza el camino acumulado y selecciona la ciudad con el menor costo desde el inicio hasta ese punto.
3. Repite hasta recorrer todos los caminos.

Resultado: 
- Camino más corto de A a D sería \( A \to C \to D \) con costo 5.
![[archivos/imagenes/Pasted image 20241104135032.png]]
![[archivos/imagenes/Pasted image 20241104135049.png]]
![[archivos/imagenes/Pasted image 20241104135118.png]]
![[archivos/imagenes/Pasted image 20241104135135.png]]
![[archivos/imagenes/Pasted image 20241104135150.png]]
![[archivos/imagenes/Pasted image 20241104135206.png]]
### 7.4 Camino más Corto entre Cualquier Par de Vértices: Algoritmo de Floyd
El algoritmo de **Floyd-Warshall** es un método para encontrar el **camino mínimo entre todos los pares de vértices** en un grafo valorado. Funciona tanto en grafos dirigidos como no dirigidos, siempre y cuando no haya ciclos de peso negativo (es decir, caminos que bajan indefinidamente el costo de ir de un nodo a otro).

El algoritmo de Floyd-Warshall es eficiente y se basa en la programación dinámica. Crea una **matriz de distancias** donde cada elemento \((i, j)\) representa la distancia mínima entre los vértices \(i\) y \(j\). La idea es mejorar gradualmente las estimaciones de estas distancias considerando caminos intermedios de una manera ordenada.

#### Explicación del algoritmo

1. **Inicialización**:
   - Se crea una matriz \( D \) donde el valor en la posición \((i, j)\) representa inicialmente el peso directo del arco entre el vértice \(i\) y el vértice \(j\), si es que existe.
   - Si no hay arco entre \(i\) y \(j\), se inicializa como infinito (\( \infty \)), indicando que no se puede ir directamente de \(i\) a \(j\).
   - La diagonal de la matriz (de \(i\) a \(i\)) se inicializa en \(0\) porque el camino desde cualquier vértice a sí mismo tiene coste cero.

2. **Construcción de caminos**:
   - Para cada vértice intermedio \(k\), el algoritmo evalúa si pasar por \(k\) para ir de \(i\) a \(j\) ofrece un camino más corto.
   - Si se encuentra un camino más corto pasando por \(k\), se actualiza el valor en la matriz.

   La actualización se basa en la siguiente fórmula:
   \[
   D[i][j] = \min(D[i][j], D[i][k] + D[k][j])
   \]
   Esto significa que el valor \(D[i][j]\) se actualizará solo si la distancia actual entre \(i\) y \(j\) es mayor que la distancia obtenida pasando por \(k\).

3. **Repetición**:
   - El algoritmo realiza esta comparación y posible actualización para todos los pares de vértices \((i, j)\) y para cada vértice intermedio \(k\).
   - Después de considerar todos los vértices intermedios, la matriz \(D\) contendrá las distancias mínimas entre todos los pares de vértices.

Supongamos un grafo dirigido con los vértices \(A\), \(B\), \(C\), y \(D\), y los siguientes arcos y pesos:

- \(A \rightarrow B\): 3
- \(A \rightarrow C\): 10
- \(B \rightarrow C\): 1
- \(B \rightarrow D\): 2
- \(C \rightarrow D\): 4

Inicializamos la matriz de distancias, \(D\), con estos valores. Los caminos que no tienen arco directo se marcan como infinito (\( \infty \)):

$$
D = 
\begin{pmatrix}
0 & 3 & 10 & \infty \\
\infty & 0 & 1 & 2 \\
\infty & \infty & 0 & 4 \\
\infty & \infty & \infty & 0
\end{pmatrix}
$$

#### Paso 1: Considerando el vértice intermedio \(A\) (\(k = A\))

Ninguno de los caminos mejora con \(A\) como intermedio, por lo que \(D\) permanece igual.

#### Paso 2: Considerando el vértice intermedio \(B\) (\(k = B\))

Evaluamos si el camino entre \(A \rightarrow C\) mejora pasando por \(B\):
- \(D[A][C] = 10\)
- \(D[A][B] + D[B][C] = 3 + 1 = 4\) (pasando por \(B\))

Como \(4 < 10\), actualizamos \(D[A][C]\) a \(4\):

$$
D = 
\begin{pmatrix}
0 & 3 & 4 & \infty \\
\infty & 0 & 1 & 2 \\
\infty & \infty & 0 & 4 \\
\infty & \infty & \infty & 0
\end{pmatrix}
$$

Luego, evaluamos si el camino entre \(A \rightarrow D\) mejora pasando por \(B\):
- \(D[A][D] = \infty\)
- \(D[A][B] + D[B][D] = 3 + 2 = 5\)

Como \(5 < \infty\), actualizamos \(D[A][D]\) a \(5\):

$$
D = 
\begin{pmatrix}
0 & 3 & 4 & 5 \\
\infty & 0 & 1 & 2 \\
\infty & \infty & 0 & 4 \\
\infty & \infty & \infty & 0
\end{pmatrix}
$$

#### Paso 3: Considerando el vértice intermedio \(C\) (\(k = C\))

Evaluamos si el camino entre \(B \rightarrow D\) mejora pasando por \(C\):
- \(D[B][D] = 2\)
- \(D[B][C] + D[C][D] = 1 + 4 = 5\)

Como \(2 < 5\), no actualizamos \(D[B][D]\).

#### Paso 4: Considerando el vértice intermedio \(D\) (\(k = D\))

No hay mejoras posibles con \(D\) como intermedio. La matriz final de distancias mínimas es:

$$
D = 
\begin{pmatrix}
0 & 3 & 4 & 5 \\
\infty & 0 & 1 & 2 \\
\infty & \infty & 0 & 4 \\
\infty & \infty & \infty & 0
\end{pmatrix}
$$



![[archivos/imagenes/Pasted image 20241104135537.png]]

### 7.5 Control de Flujo: Algoritmo de Ford-Fulkerson

El **algoritmo de Ford-Fulkerson** es un método para encontrar el **flujo máximo** en una **red de flujo** (o grafo de flujo). Es un algoritmo fundamental en teoría de grafos, utilizado para resolver problemas de optimización en los que se busca maximizar el flujo desde un nodo fuente hasta un nodo sumidero en una red dirigida con capacidades.

Antes de entrar en el algoritmo, veamos algunos conceptos importantes:

1. **Red de flujo**: Es un grafo dirigido en el que cada arco tiene una capacidad (un valor máximo de flujo que puede pasar por el arco). La red tiene un nodo fuente (donde empieza el flujo) y un nodo sumidero (donde termina el flujo).

2. **Flujo**: Es la cantidad de "flujo" que atraviesa un arco. El flujo en un arco no puede ser negativo ni superar su capacidad.

3. **Capacidad residual**: La capacidad residual de un arco es la capacidad disponible para aumentar el flujo en dicho arco. Es igual a la capacidad del arco menos el flujo actual en él. En el caso de arcos que ya tienen flujo, se considera un arco "residual" en la dirección opuesta, que representa la posibilidad de reducir el flujo en el arco original.

4. **Camino aumentante**: Un camino aumentante es un camino de la fuente al sumidero en el grafo residual, donde todos los arcos en el camino tienen capacidad residual positiva (es decir, todavía pueden aumentar el flujo). El algoritmo utiliza estos caminos aumentantes para mejorar gradualmente el flujo total.

El algoritmo de Ford-Fulkerson consiste en buscar caminos aumentantes y aumentar el flujo en la red hasta que ya no se puedan encontrar caminos desde la fuente al sumidero. Los pasos son los siguientes:

1. **Inicializar el flujo en todos los arcos** a 0.

2. **Construir el grafo residual**: En cada iteración, crear el grafo residual a partir del flujo actual. Si hay un arco de \( u \) a \( v \) con una capacidad residual \( c_{uv} - f_{uv} \) (capacidad menos flujo actual), entonces el arco residual representa cuánto flujo se puede agregar. Además, si \( f_{uv} > 0 \), se crea un arco en sentido contrario \( v \rightarrow u \) con una capacidad residual igual a \( f_{uv} \), permitiendo reducir el flujo si es necesario.

3. **Buscar un camino aumentante en el grafo residual**: Si existe un camino desde la fuente hasta el sumidero en el grafo residual, calcular el flujo máximo que se puede enviar a través de ese camino (llamado **capacidad mínima** del camino aumentante, es decir, el arco con la menor capacidad residual en el camino).

4. **Actualizar el flujo** en cada arco del camino aumentante encontrado. Para cada arco en el camino:
   - Aumentar el flujo en el sentido de los arcos en el camino en el valor de la capacidad mínima encontrada.
   - Disminuir el flujo en los arcos residuales en la dirección opuesta (representando la capacidad de reducir el flujo si fuese necesario en futuras iteraciones).

5. **Repetir** hasta que no se puedan encontrar más caminos aumentantes de la fuente al sumidero en el grafo residual.

Al finalizar, el flujo total enviado desde la fuente al sumidero será el flujo máximo de la red.


Supongamos una red de flujo con los nodos \(S\) (fuente), \(A\), \(B\), y \(T\) (sumidero), y con las siguientes capacidades en los arcos:

- \(S \rightarrow A\): capacidad 10
- \(S \rightarrow B\): capacidad 5
- \(A \rightarrow B\): capacidad 15
- \(A \rightarrow T\): capacidad 10
- \(B \rightarrow T\): capacidad 10

1. **Inicialización**: Comenzamos con un flujo de 0 en todos los arcos.

2. **Primer camino aumentante**:
   - Supongamos que encontramos el camino \( S \rightarrow A \rightarrow T \).
   - La capacidad mínima en este camino es 10 (la capacidad de \(A \rightarrow T\)).
   - Aumentamos el flujo en este camino en 10 unidades.
   
   Flujo actualizado:
   - \(S \rightarrow A\): 10
   - \(A \rightarrow T\): 10

3. **Segundo camino aumentante**:
   - Ahora encontramos el camino \( S \rightarrow B \rightarrow T \).
   - La capacidad mínima en este camino es 5 (la capacidad de \( S \rightarrow B \)).
   - Aumentamos el flujo en este camino en 5 unidades.

   Flujo actualizado:
   - \(S \rightarrow A\): 10
   - \(A \rightarrow T\): 10
   - \(S \rightarrow B\): 5
   - \(B \rightarrow T\): 5

4. **Buscar más caminos aumentantes**:
   - En el grafo residual ya no queda ningún camino de \(S\) a \(T\) con capacidad residual positiva.

Por lo tanto, el flujo máximo desde \(S\) hasta \(T\) es de \(10 + 5 = 15\).

![[archivos/imagenes/Pasted image 20241104135641.png]]
### 7.6 Árbol de Expansión de Costo Mínimo

Un **árbol de expansión** conecta todos los vértices en un grafo con la menor suma de pesos posible entre ellos, sin ciclos.

#### Algoritmo de Prim
- Comienza desde un vértice y selecciona el arco de menor peso que conecta a un nuevo vértice.
- Continua agregando arcos de menor peso, evitando ciclos, hasta conectar todos los vértices.

Ejemplo:
Si tienes los vértices A, B, C y D conectados con pesos:
- A - B (1), B - C (3), C - D (4), D - A (2)

Prim construiría el árbol de menor costo conectando, por ejemplo: \( A \to B \to C \to D \).
![[archivos/imagenes/Pasted image 20241104135722.png]]
#### Algoritmo de Kruskal
- Selecciona los arcos en orden de menor peso, conectando componentes distintas hasta que todos los vértices estén unidos.
![[archivos/imagenes/Pasted image 20241104135756.png]]
Ambos algoritmos aseguran la construcción de un árbol que minimiza el costo de conexión entre todos los nodos del grafo.